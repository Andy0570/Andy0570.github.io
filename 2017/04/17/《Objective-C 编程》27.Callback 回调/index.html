<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="google-site-verification" content="wioXOS3Gv2wXUpJ3sLtfZ4ft6YJYKNLLWSw6QoZTFYM">
  <meta name="msvalidate.01" content="C96491A81239C517A50597C54EE53CD1">
  <meta name="baidu-site-verification" content="h8asiToN1b">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"andy0570.com","root":"/","scheme":"Gemini","version":"8.0.0-rc.5","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":"mac","bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="回调 回调（callback） 就是将一段可执行的代码和一个特定的事件绑定起来。当特定的事件发生时，就会执行这段代码。  实现回调的四种途径 目标—动作对（target-action）：在程序开始等待前，要求“当事件发生时，向指定的对象发送某个特定的消息”。这里接收消息的对象是目标（target），消息的选择器（selector）是动作（action）。 辅助对象（helper objects）：">
<meta property="og:type" content="article">
<meta property="og:title" content="《Objective-C 编程》27.Callback 回调">
<meta property="og:url" content="https://andy0570.com/2017/04/17/%E3%80%8AObjective-C%20%E7%BC%96%E7%A8%8B%E3%80%8B27.Callback%20%E5%9B%9E%E8%B0%83/index.html">
<meta property="og:site_name" content="独木舟的木">
<meta property="og:description" content="回调 回调（callback） 就是将一段可执行的代码和一个特定的事件绑定起来。当特定的事件发生时，就会执行这段代码。  实现回调的四种途径 目标—动作对（target-action）：在程序开始等待前，要求“当事件发生时，向指定的对象发送某个特定的消息”。这里接收消息的对象是目标（target），消息的选择器（selector）是动作（action）。 辅助对象（helper objects）：">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-04-17T15:33:00.000Z">
<meta property="article:modified_time" content="2019-05-01T13:16:48.000Z">
<meta property="article:author" content="独木舟的木">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="Objective-C">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://andy0570.com/2017/04/17/%E3%80%8AObjective-C%20%E7%BC%96%E7%A8%8B%E3%80%8B27.Callback%20%E5%9B%9E%E8%B0%83/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《Objective-C 编程》27.Callback 回调 | 独木舟的木</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="独木舟的木" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">独木舟的木</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">iOS Developer</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">36</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">310</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83"><span class="nav-number">1.</span> <span class="nav-text">回调</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%9B%9E%E8%B0%83%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%80%94%E5%BE%84"><span class="nav-number">1.1.</span> <span class="nav-text">实现回调的四种途径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87-%E5%8A%A8%E4%BD%9C%E5%AF%B9"><span class="nav-number">1.1.1.</span> <span class="nav-text">目标 - 动作对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.2.</span> <span class="nav-text">辅助对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%9F%A5"><span class="nav-number">1.1.3.</span> <span class="nav-text">通知</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.</span> <span class="nav-text">如何选择回调机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">1.3.</span> <span class="nav-text">回调与对象所有权</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.</span> <span class="nav-text">选择器的工作机制</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="独木舟的木"
      src="https://blog-andy0570-1256077835.cos.ap-shanghai.myqcloud.com/site_Images/avatar.png">
  <p class="site-author-name" itemprop="name">独木舟的木</p>
  <div class="site-description" itemprop="description">生若直木，不语斧凿。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">310</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FuZHkwNTcw" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Andy0570"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy83MjY1NDAwL2FuZHkwNTcw" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;7265400&#x2F;andy0570"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vdS84NGM1ZmFkYzdjMTg=" title="简书 → https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;84c5fadc7c18"><i class="heartbeat fa-fw"></i>简书</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmFuZHl3aG1AMTYzLmNvbQ==" title="E-Mail → mailto:andywhm@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2017/04/17/%E3%80%8AObjective-C%20%E7%BC%96%E7%A8%8B%E3%80%8B27.Callback%20%E5%9B%9E%E8%B0%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-andy0570-1256077835.cos.ap-shanghai.myqcloud.com/site_Images/avatar.png">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="生若直木，不语斧凿。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Objective-C 编程》27.Callback 回调
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-17 23:33:00" itemprop="dateCreated datePublished" datetime="2017-04-17T23:33:00+08:00">2017-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-05-01 21:16:48" itemprop="dateModified" datetime="2019-05-01T21:16:48+08:00">2019-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C-%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Objective-C 编程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h1><ul>
<li><strong>回调（callback）</strong> 就是将一段可执行的代码和一个特定的事件绑定起来。当特定的事件发生时，就会执行这段代码。</li>
</ul>
<h2 id="实现回调的四种途径"><a href="#实现回调的四种途径" class="headerlink" title="实现回调的四种途径"></a>实现回调的四种途径</h2><ul>
<li><strong>目标—动作对（target-action）</strong>：在程序开始等待前，要求“当事件发生时，向指定的对象发送某个特定的消息”。这里接收消息的对象是目标（target），消息的选择器（selector）是动作（action）。</li>
<li><strong>辅助对象（helper objects）</strong>：程序开始等待前，要求“当事件发生时，向遵守相应协议的辅助对象发送消息”。<strong>委托对象</strong>（delegate）和<strong>数据源</strong>（data source）是常见的辅助对象。</li>
<li><strong>通知（notification）</strong>：苹果公司提供了一种称为通知中心（notification center）的对象。在程序开始等待前，可以告知通知中心“某个对象正在等待某些特定的通知”。当事件发生时，相关的对象会向通知中心发布通知，然后再由通知中心将通知转发给正在等待该通知的对象。</li>
<li><strong>Block 对象（Blocks）</strong>： <strong>Block</strong> 是一段可执行的代码。在程序开始等待前，声明一个 <strong>Block</strong> 对象，当事件发生时，执行这段 <strong>Block</strong> 对象。</li>
</ul>
<a id="more"></a>

<h3 id="目标-动作对"><a href="#目标-动作对" class="headerlink" title="目标 - 动作对"></a>目标 - 动作对</h3><blockquote>
<p>当要向一个对象发送一个回调时，使用 <strong>目标—动作对</strong>。</p>
</blockquote>
<p>示例：</p>
<p>每隔两秒，<strong>NSTimer</strong> 对象会向其目标 （<strong>BNRLogger</strong> 实例对象）发送指定的动作消息 <code>updateLastTime:</code>。</p>
<ul>
<li><strong>main.m</strong> 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;BNRLogger.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">        BNRLogger *logger &#x3D; [[BNRLogger alloc] init];</span><br><span class="line">        </span><br><span class="line">        &#x2F;**</span><br><span class="line">         *  目标-动作对</span><br><span class="line">         *</span><br><span class="line">         *  接收消息的对象是目标（target）</span><br><span class="line">         *  消息的选择器(selector)是动作(action)</span><br><span class="line">         *    __unused 修饰符用于消除&quot;没有使用的变量&quot;警告</span><br><span class="line">         *&#x2F;</span><br><span class="line">        __unused NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:2.0</span><br><span class="line">                                       target:logger</span><br><span class="line">                                     selector:@selector(updateLastTime:)</span><br><span class="line">                                     userInfo:nil</span><br><span class="line">                                      repeats:YES];</span><br><span class="line">      </span><br><span class="line">        &#x2F;&#x2F; NSRunLoop 实例会持续等待着，当特定的事件发生时，就会向相应的对象发送消息。</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>BNRLogger.h</strong> 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface BNRLogger : NSObject</span><br><span class="line">  </span><br><span class="line">@property (nonatomic) NSDate *lastTime;</span><br><span class="line">- (NSString *)lastTimeString;</span><br><span class="line">- (void)updateLastTime:(NSTimer *)t;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>BNRLogger.m</strong> 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;BNRLogger.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation BNRLogger</span><br><span class="line">  </span><br><span class="line">- (NSString *)lastTimeString &#123;</span><br><span class="line">    static NSDateFormatter *dateFormatter &#x3D; nil;</span><br><span class="line">    if (!dateFormatter) &#123;</span><br><span class="line">        dateFormatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">        [dateFormatter setTimeStyle:NSDateFormatterMediumStyle];</span><br><span class="line">        [dateFormatter setDateStyle:NSDateFormatterMediumStyle];</span><br><span class="line">        NSLog(@&quot;create dateFormatter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return [dateFormatter stringFromDate:self.lastTime];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动作方法总是有一个实参，它是(传入发送动作消息的)那个对象</span><br><span class="line">- (void)updateLastTime:(NSTimer *)t &#123;</span><br><span class="line">    NSDate *now &#x3D; [NSDate date];</span><br><span class="line">    [self setLastTime:now];</span><br><span class="line">    NSLog(@&quot;Just set time to %@&quot;,self.lastTimeString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



<h3 id="辅助对象"><a href="#辅助对象" class="headerlink" title="辅助对象"></a>辅助对象</h3><blockquote>
<p>当要向一个对象发送多个回调时，使用符合相应协议的 <strong>辅助对象</strong>。根据用途，辅助对象常被称为委托对象或数据源（data source）。</p>
</blockquote>
<p>示例：我们知道，数据同步传输是会阻塞主线程的，也就是说，在获取数据时，用户界面会失去响应。接下来我们使用异步的方式传输网络请求数据。而且要在数据传输过程中实现回调。</p>
<ul>
<li><strong>main.m</strong> 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;BNRLogger.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">        BNRLogger *logger &#x3D; [[BNRLogger alloc] init];</span><br><span class="line">        </span><br><span class="line">        NSString *string &#x3D; @&quot;http:&#x2F;&#x2F;bit.ly&#x2F;nsurlsession-test&quot;;</span><br><span class="line">        NSURL *url &#x3D; [NSURL URLWithString:string];</span><br><span class="line">        NSURLRequest *request &#x3D; [NSURLRequest requestWithURL:url];</span><br><span class="line">        </span><br><span class="line">        &#x2F;**</span><br><span class="line">         *  首先创建一个 NSURLSessionConfiguration 对象。</span><br><span class="line">         *</span><br><span class="line">         *  NSURLSessionConfiguration 对象有一些诸如 allowsCellularAccess 、</span><br><span class="line">         *  HTTPAdditionalHeaders 等属性。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        NSURLSessionConfiguration *config &#x3D; [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">        </span><br><span class="line">        &#x2F;**</span><br><span class="line">         *  然后创建一个 NSURLSession 对象。</span><br><span class="line">         *</span><br><span class="line">         *  在真正面向对象的程序中，这将是您创建的一些对象的属性，而不仅仅是一个局部变量。</span><br><span class="line">         *  任何关于iOS开发的书（包括我们的）都将显示使用 NSURLSession 的更为正确的例子。</span><br><span class="line">         *</span><br><span class="line">         *&#x2F;</span><br><span class="line">        NSURLSession *session &#x3D; [NSURLSession sessionWithConfiguration:config</span><br><span class="line">                                                              delegate:logger</span><br><span class="line">                                                         delegateQueue:nil];</span><br><span class="line">        </span><br><span class="line">        &#x2F;**</span><br><span class="line">         *  你创建的最后一个对象是一个 NSURLSessionTask - 这与 NSURLConnection 是类似的。</span><br><span class="line">         *</span><br><span class="line">         *  不同之处在于，每个独立的 NSURLConnection 对象都具有独立的委托对象和属性。</span><br><span class="line">         *  而所有的 NSURLSessionTask 对象都被 Session 对象所拥有，</span><br><span class="line">         *  该对象只拥有一个委托对象以处理所有任务的回调。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        NSURLSessionTask *task &#x3D; [session dataTaskWithRequest:request];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 你通过发送 - resume 来告诉 task 开始工作</span><br><span class="line">        &#x2F;&#x2F; 然后 task 将根据需要将实现委托的工作返回到 Session 对象。</span><br><span class="line">        [task resume];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Don&#39;t forget that this last bit is a hack;</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 你永远不会在生产应用程序中使用它。</span><br><span class="line">        &#x2F;&#x2F; 你在这里看到它只是因为它要强制命令行应用程序保持运行。</span><br><span class="line">        &#x2F;&#x2F; 通常 main（）函数返回时应用终止运行。</span><br><span class="line">        [[NSRunLoop mainRunLoop] run];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>BNRLogger.h</strong> 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 声明 BNRLogger 会实现 NSURLSessionDelegate, NSURLSessionDataDelegate 协议</span><br><span class="line">@interface BNRLogger : NSObject &lt;NSURLSessionDelegate, NSURLSessionDataDelegate&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>BNRLogger.m</strong> 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;BNRLogger.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  我决定使用类扩展（class extension）的方式添加可变数据对象，因为这是非常流行的做法。</span><br><span class="line"> *</span><br><span class="line"> *  你应该逐渐偏向于使用属性（@property）来代替实例变量，使用访问器而不是直接读取状态，</span><br><span class="line"> *  会让你的代码更安全，并且如果当前类中的属性或实例变量不需要暴露给应用程序中的其他类，</span><br><span class="line"> *  那么你就应该使用类扩展（class extension）来隐藏它。</span><br><span class="line"> *&#x2F;</span><br><span class="line">@interface BNRLogger ()</span><br><span class="line">@property (nonatomic) NSMutableData *downloadedData;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BNRLogger</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 除了预期的方法之外，这里没有太多变化</span><br><span class="line">&#x2F;&#x2F; 另外，我使用了属性符号。</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;received %lu bytes&quot;, data.length);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果 NSMutableData 对象还不存在，就创建它</span><br><span class="line">    if (!self.downloadedData) &#123;</span><br><span class="line">        self.downloadedData &#x3D; [[NSMutableData alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 将新数据附加到现有的数据堆中。</span><br><span class="line">    [self.downloadedData appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Rather than having two methods for completion (one for success, one for failure),</span><br><span class="line">&#x2F;&#x2F; the session will call this method in either case, providing an NSError only if</span><br><span class="line">&#x2F;&#x2F; the task failed.</span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 正常情况下，就像“读取文件”章节那样，我们通常会检查数据而不是检查错误来知道是否有问题</span><br><span class="line">    &#x2F;&#x2F; 但是在这里，如果不检查错误的话，你是无法知道你收集到的数据是否完整的</span><br><span class="line">    if(!error) &#123;</span><br><span class="line">        &#x2F;&#x2F; We have all the data!</span><br><span class="line">        NSLog(@&quot;Finished! Total size is %lu bytes.&quot;, self.downloadedData.length);</span><br><span class="line">        NSString *str &#x3D; [[NSString alloc] initWithData:self.downloadedData</span><br><span class="line">                                              encoding:NSUTF8StringEncoding];</span><br><span class="line">        NSLog(@&quot;Here you go!\n%@&quot;,str);</span><br><span class="line">        NSLog(@&quot;Printed %lu characters&quot;,str.length);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;Encountered an error: \(error)&quot;);</span><br><span class="line">        self.downloadedData &#x3D; nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><blockquote>
<p>处理要发送给多个对象的回调时，使用 <strong>通知</strong>。</p>
</blockquote>
<p>示例:</p>
<p>当用户修改 Mac 系统的时区设置时，程序中的很多对象可能需要知道系统发生的这一变化。这些对象都可以通过通知中心将自己注册成为观察者（observer）。</p>
<p>当系统的时区设置发生变化时，会向通知中心发布 <strong>NSSystemTimeZoneDidChangeNotification</strong> 通知，然后通知中心会将该通知转发给相应的观察者。</p>
<ul>
<li><strong>main.m</strong> 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#import &quot;BNRLogger.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">        BNRLogger *logger &#x3D; [[BNRLogger alloc] init];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 将 BNRLogger 实例注册为观察者，使之在系统的时区设置发生变化时能够收到相应的通知。</span><br><span class="line">        [[NSNotificationCenter defaultCenter]</span><br><span class="line">                                 addObserver:logger</span><br><span class="line">                                 selector:@selector(zoneChange:)</span><br><span class="line">                                 name:NSSystemTimeZoneDidChangeNotification</span><br><span class="line">                                 object:nil];</span><br><span class="line">        </span><br><span class="line">        [[NSRunLoop mainRunLoop] run];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>BNRLogger.h</strong> 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface BNRLogger : NSObject </span><br><span class="line"></span><br><span class="line">- (void) zoneChange:(NSNotification *)note;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>BNRLogger.m</strong> 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;BNRLogger.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation BNRLogger</span><br><span class="line"></span><br><span class="line">- (void) zoneChange:(NSNotification *)note &#123;</span><br><span class="line">    NSLog(@&quot;The system time zone has changes!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>构建并运行程序，当程序处于运行状态时，打开 <strong>System Preference</strong>（系统偏好设置），修改系统的时区设置。这时，zoneChange:方法应该会被调用。</p>
<h2 id="如何选择回调机制"><a href="#如何选择回调机制" class="headerlink" title="如何选择回调机制"></a>如何选择回调机制</h2><ul>
<li><p>对于只做一件事情的对象（例如 <strong>NSTimer</strong>），使用 <strong>目标—动作对</strong>。</p>
<p>当要向一个对象发送一个回调时，使用目标—动作对。</p>
</li>
<li><p>对于功能更复杂的对象（例如 <strong>NSURLSession</strong>），使用 <strong>辅助对象</strong>。最常见的辅助对象是委托对象。</p>
<p>当要向一个对象发送多个回调时，使用符合相应协议的辅助对象。根据用途，辅助对象常被称为委托对象或数据源（data source）。</p>
</li>
<li><p>对于要触发多个（其他对象中的）回调的对象（例如 <strong>NSTimeZone</strong>），使用 <strong>通知</strong>。</p>
<p>处理要发送给多个对象的回调时，使用通知。</p>
</li>
</ul>
<h2 id="回调与对象所有权"><a href="#回调与对象所有权" class="headerlink" title="回调与对象所有权"></a>回调与对象所有权</h2><p>为了避免回调时产生强应用循环的风险（例如：创建的对象拥有一个指向回调对象的指针，而这个回调对象的指针指向你创建的对象），编写代码时，应遵守以下规则：</p>
<ul>
<li><p><strong>通知中心不拥有观察者</strong>。如果将某个对象注册为观察者，那么通常应该在释放该对象时将其移出通知中心：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">  [[NSNotificationCenter defalutCenter] removeObserver:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对象不拥有委托对象或数据源对象</strong>。如果某个新创建的对象是另一个对象的委托对象或数据源对象，那么该对象应该在其 <strong>dealloc</strong> 方法中取消响应的关联：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">  [windowThatBossesMeAround setDelegate:nil];</span><br><span class="line">  [tableViewThatBegsForDAta setDataSource:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对象不拥有目标</strong>。如果某个新创建的对象是另一个对象的目标，那么该对象应该在其 <strong>dealloc</strong> 方法中将相应的目标指针赋为 <strong>nil</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">  [buttonThatKeepsSendingMeMessage setTarget:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="选择器的工作机制"><a href="#选择器的工作机制" class="headerlink" title="选择器的工作机制"></a>选择器的工作机制</h2><p>当某个对象收到消息时，会向该对象的类进行查询，检查是否有与消息名称相匹配的方法。该查询过程会沿着继承层次结构向上，直到某个类回应“我有与消息相匹配的方法”。</p>
<p>方法的查询非常快速。如果使用方法的实际名称（可能会很长）进行查询，那么查询的速度会很慢。<strong>为了提速，编译器会为每个其接触过的方法附上一个唯一的数字</strong>。运行时，程序使用的是这个数字，而不是方法名。</p>
<p>以上提到的代表特定方法名的唯一数字称为 <strong>选择器</strong>（selector）。当一个方法需要一个选择器作为实参（就像<code>scheduledTimerWithTimeInterval:target:selector:userInfo: repeats:</code>）时，它实际就是需要这个数字。通过编译指令@selector，可以得到与方法名相对应的选择器。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>独木舟的木
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://andy0570.com/2017/04/17/%E3%80%8AObjective-C%20%E7%BC%96%E7%A8%8B%E3%80%8B27.Callback%20%E5%9B%9E%E8%B0%83/" title="《Objective-C 编程》27.Callback 回调">https://andy0570.com/2017/04/17/《Objective-C 编程》27.Callback 回调/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/04/17/iOS%20%E7%BC%96%E7%A8%8B%EF%BC%9AWKWebView/" rel="prev" title="iOS 编程：WKWebView">
      <i class="fa fa-chevron-left"></i> iOS 编程：WKWebView
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/04/18/%E3%80%8AObjective-C%20%E7%BC%96%E7%A8%8B%E3%80%8B30.Property%20List/" rel="next" title="《Objective-C 编程》30.Property List">
      《Objective-C 编程》30.Property List <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">独木舟的木</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">2.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">31:21</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>















  

  

</body>
</html>
