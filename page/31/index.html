<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
      
    
    
      
    
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">



  
  
    
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/han-css@3/dist/han.min.css">













  
  
    
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">







  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/panda/apple-touch-icon.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/panda/favicon-32x32.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/panda/favicon-16x16.png?v=7.1.0">


  <link rel="mask-icon" href="/images/panda/safari-pinned-tab.svg?v=7.1.0" color="#222">


  <link rel="manifest" href="/images/panda/site.webmanifest">


  <meta name="msapplication-config" content="/images/panda/browserconfig.xml">





<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: true,
    fastclick: true,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="有时候阳光很好 有时候阳光很暗">
<meta name="keywords" content="独木舟的木">
<meta property="og:type" content="website">
<meta property="og:title" content="独木舟的木">
<meta property="og:url" content="https://andy0570.com/page/31/index.html">
<meta property="og:site_name" content="独木舟的木">
<meta property="og:description" content="有时候阳光很好 有时候阳光很暗">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="独木舟的木">
<meta name="twitter:description" content="有时候阳光很好 有时候阳光很暗">



  <link rel="alternate" href="/atom.xml" title="独木舟的木" type="application/atom+xml">



  
  
  <link rel="canonical" href="https://andy0570.com/page/31/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>独木舟的木</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8229a094facca297f211d61323fd9fde";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/andy0570" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">独木舟的木</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">iOS Developer</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">15</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">76</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">311</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/18/《iOS编程（第四版）》Demo6：HQLHypnoNerd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/18/《iOS编程（第四版）》Demo6：HQLHypnoNerd/" class="post-title-link" itemprop="url">《iOS编程（第四版）》Demo6：HQLHypnoNerd</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-18 17:56:00" itemprop="dateCreated datePublished" datetime="2016-08-18T17:56:00+08:00">2016-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-17 17:25:35" itemprop="dateModified" datetime="2019-04-17T17:25:35+08:00">2019-04-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/18/《iOS编程（第四版）》Demo6：HQLHypnoNerd/" class="leancloud_visitors" data-flag-title="《iOS编程（第四版）》Demo6：HQLHypnoNerd">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="HQLHypnoNerd"><a href="#HQLHypnoNerd" class="headerlink" title="HQLHypnoNerd"></a>HQLHypnoNerd</h1><p>这是参照 <strong>《iOS编程（第四版）》</strong> 第6、7章写的非常杂乱的 Demo 笔记，</p>
<ul>
<li><a href="https://github.com/Andy0570/HQLHypnoNerd" target="_blank" rel="noopener">GitHub源码</a></li>
</ul>
<h1 id="窗口、视图控制器、添加视图、访问视图"><a href="#窗口、视图控制器、添加视图、访问视图" class="headerlink" title="窗口、视图控制器、添加视图、访问视图"></a>窗口、视图控制器、添加视图、访问视图</h1><h2 id="main-与UIApplication"><a href="#main-与UIApplication" class="headerlink" title="main() 与UIApplication"></a>main() 与UIApplication</h2><p>用 Objective-C 语言编写的程序的执行入口与C语言相同，都是 main() 函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="UIApplicationMain-函数"><a href="#UIApplicationMain-函数" class="headerlink" title="UIApplicationMain 函数:"></a><strong>UIApplicationMain</strong> 函数:</h3><ul>
<li><p>1️⃣ 创建一个 <strong>UIApplication</strong> 对象（每个iOS应用都有且只有一个该对象）。</p>
<p>作用:维护运行循环。</p>
</li>
<li><p>2️⃣ <strong>UIApplicationMain</strong> 函数还会创建某个指定类的对象，并将其设置为 <strong>UIApplication</strong> 对象的 delegate，该对象的类是由 <strong>UIApplicationMain</strong> 函数得最后一个实参指定的，该实参的类型是 <strong>NSString</strong> 对象，代表的某个类的类名。</p>
<ul>
<li>所以以上代码块中，<strong>UIApplicationMain</strong> 会创建一个 <strong>AppDelegate</strong> 对象，并将其设置为 <strong>UIApplication</strong> 对象的 delegate。</li>
<li>在应用启动运行循环并开始接收事件前，UIApplication对象会向其委托发送一个特定的消息（<code>didFinishLaunchingWithOptions:</code>）完成相应的初始化工作，该方法只会在应用启动完毕后调用一次。</li>
</ul>
</li>
</ul>
<p>初始化方法实现在 <strong>AppDelegate.m</strong> 文件中： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br></pre></td></tr></table></figure>
<h2 id="UIWindow"><a href="#UIWindow" class="headerlink" title="UIWindow"></a>UIWindow</h2><p>见 <a href="http://www.jianshu.com/p/92d077d82d0f" target="_blank" rel="noopener">UIWindow</a></p>
<h2 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h2><ul>
<li><p>视图控制器是 <strong>UIViewController</strong> 类或其子类的对象。每个视图控制器都负责管理一个视图层次结构，包括视图层次结构中的视图并处理相关用户事件，以及将整个视图层次结构添加到应用窗口。</p>
</li>
<li><p><strong>根视图控制器</strong><br> <strong>UIWindow</strong> 对象提供了一个方法将视图控制器的视图层次结构加入应用窗口：<code>setRootViewController</code>,当程序将某个视图控制器设置为 <strong>UIWindow</strong> 对象的 rootViewControl 时，<strong>UIWindow</strong> 对象会将该视图控制器的view作为子视图加入窗口，此外，还会自动调整view的大小，将其设置为与窗口的大小相同。<code>rootViewControl</code> 的 view 需要在应用启动完毕之后就显示，所以 <strong>UIWindow</strong> 对象会在设置完<code>rootViewControl</code> 后立刻加载其 view 。</p>
</li>
<li><p><strong>根视图控制器创建步骤：</strong></p>
<ol>
<li>创建 <strong>UIViewController</strong> 的子类<br><code>@interface myViewController : UIViewController</code></li>
<li>在 <strong>AppDelegate.h</strong> 中声明属性<br><code>@property (strong,nonatomic) UIViewController *viewController;</code></li>
<li>在 <strong>AppDelegate.m</strong> 中实现初始化</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 方法一：</span><br><span class="line">// 设置根视图控制器</span><br><span class="line">BNRMyViewController *mvc = [[BNRyViewController alloc]init]; </span><br><span class="line">self.window.rootViewController = mvc;</span><br><span class="line"></span><br><span class="line">// 方法二：</span><br><span class="line">// 获取指向 NSbundle 对象的指针，该 NSBundle 对象代表应用程序的主程序包</span><br><span class="line">// mainBundle 主程序包对应于文件系统中项目的根目录</span><br><span class="line">NSBundle *appBundle = [NSBundle mainBundle];</span><br><span class="line">// 告诉初始化方法在 appBundle 中查找 HQLReminderViewController.xib 文件</span><br><span class="line">self.viewController = [[myViewController alloc] initWithNibName:@&quot;HQLReminderViewController&quot; bundle: appBundle];</span><br><span class="line">//将 viewController 作为 window 的根视图控制器</span><br><span class="line">self.window.rootViewController =self.viewController;</span><br></pre></td></tr></table></figure>
<p>上述方法二中对【对象是通过 XIB 文件创建的根视图控制器】设置同样可使用方法一实现，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HQLReminderViewController *rvc = [[HQLReminderViewController alloc] init];</span><br><span class="line">self.window.rootViewController = rvc;</span><br></pre></td></tr></table></figure></p>
<p>为什么向一个需要使用 NIB 文件的视图控制器发送 <code>init</code> 消息也能成功加载对应的视图？</p>
<p><strong>原因</strong>：</p>
<ul>
<li><code>initWithNibName：bundle：</code> 是 <strong>UIViewController</strong> 的指定初始化方法。</li>
<li>向视图控制器发送 <code>init</code> 消息会调用指定初始化方法  <code>initWithNibName：bundle：</code> 并为两个参数都传入nil。</li>
<li>即使向一个需要使用 NIB 文件的视图控制器发送 <code>init</code> 消息，<strong>UIViewControl</strong> 对象仍然会在应用程序中查找和当前 <code>UIViewControl</code> 子类同名的 XIB 文件。</li>
<li>⚠️ 因此建议为 【<strong>UIViewController</strong> 子类】和【该子类需要载入的NIB文件】取相同的名称，这样当视图控制器需要加载视图时，会自动载入正确的XIB文件。    </li>
</ul>
<h3 id="lazy-loading-延迟加载视图"><a href="#lazy-loading-延迟加载视图" class="headerlink" title="lazy loading 延迟加载视图"></a>lazy loading 延迟加载视图</h3><ul>
<li>视图控制器不会在其被创建出来的那一刻马上创建并载入相应的视图，只有当应用需要将某个视图控制器的视图显示到屏幕上时，相应的视图控制器才会创建其视图。</li>
<li>也就是说，视图控制器刚被创建时，其 <code>view</code> 属性会被初始化为 <strong>nil</strong>。之后，当应用需要将视图控制器的视图显示到屏幕上时，如果 <code>view</code> 属性是 <strong>nil</strong>,就会自动调用 <code>loadview</code> 方法。</li>
<li>⚠️ 为了实现视图延迟加载，<code>在initWithNibName：bundle：</code>中不应该访问 <code>view</code> 或 <code>View</code> 的任何子视图。凡是和 <code>view</code>或 <code>view</code>的子视图有关的代码，都应该在 <code>viewDidLoad</code> 方法中实现，避免加载不需要在屏幕上显示的视图。</li>
<li>视图控制器可以通过两种方式创建视图层次结构<ul>
<li>代码方式：覆盖 <strong>UIViewController</strong> 中的 <code>loadView</code> 方法</li>
<li>文件方式：使用 interface builder 创建一个 NIB 文件，然后加入所需的视图层次结构，最后视图控制器会在运行时加载由该 NIB 文件编译而成的 XIB 文件。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> - (void)loadView &#123;  </span><br><span class="line"></span><br><span class="line">//创建一个 HQLHypnosisView 对象</span><br><span class="line">HQLHypnosisView *backgroundView = [[HQLHypnosisView alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</span><br><span class="line">self.view = backgroundView;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上述代码中，将 HQLHypnosisView 对象赋值给视图控制器的 <code>view</code> 属性。</p>
</li>
<li><p><code>view</code> 属性继承自 <strong>UIViewControl</strong> :</p>
<p>   <code>@property(null_resettable, nonatomic,strong) UIView *view;</code><br>   如果视图还没有被设置，那么get方法会首先调用自身的 loadView 方法，如果重写了 setter 或 getter 方法，子类必须调用父类。</p>
</li>
</ul>
<h3 id="运行循环和重绘视图"><a href="#运行循环和重绘视图" class="headerlink" title="运行循环和重绘视图"></a>运行循环和重绘视图</h3><ul>
<li>iOS 应用启动时会开始一个运行循环（run loop）。运行循环的工作是监听事件，当事件发生时运行循环会为相应的事件找到合适的处理方法（类似于单片机中的中断处理机制）,只有当调用的处理方法都执行完毕时，控制权才会再次回到运行循环。</li>
<li>当应用将控制权交回给运行循环时，运行循环首先会检查是否有等待重绘的视图（即在当前循环收到 <code>setNeedsDisplay</code> 消息的视图），然后向所有等待重绘的视图发送  <code>drawRect</code>  消息，最后视图层次结构中所有视图的图层再次组合成一幅完整的图像并绘制到屏幕上。</li>
<li>iOS 做了两方面来保证用户界面的流畅性<ol>
<li>不重绘显示的内容没有改变的视图；</li>
<li>在每次事件处理周期（event handing cycle）中只发送一次 <code>drawRect:</code> 消息。iOS 会在运行循环的最后阶段集中处理所有需要重绘的视图。</li>
</ol>
</li>
</ul>
<h2 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h2><h3 id="添加视图"><a href="#添加视图" class="headerlink" title="添加视图"></a>添加视图</h3><p><strong>frame</strong>:用于确定与视图层次结构中其他视图的相对位置，从而将自己的图层与其他视图的图层正确组合屏幕上的图像。<br><strong>bounds</strong>:用于确定绘制区域，避免将自己绘制到图层边界之外。<br><strong>frame </strong>是从父视图的坐标系统来看的，而 <strong>bounds</strong> 是从本身的坐标系统来看的.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-6b0e6cf74b47e40a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="frame与bounds的区别"></p>
<p>视图的相关结构：<br>Core Graphics( CG )</p>
<ul>
<li><p><strong>CGPoint</strong>：2D空间中的位置坐标,（x,y）<br>  生成函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* **CGSize**：某个对象的尺寸：width、height</span><br><span class="line">   生成函数：```CGSizeMake(width,height)</span><br></pre></td></tr></table></figure></p>
</li>
<li><p><strong>CGRect</strong>：位置和尺寸：origin 和 size<br> 生成函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">```objective-c</span><br><span class="line">//创建一个CGRect结构</span><br><span class="line">//CGRect firstFrame = CGRectMake(160, 240, 100, 150);</span><br><span class="line"></span><br><span class="line">CGRect firstFrame = self.window.bounds;</span><br><span class="line"></span><br><span class="line">//创建HQLHypnosisView对象</span><br><span class="line">HQLHypnosisView *firstView = [[HQLHypnosisView alloc] initWithFrame:firstFrame];</span><br><span class="line"></span><br><span class="line">//设置HQLHypnosisView背景色</span><br><span class="line">firstView.backgroundColor = [UIColor greenColor];</span><br><span class="line"></span><br><span class="line">//将HQLHypnosisView对象加入UIWindow对象</span><br><span class="line">[self.window addSubview:firstView];</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<p>也可以在 <strong>HQLHypnosisView.m</strong> 中复写 <strong>initWithFrame:</strong> 方法设置 HQLHypnosisView 背景色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">self =[super initWithFrame:frame];</span><br><span class="line">if (self) &#123;</span><br><span class="line">    //设置HQLHyponsisView对象的背景颜色为透明</span><br><span class="line">    self.backgroundColor = [UIColor clearColor];</span><br><span class="line">	&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="视图层次的嵌套"><a href="#视图层次的嵌套" class="headerlink" title="视图层次的嵌套"></a>视图层次的嵌套</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HQLHypnosisView *secondView = [[HQLHypnosisView alloc] <span class="string">initWithFrame:</span>secondFrame];</span><br><span class="line">secondView.backgroundColor = [UIColor blueColor];</span><br><span class="line"></span><br><span class="line"><span class="comment">//将 secondView 添加到 window 上</span></span><br><span class="line">[self.window <span class="string">addSubview:</span>secondView];</span><br><span class="line"></span><br><span class="line"><span class="comment">//视图层次嵌套</span></span><br><span class="line"><span class="comment">//视图的frame所代表的位置是相对于其父视角的</span></span><br><span class="line"><span class="comment">//将 secondView 添加到 firstview 上</span></span><br><span class="line">[firstView <span class="string">addSubview:</span>secondView];</span><br></pre></td></tr></table></figure>
<h3 id="访问视图"><a href="#访问视图" class="headerlink" title="访问视图"></a>访问视图</h3><p>通常情况下，在用户看到创建的视图之前需要对它们做一些额外的初始化工作。<br>两种访问NIB文件视图的方法：</p>
<ul>
<li><code>-viewDidLoad:</code> 该方法会在视图控制器加载完视图之后被调用，此时视图控制器中所有视图属性都已经指向了正确的视图对象。</li>
<li><code>-viewWillAppear:</code>该方法会在视图控制器的 view 添加到应用窗口之前被调用。<br><strong>区别：</strong> ⚠️ <strong>如果只需要在应用启动后设置一次视图对象，就选择 <code>viewDidLoad</code>；如果用户每次看到视图控制器的 view 时都需要对其进行设置，则选择 <code>viewWillAppear</code>。</strong></li>
<li><p>相反，<code>viewWillDisappear:</code> 和 <code>viewDidDisappear</code>方法会在每次视图控制器的 view 从屏幕上消失时被调用。</p>
</li>
<li><p><a href="http://www.cnblogs.com/mjios/archive/2013/02/26/2933667.html" target="_blank" rel="noopener">loadView、viewDidLoad及viewDidUnload的关系</a></p>
</li>
</ul>
<h3 id="设置启动页面延时"><a href="#设置启动页面延时" class="headerlink" title="设置启动页面延时"></a>设置启动页面延时</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//延时3秒</span><br><span class="line">[NSThread sleepForTimeInterval:3.0];</span><br></pre></td></tr></table></figure>
<h1 id="运动效果"><a href="#运动效果" class="headerlink" title="运动效果"></a>运动效果</h1><p>iOS 设备内嵌了许多功能强大的传感器，例如加速传感器，磁场传感器和三轴陀螺仪等。应用可以通过这些传感器了解设备的速度、方向和角度，并实现有用的功能。</p>
<p>例如，应用可以根据设备的方向自动将界面调整为横排模式或竖排模式。从iOS 7开始，Apple 引入了一些新API，可以轻松为应用添加一种通过感应器实现的视差（parallax）效果。</p>
<p>在 <strong>HQLHyponViewController.m</strong> 中修改<code>drawHyponticMessage:</code>方法，为 <strong>UILabel</strong> 对象分别添加水平方向和垂直方向的视差效果，使 <strong>UILabel</strong> 对象的中心点坐标在每个方向上最多移动25点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//在屏幕随机位置绘制20个UILabel对象</span><br><span class="line">- (void)drawHypnoticMessage:(NSString *)message &#123;</span><br><span class="line"></span><br><span class="line">for (int i =0; i&lt;20; i++) &#123;</span><br><span class="line">    UILabel *messageLabel = [[UILabel alloc] init];</span><br><span class="line">    //设置UILabel对象的文字和颜色</span><br><span class="line">    messageLabel.backgroundColor = [UIColor clearColor];</span><br><span class="line">    messageLabel.textColor = [UIColor whiteColor];</span><br><span class="line">    messageLabel.text = message;</span><br><span class="line">    //根据需要显示的文字调整UILabel对象的大小</span><br><span class="line">    [messageLabel sizeToFit];</span><br><span class="line">    </span><br><span class="line">    //获取随机x坐标</span><br><span class="line">    //使UILabel对象的宽度不超出HQLHyponsisViewController的view的宽度</span><br><span class="line">    int width = (int)(self.view.bounds.size.width - messageLabel.bounds.size.width);</span><br><span class="line">    int x = arc4random() % width;</span><br><span class="line">    </span><br><span class="line">    //获取随机y坐标</span><br><span class="line">    //使UILabel对象的高度不超出HQLHyponsisViewController的view的高度</span><br><span class="line">    int height = (int)(self.view.bounds.size.width - messageLabel.bounds.size.height);</span><br><span class="line">    int y =184 + arc4random() % height;</span><br><span class="line">    </span><br><span class="line">    //设置UILabel对象的frame</span><br><span class="line">    CGRect frame = messageLabel.frame;</span><br><span class="line">    frame.origin = CGPointMake(x, y);</span><br><span class="line">    messageLabel.frame = frame;</span><br><span class="line">    </span><br><span class="line">    //将UILabel对象添加到HQLHyponsisViewController的view中</span><br><span class="line">    [self.view addSubview:messageLabel];</span><br><span class="line">    </span><br><span class="line">    //运行效果:水平方向和垂直方向的视差效果</span><br><span class="line">  	//设置UILabel 对象的中心点坐标在每个方向上最多移动25点</span><br><span class="line">    UIInterpolatingMotionEffect *motionEffect;</span><br><span class="line">    motionEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@&quot;center.x&quot; type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis];</span><br><span class="line">    motionEffect.minimumRelativeValue = @(-25);</span><br><span class="line">    motionEffect.maximumRelativeValue = @(25);</span><br><span class="line">    [messageLabel addMotionEffect:motionEffect];</span><br><span class="line">    </span><br><span class="line">    motionEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@&quot;center.y&quot; type:UIInterpolatingMotionEffectTypeTiltAlongVerticalAxis];</span><br><span class="line">    motionEffect.minimumRelativeValue = @(-25);</span><br><span class="line">    motionEffect.maximumRelativeValue = @(25);</span><br><span class="line">    [messageLabel addMotionEffect:motionEffect];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LocalNotification（本地通知）"><a href="#LocalNotification（本地通知）" class="headerlink" title="LocalNotification（本地通知）"></a>LocalNotification（本地通知）</h1><p><strong>本地通知</strong>（local notification）用于向用户提示一条消息，即使应用没有运行，用户也可以收到本地通知。<br>应用还可以通过后台服务器实现推送通知（push notification）.有关推送通知的技术细节请参考Apple的Local and Push Notification Programming Guide（本地通知和推送通知编程指南）。<br>Demo:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-5bd235356d1e2922.gif?imageMogr2/auto-orient/strip" alt="locolNotification.gif"></p>
<p>实现本地通知方法代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)addReminder:(id)sender &#123;</span><br><span class="line">    </span><br><span class="line">    NSDate *date = self.datePicker.date;</span><br><span class="line">    NSLog(@&quot;Setting a reminder for %@&quot;,date);</span><br><span class="line">    </span><br><span class="line">    if ([UIApplication instancesRespondToSelector:@selector(registerUserNotificationSettings:)])&#123;</span><br><span class="line">        </span><br><span class="line">        [[UIApplication sharedApplication] registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound categories:nil]];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 创建 UILocalNotification 对象</span><br><span class="line">    UILocalNotification *note = [[UILocalNotification alloc] init];</span><br><span class="line">    // 设置显示内容</span><br><span class="line">    note.alertBody = @&quot;Hypnotize me!&quot;;</span><br><span class="line">    // 设置提醒时间</span><br><span class="line">    note.fireDate = date;</span><br><span class="line">    </span><br><span class="line">    // 使用 scheduleLocalNotification: 方法注册通知</span><br><span class="line">    [[UIApplication sharedApplication] scheduleLocalNotification:note];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;addReminder run over&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="UITabBarController"><a href="#UITabBarController" class="headerlink" title="UITabBarController"></a>UITabBarController</h1><p>参考： <a href="http://www.jianshu.com/p/33d3300afd91" target="_blank" rel="noopener">UITabBarController（标签栏）</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.jianshu.com/p/2e8ef223efef" target="_blank" rel="noopener">天才第一步，从UIWindow谈起 @吴白</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/18/《iOS编程（第四版）》Demo1：Quiz/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/18/《iOS编程（第四版）》Demo1：Quiz/" class="post-title-link" itemprop="url">《iOS编程（第四版）》Demo1：Quiz</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-18 17:08:00" itemprop="dateCreated datePublished" datetime="2016-08-18T17:08:00+08:00">2016-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-17 17:26:08" itemprop="dateModified" datetime="2019-04-17T17:26:08+08:00">2019-04-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/18/《iOS编程（第四版）》Demo1：Quiz/" class="leancloud_visitors" data-flag-title="《iOS编程（第四版）》Demo1：Quiz">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<blockquote>
<p>《iOS编程》Demo应用：Quiz</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-dac10288198f7605.gif?imageMogr2/auto-orient/strip" alt="Quiz应用"></p>
<p> 功能：在视图中显示一个问题，用户点击视图下方的按钮，可以显示相应的答案，用户点击上方的按钮，则会显示一个新的问题   </p>
<h1 id="第1章-第一个简单的iOS应用"><a href="#第1章-第一个简单的iOS应用" class="headerlink" title="第1章 第一个简单的iOS应用"></a>第1章 第一个简单的iOS应用</h1><h2 id="1-1-创建Xcode项目"><a href="#1-1-创建Xcode项目" class="headerlink" title="1.1 创建Xcode项目"></a>1.1 创建Xcode项目</h2><ul>
<li>位于工作空间窗口左侧的是导航面板区域（navigator area），负责显示各种不同的导航面板。</li>
<li>项目导航面板（project navigator）：显示项目中的文件。</li>
<li>项目导航面板中的组只用来整理文件，与文件系统无关。</li>
<li>一个类（class）表示一种对象（object）。iOS开发是面向对象的，每个iOS应用都可以看成是由一系列协同工作的对象构成的。</li>
</ul>
<h2 id="1-2-模型-视图-控制器"><a href="#1-2-模型-视图-控制器" class="headerlink" title="1.2 模型-视图-控制器"></a>1.2 模型-视图-控制器</h2><p><strong>MVC设计模式</strong>的含义：应用创建的任何一个对象，其类型必定是模型对象、视图对象或者控制器对象三种类型中的一个。</p>
<ul>
<li>【视图对象】是用户可以看见的对象，用来构建用户界面。</li>
<li>【模型对象】负责存储数据，与用户界面无关。通常情况下，【模型对象】表示真实世界中与用户相关的事物。</li>
<li>【控制器对象】扮演“管家”的角色，它用于控制【视图对象】为用户呈现的内容，以及负责确保【视图对象】和【模型对象】的数据保持一致。</li>
</ul>
<blockquote>
<p>⚠️  【模型对象】和【视图对象】之间没有直接产生联系，而是由【控制器对象】负责彼此间的消息发送和数据传递。</p>
</blockquote>
<h2 id="1-3-设计Quiz"><a href="#1-3-设计Quiz" class="headerlink" title="1.3 设计Quiz"></a>1.3 设计Quiz</h2><p>开发中需要使用的对象：</p>
<ul>
<li>四个视图对象：<strong>UILabel</strong> 和 <strong>UIButton</strong>；</li>
<li>两个控制器对象：<strong>AppDelegate</strong>、<strong>QuizViewControl</strong>的对象各一个；</li>
<li>两个模型对象：<strong>NSArray</strong> 的对象两个；</li>
</ul>
<h2 id="1-4-创建视图控制器"><a href="#1-4-创建视图控制器" class="headerlink" title="1.4 创建视图控制器"></a>1.4 创建视图控制器</h2><h2 id="1-5-创建界面"><a href="#1-5-创建界面" class="headerlink" title="1.5 创建界面"></a>1.5 创建界面</h2><ul>
<li><p>Xcode 会使用 Interface Builder （界面创建工具）打开 XIB 文件。Interface Builder 是一种可视化编辑器，可以用拖动对象的方式创建图形用户界面。</p>
</li>
<li><p>XIB 的全称就是 XML Interface Builder。</p>
</li>
</ul>
<h3 id="创建视图对象"><a href="#创建视图对象" class="headerlink" title="创建视图对象"></a>创建视图对象</h3><h3 id="NIB文件"><a href="#NIB文件" class="headerlink" title="NIB文件"></a>NIB文件</h3><p>构建项目时，所有XIB文件都会被编译成NIB文件（NIB文件体积更小，更容易解析），然后Xcode会将NIB文件拷贝至应用的程序包（bundle）中。</p>
<h2 id="1-6-创建关联"><a href="#1-6-创建关联" class="headerlink" title="1.6 创建关联"></a>1.6 创建关联</h2><p>在 Interface Builder中可以创建两种关联</p>
<ul>
<li><strong>插座变量</strong>（outlets）:指向对象的指针；</li>
<li><strong>动作</strong>（actions）：一种方法，在视图对象和用户发生交互时被调用。</li>
</ul>
<h3 id="设置插座变量"><a href="#设置插座变量" class="headerlink" title="设置插座变量"></a>设置插座变量</h3><h2 id="1-7-创建模型对象"><a href="#1-7-创建模型对象" class="headerlink" title="1.7 创建模型对象"></a>1.7 创建模型对象</h2><p><a href="https://github.com/Andy0570/QUIZ.git" target="_blank" rel="noopener">gitHub下载</a></p>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul>
<li><a href="http://www.infoq.com/cn/articles/rethinking-mvc-mvvm" target="_blank" rel="noopener">被误解的MVC和被神化的MVVM</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/08/Objective-C_异常处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/08/Objective-C_异常处理/" class="post-title-link" itemprop="url">Objective-C_异常处理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-08 10:48:00" itemprop="dateCreated datePublished" datetime="2016-08-08T10:48:00+08:00">2016-08-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-15 21:22:06" itemprop="dateModified" datetime="2019-04-15T21:22:06+08:00">2019-04-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C-编程/" itemprop="url" rel="index"><span itemprop="name">Objective-C 编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/08/Objective-C_异常处理/" class="leancloud_visitors" data-flag-title="Objective-C_异常处理">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><hr>
<p><strong>异常</strong>：当程序执行时，发生的某种特殊状况,打断了正常的运转流程。</p>
<ul>
<li>Objective-C 的异常处理语法与Java和C++类似。通过使用 <strong>NSException</strong>, <strong>NSError</strong> 以及自定义的异常处理类来处理这些异常。</li>
<li>Objective-C 对异常的支持包括四个编译器指令: <strong>@try</strong>、<strong>@catch</strong>、<strong>@throw</strong> 以及 <strong>@finally</strong>。使用规则:              </li>
<li>如果这句或这部分代码有可能出现问题,就把它放在<code>@try{}</code>中.</li>
<li><code>@catch</code> 捕获异常,出现了问题后,会执行到这里,然后你就可以对错误进行另外的处理,比如记录日志或者提醒用户哪错了。</li>
<li><code>@finally</code> 无论是否会抛出异常,这个块中的代码都会执行。 </li>
<li><code>@throw</code>指令允许你抛出自己的异常。可以使用该指令抛出特定的异常。</li>
</ul>
<p><strong>异常分类:</strong></p>
<ol>
<li>数组越界;</li>
<li>不能识别的方法选择器;</li>
<li>野指针调用：指针指向销毁的对象;</li>
</ol>
<p>示例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @try 块中写有可能出错的代码段</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> array];</span><br><span class="line">    [array objectAtIndex:<span class="number">1</span>];  <span class="comment">//数组越界</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @catch 块内处理异常代码</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"捕获到异常：%@%@"</span>,exception.name, exception.reason);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">@finally</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可选项，不管是否出现异常，都会执行此代码段</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"始终执行的代码！"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>Demo[17328:3652315] 捕获到异常：NSRangeException*** -[__NSArray0 objectAtIndex:]: index 1 beyond bounds for empty NSArray<br>Demo[17328:3652315] 始终执行的代码！<br>Demo[17328:3652315] Hello, World!</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/08/Objective-C_方法调用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/08/Objective-C_方法调用/" class="post-title-link" itemprop="url">Objective-C_方法调用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-08 10:48:00" itemprop="dateCreated datePublished" datetime="2016-08-08T10:48:00+08:00">2016-08-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-15 21:15:28" itemprop="dateModified" datetime="2019-04-15T21:15:28+08:00">2019-04-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C-编程/" itemprop="url" rel="index"><span itemprop="name">Objective-C 编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/08/Objective-C_方法调用/" class="leancloud_visitors" data-flag-title="Objective-C_方法调用">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>OC语言中采用特定的语言调用类或者实例(对象)的方法称为<strong>发送消息</strong>或<strong>方法调用</strong>。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法调用格式：[对象 方法名];</span></span><br><span class="line">[<span class="meta">Person1 shopping</span>];   </span><br><span class="line"><span class="comment">// 调用带参数的方法 </span></span><br><span class="line">[<span class="meta">Person2 goshopping:200.0</span>];</span><br></pre></td></tr></table></figure></p>
<h3 id="set、get方法"><a href="#set、get方法" class="headerlink" title="set、get方法"></a>set、get方法</h3><p>set、get方法用来访问和修改对象里面的属性值。</p>
<ul>
<li>set方法是对某一个属性设值。</li>
<li>get方法是获取某一个属性值。<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义设置器方法   </span></span><br><span class="line"><span class="comment">//年龄的设置器方法：给对象的年龄设置的   </span></span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">setAge:</span>(NSInteger)age;   </span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">setName:</span>(NSString *)name;   </span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">setWeight:</span>(<span class="keyword">float</span>)weight;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.定义多个参数的设置器方法   </span></span><br><span class="line"><span class="comment">//方法名：setName:setAge:setweight:   </span></span><br><span class="line">-(<span class="keyword">void</span>)<span class="string">setAge:</span>(NSInteger)age   <span class="string">setName:</span>(NSString *)name   <span class="string">setWeight:</span>(<span class="keyword">float</span>)weight;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.定义访问器方法   </span></span><br><span class="line"><span class="comment">//访问器方法：用于访问对象的属性值   </span></span><br><span class="line"><span class="comment">//OC里的命名规范:get方法名不需要加get前缀   </span></span><br><span class="line">-(NSInteger)age;   </span><br><span class="line">-(NSString *)name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>在类的外部如：<em>main.m</em> 文件中想要给对象设置属性，要通过调用相应的设置器方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式：[对象 方法名]</span></span><br><span class="line"><span class="comment">// set 方法</span></span><br><span class="line">[Person setAge:<span class="number">34</span>];   </span><br><span class="line">[Person setName:<span class="string">@"张三"</span>];   </span><br><span class="line">[Person setWeight:<span class="number">80</span>];&lt;br /&gt;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// get 方法  </span></span><br><span class="line"><span class="comment">// 用age变量接收调用的方法返回值   </span></span><br><span class="line"><span class="built_in">NSInteger</span> age = [Person age ];   </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"person的年龄：%ld"</span>,age);   </span><br><span class="line"><span class="built_in">NSString</span> *name = [Person name];   </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"person的名字：%@"</span>,name);   </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 点语法</span></span><br><span class="line"><span class="comment">//点语法只能调用 set 和 get 方法</span></span><br><span class="line">Person.age = <span class="number">34</span>;   <span class="comment">//等效于 [Person setAge:34]; </span></span><br><span class="line"><span class="built_in">NSInteger</span> age = Person.age; <span class="comment">//等效于 NSInteger age = [Person age ];</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>字符串<br>  OC中字符串都是以@开头的,比如@<code>&quot;Hello&quot;</code>是OC中的字符串。</li>
<li>控制台打印<br>   C语言中使用<code>printf(&quot;Hello&quot;)</code>打印字符串, OC中使用NSLog函数打印字符串:<code>NSLog(@&quot;Hello&quot;)</code>;</li>
<li>把一个对象使用%@打印，实际上是调用了此对象的description，然后取的此方法的返回值打印。   <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,book);     </span><br><span class="line"><span class="comment">//与下面的方法等价       </span></span><br><span class="line"><span class="built_in">NSString</span> *desc = [book description];        </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,desc);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><ul>
<li>对象必须先创建,然后初始化,才能使用。如：<code>NSObject *object = [[NSObject alloc] init];</code>；</li>
<li>OC中的对象通过指针来声明。如：<code>Person *p</code> ；</li>
<li>初始化方法，是创建对象alloc之后调用，并且只能调用一次；</li>
<li>方法名必须以init开头；</li>
<li>返回值类型是id类型；<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义初始化方法，将姓名传入   </span></span><br><span class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">initWithName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">name</span>;</span><br><span class="line"><span class="comment">//多个参数的初始化方法的定义   </span></span><br><span class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">initWithName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">name</span> <span class="selector-tag">WithAge</span><span class="selector-pseudo">:(NSInteger)age</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="自定义初始化方法的实现"><a href="#自定义初始化方法的实现" class="headerlink" title="自定义初始化方法的实现"></a>自定义初始化方法的实现</h4><p>在<strong>init方法</strong>中,若要父类完成所需的一次性初始化,需要调用<code>[super init]</code>,init方法返回的值,描述了被初始化的对象。<br>将<code>[super init]</code>的结果赋给<code>self</code>是<strong>Objective-C</strong>的标准惯例,这么做是为了防止父类在初始化过程中返回的对象不同于原先创建的对象。</p>
<pre><code>- (id)initWithName:(NSString *)name{
//使用super可以调用父类中定义的方法
self = [super init];
if (self) {
    //赋值
    _name = name;
} 
return self;
</code></pre><p>}</p>
<p>####调用初始化方法</p>
<pre><code>Person *p1 = [[Person alloc] init];
Person *p2 = [[Person alloc] initWithName:@&quot;jack&quot;];
Person *p3 = [[Person alloc] initWithName:@&quot;Tom&quot; WithAge:22];
</code></pre><p><strong>initWithCString</strong>: c语言的字符串转换成OC的字符串<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *outputValue = [[<span class="built_in">NSString</span> alloc] initWithCString:inputValue encoding: <span class="built_in">NSUTF8StringEncoding</span>];</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/08/Objective-C_Foundation框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/08/Objective-C_Foundation框架/" class="post-title-link" itemprop="url">Objective-C_Foundation框架</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-08 10:48:00" itemprop="dateCreated datePublished" datetime="2016-08-08T10:48:00+08:00">2016-08-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-15 21:16:42" itemprop="dateModified" datetime="2019-04-15T21:16:42+08:00">2019-04-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C-编程/" itemprop="url" rel="index"><span itemprop="name">Objective-C 编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/08/Objective-C_Foundation框架/" class="leancloud_visitors" data-flag-title="Objective-C_Foundation框架">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Foundation框架"><a href="#Foundation框架" class="headerlink" title="Foundation框架"></a>Foundation框架</h3><ul>
<li><strong>框架</strong>是由许多类、方法、函数组成的一个类库。以便于开发者更方便的开发程序。</li>
<li>许多框架的集合构成了<strong>SDK（开发工具包）</strong>。</li>
<li><strong>Foundation</strong>是OC语言的基础类库。此框架中的类都以 “NS” 为前缀,便于与其他类区分开。</li>
<li><strong>UIKit框架</strong>是UI界面的基础库<br>Foundation中的大部分类都提供了两种方式创建对象:<ul>
<li>alloc创建：<code>NSNumber *number1 = [[NSNumber alloc] initWithInt:100];</code></li>
<li>类方法创建：<code>NSNumber *number2 = [NSNumber numberWithInt:100];</code> </li>
</ul>
</li>
</ul>
<h3 id="NSObject类、延迟调用"><a href="#NSObject类、延迟调用" class="headerlink" title="NSObject类、延迟调用"></a>NSObject类、延迟调用</h3><p><strong>NSObject</strong>类是一切类的根类(基类),它是没有父类,它是所有对象的“生命”方法,也是了对象生终的“终结”。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>比较两个指针是否指向同一个对象(指针是否指向同一个内存区域)<br>  <code>- (BOOL)isEqual:(id)object;</code></li>
<li>调用一个方法<br>  <code>- (id)performSelector:(SEL)aSelector;</code></li>
<li>调用一个方法,并且传递一个参数<br>  <code>- (id)performSelector:(SEL)aSelector withObject:(id)object;</code></li>
<li>调用一个方法,并且传递2个参数<br>  <code>- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</code></li>
<li>某一个对象是否派生或属于某一类<br>  <code>- (BOOL)isKindOfClass:(Class)aClass;</code></li>
<li>某一个对象是否属于某类<br>  <code>- (BOOL)isMemberOfClass:(Class)aClass;</code></li>
<li>某对象是否响应指定的方法<br>  <code>- (BOOL)respondsToSelector:(SEL)aSelector;</code></li>
<li><p>返回指定对象的父类和本类<br>  <code>- (Class)superclass;  - (Class)class;</code></p>
<p>  例：假设 demo1 是一个私有方法（在 .m 文件中实现，但在 .h 文件中没有声明的方法）</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//创建了一个方法选择器，封装demo1方法   </span></span><br><span class="line">	SEL selector1 = <span class="meta">@selector</span>(demo1);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//在performSelector方法中调用selector1方法选择器，也就是demo1</span></span><br><span class="line">   [<span class="keyword">super</span> <span class="string">performSelector:</span>selector1];</span><br><span class="line">	[self <span class="string">performSelector:</span>selector1];  <span class="comment">//同上</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//perform调用带1个参数的方法，@"hello"传给了demo2:的形参</span></span><br><span class="line">    [self <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">demo2:</span>)</span><br><span class="line"><span class="symbol">               withObject:</span>@<span class="string">"hello"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用带2个参数的方法</span></span><br><span class="line">	[self <span class="string">performSelector:</span>(SEL)</span><br><span class="line"><span class="symbol">	              withObject:</span>(id)</span><br><span class="line"><span class="symbol">	               withObject:</span>(id)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//延迟调用</span></span><br><span class="line">    [self demo1];  <span class="comment">//没有延迟，立马调用demo1方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//延迟调用demo1，但是代码执行到此处时，不会停在此处3秒钟</span></span><br><span class="line">    [self <span class="string">performSelector:</span><span class="meta">@selector</span>(demo1) <span class="string">withObject:</span>nil <span class="string">afterDelay:</span><span class="number">3.0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>//让程序保持运行状态
[[NSRunLoop currentRunLoop] run];
</code></pre><hr>
<h4 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h4><ul>
<li><a href="http://www.jianshu.com/p/c4eadf54cd25" target="_blank" rel="noopener">第16章——NSString</a></li>
</ul>
<hr>
<h4 id="NSMutableString"><a href="#NSMutableString" class="headerlink" title="NSMutableString"></a>NSMutableString</h4><ul>
<li><a href="http://www.jianshu.com/p/b628c48be542" target="_blank" rel="noopener">第16章——NSMutableString</a></li>
</ul>
<hr>
<h4 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h4><ul>
<li><a href="http://www.jianshu.com/p/aaa89e070f84" target="_blank" rel="noopener">第17章——NSArray</a></li>
</ul>
<hr>
<h4 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h4><ul>
<li><a href="http://www.jianshu.com/p/64443aecc4dd" target="_blank" rel="noopener">第17章——NSMutableArray</a></li>
</ul>
<hr>
<h4 id="Collection-类"><a href="#Collection-类" class="headerlink" title="Collection 类"></a>Collection 类</h4><ul>
<li><a href="http://www.jianshu.com/p/d84d570fe6a9" target="_blank" rel="noopener">第24章——Collection 类</a></li>
</ul>
<hr>
<h4 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h4><ul>
<li><a href="http://www.jianshu.com/p/6fa0926dd478" target="_blank" rel="noopener">NSNumber</a></li>
</ul>
<hr>
<h4 id="NSValue"><a href="#NSValue" class="headerlink" title="NSValue"></a>NSValue</h4><ul>
<li><a href="http://www.jianshu.com/p/928502aba37a" target="_blank" rel="noopener">NSValue</a></li>
</ul>
<hr>
<h4 id="NSNull"><a href="#NSNull" class="headerlink" title="NSNull"></a>NSNull</h4><p>我们之前提到,不能在集合(collection) 中存储nil值,因为字典和数组中nil都有特殊的含义,但有时候你确实需要存储一个表示“什么都没有”的值。那就用 <strong>NSNull</strong> 代替,表示什么都不是,什么都没有。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [zhangsan,lisi,  ,zhaoliu];</span></span><br><span class="line">NSNull *<span class="keyword">null</span> = [NSNull <span class="keyword">null</span>];</span><br><span class="line">NSArray *<span class="keyword">array</span> = @[@<span class="string">"zhagnsan"</span>,@<span class="string">"lisi"</span>,<span class="keyword">null</span>,@<span class="string">"zhaoliu"</span>];</span><br></pre></td></tr></table></figure>
<h5 id="线上的一个实际例子："><a href="#线上的一个实际例子：" class="headerlink" title="线上的一个实际例子："></a>线上的一个实际例子：</h5><p>本意：如果用户已经成功登录，就获取存储在磁盘上的用户名：<br> <code>NSDictionary *dictionary = @{@&quot;username&quot;:_username};</code><br>实际生产环境中，发生了这样的情况：判断用户已经登录成功，但是无法获取用户名导致应用crash。<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">attachDatas:</span></span><br><span class="line"><span class="symbol">Exception:</span>&#123;</span><br><span class="line">    Name = NSInvalidArgumentException<span class="comment">;</span></span><br><span class="line">    Reason = <span class="string">"*** -[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[0]"</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最初的修复方法是，判断为nil,就传入一个空字符串： @””：<br><code>NSDictionary *dictionary = @{@&quot;username&quot;:_username?:@&quot;&quot;};</code><br>规范的方法是传入一个空对象：<br> <code>NSDictionary *dictionary = @{@&quot;username&quot;:_username?:[NSNull null]};</code><br>参考：<a href="http://nshipster.cn/nil/" target="_blank" rel="noopener">nshipster: nil / Nil / NULL / NSNull</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/08/Objective-C_面向对象—封装、继承、多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/08/Objective-C_面向对象—封装、继承、多态/" class="post-title-link" itemprop="url">Objective-C_面向对象—封装、继承、多态</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-08 10:48:00" itemprop="dateCreated datePublished" datetime="2016-08-08T10:48:00+08:00">2016-08-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-15 21:15:58" itemprop="dateModified" datetime="2019-04-15T21:15:58+08:00">2019-04-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C-编程/" itemprop="url" rel="index"><span itemprop="name">Objective-C 编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/08/Objective-C_面向对象—封装、继承、多态/" class="leancloud_visitors" data-flag-title="Objective-C_面向对象—封装、继承、多态">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征:"></a>面向对象的三大特征:</h3><ol>
<li>封装 (Encapsulation) </li>
<li>继承 (Inheritance)</li>
<li>多态 (Polymorphism)</li>
</ol>
<h3 id="封装、权限修饰符（-public、-private、-protected）"><a href="#封装、权限修饰符（-public、-private、-protected）" class="headerlink" title="封装、权限修饰符（@public、@private、@protected）"></a>封装、权限修饰符（@public、@private、@protected）</h3><ul>
<li>隐藏属性、方法或者实现细节的过程称之为<strong>封装</strong>。   </li>
<li><strong>权限修饰符</strong>用来修饰<strong>实例变量</strong>,用来控制实例变量的访问权限。</li>
<li>在语法上，不存在私有<strong>方法</strong>。但约定：在 .m 文件中实现，但在 .h 文件中没有声明的方法称之为<strong>私有方法</strong>。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="comment">/*    属性的封装</span></span><br><span class="line"><span class="comment"> *   1.使类的属性不让外部直接访问</span></span><br><span class="line"><span class="comment"> */</span>  <span class="number">2.</span>外部使用这个类时，不需要关心这个类具有哪些属性</span><br><span class="line">   </span><br><span class="line"><span class="comment">//@public 修饰的成员变量，外部可以直接访问</span></span><br><span class="line"><span class="comment">//不建议直接使用，因为破坏了属性的封装性</span></span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">   <span class="built_in">NSString</span> *_name;    <span class="comment">//名称</span></span><br><span class="line">   <span class="built_in">NSString</span> *_color;   <span class="comment">//颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@private 是私有属性，只能在类的内部访问</span></span><br><span class="line"><span class="comment">// 子类不能访问private修饰的属性</span></span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">   <span class="keyword">float</span> width;    <span class="comment">//车宽</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@protected 受保护的属性，</span></span><br><span class="line"><span class="comment">//类的内部，子类都可以访问，类的外部不能访问</span></span><br><span class="line"><span class="keyword">@protected</span>  <span class="comment">//默认的修饰</span></span><br><span class="line">   <span class="keyword">float</span> _capcity; <span class="comment">//耗油量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@package</span>  <span class="comment">//修饰的变量只能在当前所在的框架中访问</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*方法的封装</span></span><br><span class="line"><span class="comment">1.对功能实现的细节隐藏于封装</span></span><br><span class="line"><span class="comment">2.保护属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)run;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装还可以保护属性值的有效性</span></span><br><span class="line">- (<span class="keyword">void</span>)setCapicity:(<span class="keyword">float</span>)capicity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<pre><code>//.m 文件实现中
//调用方法时可以对属性值的有效性进行判断
- (void)setCapicity:(float)capicity{
if (capicity &lt; 0) {
    //给出错误处理
    return 0;
}
_capcity = capicity;
}
</code></pre><p>​    </p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>子类具有父类的一般特性（包括属性和行为），以及自身特殊的特性。</li>
<li>定义一个通用的类,它有基本的实例变量。子类可以继承了该类,就可以拥有这些实例变量。子类也可以定义自己的实例变量。</li>
<li>被继承的类叫<strong>超类</strong>或<strong>父类</strong>(<strong>superclass</strong>),继承超类的类叫<strong>子类</strong>或<strong>派生类</strong>(s<strong>ubclass</strong>)。</li>
<li>OC中继承的语法规则为: <code>@interface 子类 :父类</code></li>
<li>子类自动继承父类的属性和方法</li>
<li>OC语言的类都是<strong>单继承</strong>，即一个子类只能有一个父类。</li>
<li>（<em>多继承即一个子类可以有多个父类，它继承了多个父类的特性</em>）</li>
</ul>
<p><strong>父类：</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="string">ClassA :</span> NSObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">&#125; </span><br><span class="line">- (<span class="keyword">void</span>) run; </span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>子类：</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="string">ClassB :</span> ClassA  </span><br><span class="line">- (<span class="keyword">void</span>) printVar;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><ul>
<li>通过方法重写，子类可以改变从父类继承的行为。</li>
<li>被重写的方法定义必须与父类中的方法完全一样。</li>
<li>方法重写必须满足两个条件1.必须要有继承关系；2.重写方法的方法名、参数列表必须都一致；<br>例如：重写 init 初始化方法。</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>多态是指同一种类型,具有多种表现形态。</li>
<li>多态的条件：1.必须存在继承关系。2.子类重写父类的方法。3.父类声明的变量指向子类对象。</li>
</ul>
<ul>
<li><strong>多态</strong>能够使来自不同类的对象定义相同名称的方法（不同的类可以有相同的方法名）。</li>
<li><strong>动态类型</strong>能使程序直到执行时才确定对象所属的类。</li>
<li><strong>动态绑定</strong>能使程序直到执行时才确定实际要调用的对象方法。<blockquote>
<p>Objective-C 系统总是跟踪对象所属的类:<br>含义：先判定对象所属的类，然后在运行时确定需要动态调用的方法，而不是在编译的时候。</p>
</blockquote>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-842d1057e0081625.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="isKindOfClass-amp-isMemberOfClass"><a href="#isKindOfClass-amp-isMemberOfClass" class="headerlink" title="isKindOfClass:&amp;isMemberOfClass:"></a><code>isKindOfClass:</code>&amp;<code>isMemberOfClass:</code></h3><ul>
<li><code>isKindOfClass:</code>确定一个对象是否是一个类的成员,或者是派生自该类的成员。</li>
<li><code>isMemberOfClass:</code>确定一个对象是否是当前类的成员。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/08/Objective-C_KVO、KVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/08/Objective-C_KVO、KVC/" class="post-title-link" itemprop="url">Objective-C_KVO、KVC</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-08 10:48:00" itemprop="dateCreated datePublished" datetime="2016-08-08T10:48:00+08:00">2016-08-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-15 21:18:09" itemprop="dateModified" datetime="2019-04-15T21:18:09+08:00">2019-04-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C-编程/" itemprop="url" rel="index"><span itemprop="name">Objective-C 编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/08/Objective-C_KVO、KVC/" class="leancloud_visitors" data-flag-title="Objective-C_KVO、KVC">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><hr>
<h5 id="键值编码的基本概念"><a href="#键值编码的基本概念" class="headerlink" title="键值编码的基本概念"></a>键值编码的基本概念</h5><ol>
<li><strong>KVC</strong> 是 <strong>KeyValue Coding</strong> 的简称，它是一种可以直接通过字符串的名字(key)来访问属性的机制。使用该机制不需要调用存取方法和变量实例就可访问对象属性。本质上讲，键-值编码定义了你的程序存取方法需要实现的样式及方法签名。</li>
<li>在应用程序中实现键-值编码兼容性是一项重要的设计原则。存取方法可以加<br>强合适的数据封装，而键-值编码方法在多数情况下可简化程序代码。</li>
<li>键-值编码方法在 Objective-C 非标准协议（类目）<strong>NSKeyValueCoding</strong>中被声明，默认的实现方法由 <strong>NSObject</strong> 提供，所以凡是继承自 <strong>NSObject</strong> 的类都具备 KVC 功能。</li>
<li>键-值编码支持带有对象值的属性，同时也支持纯数值类型和结构。非对象参<br>数和返回类型会被识别并自动封装/解封。</li>
</ol>
<h5 id="设置和访问"><a href="#设置和访问" class="headerlink" title="设置和访问"></a>设置和访问</h5><ul>
<li>键/值编码中的基本调用包括 <code>-valueForKey：</code> 和 <code>-setValue：forkey：</code> 这两个<br>方法，它们以字符串的形式向对象发送消息，字符串是我们关注属性的关键。</li>
</ul>
<p>示例1：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BNRAppliance *a = [[BNRAppliance alloc] init];</span><br><span class="line"></span><br><span class="line">[a <span class="string">setProductName:</span>@<span class="string">"Washing Machine"</span>];</span><br><span class="line"><span class="comment">// 使用 KVC 重写以上代码</span></span><br><span class="line"> [a <span class="string">setValue:</span>@<span class="string">"Washing Machine"</span> <span class="string">forKey:</span>@<span class="string">"productName"</span>];</span><br><span class="line">        </span><br><span class="line">[a <span class="string">setVoltage:</span><span class="number">240</span>];</span><br><span class="line"><span class="comment">// 使用 KVC 重写以上代码</span></span><br><span class="line">[a <span class="string">setValue:</span>[NSNumber <span class="string">numberWithInt:</span><span class="number">240</span>] <span class="string">forKey:</span>@<span class="string">"voltage"</span>];</span><br><span class="line">        </span><br><span class="line"> NSLog(@<span class="string">"a is %@"</span>,a);</span><br><span class="line"> <span class="comment">// 使用 KVC 重写以上代码</span></span><br><span class="line"> NSLog(@<span class="string">"the product name is %@"</span>,[a <span class="string">valueForKey:</span>@<span class="string">"productName"</span>]);</span><br></pre></td></tr></table></figure></p>
<p>示例2：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person *<span class="keyword">jack </span>= [[Person alloc] init]<span class="comment">;</span></span><br><span class="line">NSMutableString *name = [[NSMutableString alloc] initWithFormat:@<span class="string">"jack"</span>]<span class="comment">;</span></span><br><span class="line">[<span class="keyword">jack </span>setValue:name forKey:@<span class="string">"name"</span>]<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">"jack name : %@"</span>, [<span class="keyword">jack </span>valueForKey:@<span class="string">"name"</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>使用KVC，编译器会查找是否存在 <strong>setter</strong>、<strong>getter</strong> 方法，如果不存在，它将在内部查找名为 <strong>_key</strong> 或 <strong>key</strong> 的实例变量。通过 KVC，可以获取不存在<strong>getter</strong>方法的对象值，无需通过对象指针直接访问。</li>
<li>KVC 能够在没有存取方法的情况下直接存取实例变量。</li>
<li>⚠️非对象类型：当我们通过 <code>setValue：forKey：</code> 设置对象的值，或通过<br><code>valueForKey</code> 来获取对象的值时，如果对象的实例变量为基本数据类型（<strong>char、int、float、BOOL</strong>）时，我们需要使用 <strong>NSNumber</strong> 对象对数据进行 <strong>封装</strong>。</li>
</ul>
<h5 id="key路径"><a href="#key路径" class="headerlink" title="key路径"></a>key路径</h5><ul>
<li>除了通过键设置值外，键/值编码还支持指定路径，像文件系统一样。用“点”<br>号隔开。</li>
<li>使用 key path 可以一次性遍历复杂的对象表。</li>
<li>注意顺序，第一个想要遍历的对象放在第一个。</li>
</ul>
<p>示例：<br><code>BNRDepartment. manager</code> 指向 <code>BNREmployee. emergencyContact</code> 指向 <code>BNRPerson. phoneNumber</code></p>
<pre><code>BNRDepartment *sales = ...;
BNREmployee *sickEmployee = [sales valueForKey:@&quot;manager&quot;];
BNRPerson *personToCall = [sickEmployee valueForKey:@&quot;emergencyContact&quot;];
[personToCall setValue:@&quot;555-606-0842&quot; forKey:@&quot;phoneNumber&quot;];

// 使用 Key路径 重写以上代码
BNRDepartment *sales = ...;
[personToCall setValue:@&quot;555-606-0842&quot;
            forKeyPath:@&quot;manager.emergencyContact.phoneNumber&quot;];
</code></pre><h4 id="一对多的关系"><a href="#一对多的关系" class="headerlink" title="一对多的关系"></a>一对多的关系</h4><ul>
<li>如果向 <strong>NSArray</strong> 请求一个键值，它实际上会查询数组中的每个对象来查找这个<br>键值，然后将查询结果打包到另一个数组中并返回给你。</li>
</ul>
<pre><code>NSArray *booksArray = [NSArray arrayWithObjects:book1, book2, nil];
[book1 release];
[book2 release];
[book setValue:booksArray forKey:@&quot;relativeBooks&quot;];
NSLog(@&quot;books 2: %@&quot;, [book valueForKeyPath:@&quot;relativeBooks.price&quot;]);
</code></pre><h4 id="实现简单的运算"><a href="#实现简单的运算" class="headerlink" title="实现简单的运算"></a>实现简单的运算</h4><pre><code>NSString *count = [book valueForKeyPath:@&quot;relativeBooks.@count&quot;];
NSLog(@&quot;count : %@&quot;, count);
NSString *sum = [book valueForKeyPath:@&quot;relativeBooks.@sum._price&quot;];
NSLog(@&quot;sum : %@&quot;, sum);
NSString *avg = [book valueForKeyPath:@&quot;relativeBooks.@avg._price&quot;];
NSLog(@&quot;avg : %@&quot;, avg);
NSString *min = [book valueForKeyPath:@&quot;relativeBooks.@min._price&quot;];
NSLog(@&quot;min : %@&quot;, min);
NSString *max = [book valueForKeyPath:@&quot;relativeBooks.@max._price&quot;];
NSLog(@&quot;max : %@&quot;, max);
</code></pre><h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><hr>
<h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ol>
<li><strong>Key Value Observing</strong>，直译为：基于键值的观察者。它提供一种机制，当指定的对象的属性被修改后，则对象就会接受到通知。简单的说就是每次指定的被观察对象的属性被修改后，KVO就会自动通知相应的观察者了。</li>
<li>与 <strong>NSNotification</strong>不同，键-值观察中并没有所谓的中心对象来为所有观察者提供变化通知。取而代之地，当有变化发生时，通知被直接发送至处于观察状态的对象。<strong>NSObject</strong> 提供这种基础的键-值观察实现方法。   </li>
<li>你可以观察任意对象属性，包括简单属性，对一或是对多关系。对多关系的观察者将会被告知发生变化的类型-也就是任意发生变化的对象。</li>
<li>键-值观察为所有对象提供自动观察兼容性。你可以通过禁用自动观察通知并<br>实现手动通知来筛选通知。</li>
</ol>
<h5 id="注册观察者"><a href="#注册观察者" class="headerlink" title="注册观察者"></a>注册观察者</h5><p>为了正确接收属性的变更通知，观察对象必须首先发送一个<br><code>addObserver:forKeyPath:options:context:</code>消息至被观察对象，用以传送观察<br>对象和需要观察的属性的关键路径，以便与其注册。选项参数指定了发送变更通知时提供给观察者的信息。 使用<code>NSKeyValueObservingOptionOld</code>选项可以将<br>初始对象值 以变更字典中的一个项的形式提供给观察者。指定<br><code>NSKeyValueObservingOptionNew</code>选项可以将新的值以一个项的形式 添加至<br>变更字典。你可以使用逐位“|”这两个常量来指定接收上述两种类型的值。<br>示例：</p>
<pre><code>BNRLogger *logger = [[BNRLogger alloc] init];
__unused NSTimer *timer =
            [NSTimer scheduledTimerWithTimeInterval:2.0
                                             target:logger
                                           selector:@selector(updateLastTime:)
                                           userInfo:nil
                                            repeats:YES];

BNRObserver *observer = [[BNRObserver alloc] init];
// 无论 lastTime 何时发生变化，都要通知我它改变的新值以及改变之前的旧值
[logger addObserver:observer
         forKeyPath:@&quot;lastTime&quot;
            options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld
            context:nil];

[[NSRunLoop mainRunLoop] run];
</code></pre><h5 id="接受变更后通知"><a href="#接受变更后通知" class="headerlink" title="接受变更后通知"></a>接受变更后通知</h5><ul>
<li>当对象的一个被观察属性发生变动时，观察者收到一个<br><code>observeValueForKeyPath:ofObject:change:context:</code>消息。所有观察者都必须<br>实现这一方法。触发观察通知的对象和键路径、包含变更细节的字典，以及观察者<br>注册时提交的上下文指针均被提交给观察者，<code>context</code>可以为任意类型参数。<br>示例：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *oldValue = [change objectForKey:<span class="built_in">NSKeyValueChangeOldKey</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *newValue = [change objectForKey:<span class="built_in">NSKeyValueChangeNewKey</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Observed:%@ of %@ was changed from %@ to %@"</span>,</span><br><span class="line">          keyPath,object,oldValue,newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="移除观察者身份"><a href="#移除观察者身份" class="headerlink" title="移除观察者身份"></a>移除观察者身份</h5><ul>
<li>你可以发送一条指定观察方对象和键路径的<code>removeObserver:forKeyPath:</code><br>消息至被观察的对象，来移除一个键-值观察者。（当我们达到目的时）<br>示例：</li>
</ul>
<pre><code>[child removeObserver:self forKeyPath:@&quot;key&quot;];
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/08/Objective-C_SandBox&NSFileManager/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/08/Objective-C_SandBox&NSFileManager/" class="post-title-link" itemprop="url">Objective-C_SandBox&NSFileManager</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-08 10:48:00" itemprop="dateCreated datePublished" datetime="2016-08-08T10:48:00+08:00">2016-08-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-15 21:17:26" itemprop="dateModified" datetime="2019-04-15T21:17:26+08:00">2019-04-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C-编程/" itemprop="url" rel="index"><span itemprop="name">Objective-C 编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/08/Objective-C_SandBox&NSFileManager/" class="leancloud_visitors" data-flag-title="Objective-C_SandBox&NSFileManager">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><a href="http://www.jianshu.com/p/a30ae4746aca" target="_blank" rel="noopener">APP的沙盒文档结构、获取沙盒目录</a></li>
</ul>
<h4 id="SandBox"><a href="#SandBox" class="headerlink" title="SandBox"></a>SandBox</h4><ul>
<li>iOS中每个应用程序都有一个单独封闭的文件夹，这个文件夹称为沙盒（sandbox）</li>
<li>沙盒目录用来存放App的本地文件</li>
<li>当前APP应用程序没有权限访问其他APP的沙盒。</li>
<li>沙盒目录：<ul>
<li>Docunments :存放长期使用的文件。</li>
<li>Library :系统存放文。</li>
<li>tmp : 临时文件，App重启时，该目录下的文件清空。</li>
</ul>
</li>
</ul>
<h5 id="获取沙盒Home路径"><a href="#获取沙盒Home路径" class="headerlink" title="获取沙盒Home路径"></a>获取沙盒Home路径</h5><p><code>NSString *homeDir = NSHomeDirectory();</code></p>
<h5 id="文件路径的追加"><a href="#文件路径的追加" class="headerlink" title="文件路径的追加"></a>文件路径的追加</h5><pre><code>NSString *homeDir = NSHomeDirectory(); 

NSString *documents = [homeDir stringByAppendingString:@&quot;/Documents&quot;];   
NSString *documents = [homeDir stringByAppendingPathComponent:@&quot;Documents&quot;]; //注意：不需要加‘/’
</code></pre><h5 id="获取沙盒下的Documents目录"><a href="#获取沙盒下的Documents目录" class="headerlink" title="获取沙盒下的Documents目录"></a>获取沙盒下的Documents目录</h5><pre><code>NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *documents = [paths lastObject];
NSLog(@&quot;documents = %@&quot;,documents);
</code></pre><h5 id="NSString处理路径"><a href="#NSString处理路径" class="headerlink" title="NSString处理路径"></a>NSString处理路径</h5><pre><code>//演示路径 
NSString *path = @&quot;/Users/apple/file.text&quot;;

1.获取路径的组成部分  结果: (“/”,”Users”, “apple”, “file.text”) 
NSArray *components = [path pathComponents];

2.路径的最后一个组成部分   结果: file.text
NSString *lastName = [path lastPathComponent]；

3.追加文件或目录  结果: /Users/apple/file.text/app.text
NSString *filePath = [path stringByAppendingPathComponent:@&quot;app.text&quot;];

4.删除最后部分的组成部分 结果: /Users/apple
NSString *filePath = [path stringByDeletingLastPathComponent];

5. 取路径最后部分的扩展名 结果: text
NSString *extName = [path pathExtension];

6. 追加扩展名   结果: /Users/apple/file.text.jpg
NSString *filePath = [path stringByAppendingPathExtension:@&quot;jpg&quot;];
</code></pre><p>​    </p>
<h4 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h4><ul>
<li><strong>NSData</strong> 是对数据的一种抽象.</li>
<li><p>任何数据都可以通过 <strong>NSData</strong> 来存储,<strong>NSMutableData</strong> 是可变的,继承于NSData.</p>
<h5 id="NSString-NSData"><a href="#NSString-NSData" class="headerlink" title="NSString  NSData"></a>NSString <-> NSData</-></h5><pre><code>NSString *s = @&quot;NSData是对数据的一种抽象&quot;;

//NSString -&gt; NSData
NSData *data1 = [s dataUsingEncoding:NSUTF8StringEncoding];

//NSData -&gt; NSString
NSString *s2 =[[NSString alloc] initWithData:data1 encoding:NSUTF8StringEncoding];
</code></pre></li>
</ul>
<h4 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h4><ul>
<li><strong>NSFileManager</strong> 主要对文件进行管理,主要有如下功能:创建、复制、删除、剪切等</li>
</ul>
<h5 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h5><pre><code>//创建 NSFileManager 对象
NSFileManager *fileManager = [[NSFileManager alloc] init];    
NSFileManager *fileManager = [NSFileManager defaultManager];  //同上

//1.构造文件的路径
NSString *homePath = NSHomeDirectory();
NSString *filePath = [homePath stringByAppendingPathComponent:@&quot;file.txt&quot;];

//2.构造数据
NSString *string = @&quot;Hello World!&quot;;

//3.将字符串中的文本数据存储到Data对象中
NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];

//4.创建文件
//createFileAtPath 创建文件，如果文件已经存在，那么新创建的文件会将原文件覆盖
BOOL success = [fileManager createFileAtPath:filePath //路径
                                        contents:data //数据
                                      attributes:nil]; //属性
if (success) {
        NSLog(@&quot;create file success&quot;);
    }
</code></pre><h5 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h5><pre><code>[fileManager createDirectoryAtPath:(NSString *) withIntermediateDirectories:(BOOL) attributes:(NSDictionary *) error:(NSError *__autoreleasing *)] 
</code></pre><h5 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h5><pre><code>//创建 NSFileManager 对象
NSFileManager *fileManager = [NSFileManager defaultManager]; 

//构造文件的路径
NSString *homePath = NSHomeDirectory();
NSString *filePath = [homePath stringByAppendingPathComponent:@&quot;file.txt&quot;];

//根据路径读取文件
NSData *fileData = [fileManager contentsAtPath:filePath];

//将NSData转NSString
NSString *content = [[NSString alloc] initWithData:fileData
                             encoding:NSUTF8StringEncoding];
</code></pre><h5 id="移动，剪切文件"><a href="#移动，剪切文件" class="headerlink" title="移动，剪切文件"></a>移动，剪切文件</h5><pre><code>NSFileManager *fileManager = [NSFileManager defaultManager];

//构造路径
//文件的原路径
NSString *srcPath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;file.txt&quot;];     
//文件剪切之后的路径
NSString *toPath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;temp/file.txt&quot;];

//注意：如果目标路径已经存在此文件，那么会导致操作失败
NSError *error = nil;
BOOL success = [fileManager moveItemAtPath:srcPath
                                        toPath:toPath
                                         error:&amp;error];
if (!success) {
    NSLog(@&quot;剪切失败,%@&quot;,error);
    }
</code></pre><h5 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h5><pre><code>NSFileManager *fileManager = [NSFileManager defaultManager];

//1.构造路径
//文件的原路径
NSString *srcPath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;temp/file.txt&quot;];    
//文件复制之后的路径
NSString *toPath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;file.txt&quot;];

BOOL success = [fileManager copyItemAtPath:srcPath
                                        toPath:toPath
                                         error:nil];
/注意：如果目标路径已经存在此文件，那么会导致操作失败
if (!success) {
        NSLog(@&quot;复制失败&quot;);
    }
</code></pre><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><pre><code>NSFileManager *fileManager = [NSFileManager defaultManager];

//1.构造文件路径
NSString *toPath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;file.txt&quot;];

//2.判断文件是否存在
BOOL exist = [fileManager fileExistsAtPath:toPath];
if (exist) {
//3.删除文件
    if ([fileManager removeItemAtPath:toPath error:nil]) {
            NSLog(@&quot;删除文件成功&quot;);
        }
    }
</code></pre><h5 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h5><pre><code>NSString *dir = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;temp&quot;];
[fileManager removeItemAtPath:dir error:nil];
</code></pre><h5 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h5><pre><code>NSFileManager *fileManager = [NSFileManager defaultManager];

//1.构造文件路径    
NSString *filePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;file.txt&quot;];

//获得文件的属性字典     
NSDictionary *fileAttribute = [fileManager attributesOfItemAtPath:filePath error:nil];
NSLog(@&quot;%@&quot;,fileAttribute);

//获取文件大小    
NSNumber *fileSize = [fileAttribute objectForKey:@&quot;NSFileSize&quot;];
long size = [fileSize longValue];
NSLog(@&quot;size = %ld&quot;,size);
</code></pre><h5 id="获取文件夹中所有的文件"><a href="#获取文件夹中所有的文件" class="headerlink" title="获取文件夹中所有的文件"></a>获取文件夹中所有的文件</h5><pre><code>NSFileManager *fileManager = [NSFileManager defaultManager];

//1.构造路径
NSString *filePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;壁纸&quot;];

//2.获取文件夹中所有的子文件路径(路径是相对路径)
NSArray *subPaths = [fileManager subpathsOfDirectoryAtPath:filePath error:nil];

//3.遍历每一个子路径
long sum = 0;
for (NSString *subpath in subPaths) {

//4.子路径与父路径拼接
NSString *path = [filePath stringByAppendingPathComponent:subpath];

//5.获取文件的属性，计算所有文件占用内存大小
NSDictionary *fileAttribute = [fileManager attributesOfItemAtPath:path error:nil];

NSNumber *filesize = fileAttribute[@&quot;NSFileSize&quot;];
long size = [filesize longValue];
sum += size;
}
//6.单位换算
float result = sum / (1000*1000.0);
NSLog(@&quot;result = %.1f&quot;,result);
</code></pre><h5 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h5><ul>
<li>数组、字典、字符串、NSData都是容纳数据的,他们都有一个writeToFile方法, 将数据写入文件。</li>
<li>数组、字典写入的文件叫属性列表 (plist) 文件,可以用xcode打开编辑。</li>
<li>数组只能将如下数据类型写入文件,如果包含其他对象,将写入失败。NSNumber、NSString、NSData、NSDate、NSArray、NSDictionary</li>
</ul>
<pre><code>//数组写文件
NSString *s1 = @&quot;zhangsan&quot;; 
NSString *s2 = @&quot;lisi&quot;; 
NSArray *array = [NSArray arrayWithObjects:s1,s2, nil];
</code></pre><p>​<br>​    //将数组中的数据写入文件<br>​    [array writeToFile:path atomically:YES]; </p>
<h5 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h5><pre><code>//数组读文件
//1.通过alloc创建，并读入文件数据
NSArray *alloc = [[NSArray alloc] initWithContentsOfFile:path]; 

//2.通过类方法创建，并读入文件数据
MSArray *array = [NSArray arrayWithContentsofFile:path];
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/08/iOS 编程：NSDate（时间类）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/08/iOS 编程：NSDate（时间类）/" class="post-title-link" itemprop="url">iOS 编程：NSDate（时间类）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-08 10:48:00" itemprop="dateCreated datePublished" datetime="2016-08-08T10:48:00+08:00">2016-08-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-17 17:33:28" itemprop="dateModified" datetime="2019-04-17T17:33:28+08:00">2019-04-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C-编程/" itemprop="url" rel="index"><span itemprop="name">Objective-C 编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/08/iOS 编程：NSDate（时间类）/" class="leancloud_visitors" data-flag-title="iOS 编程：NSDate（时间类）">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>💡<br>推荐使用的时间类框架：<br><a href="https://github.com/MatthewYork/DateTools" target="_blank" rel="noopener">DateTools</a> | <a href="https://www.jianshu.com/p/10c5a9e60880" target="_blank" rel="noopener">DateTools 使用「日期工具库」</a></p>
</blockquote>
<h1 id="NSDate"><a href="#NSDate" class="headerlink" title="NSDate"></a>NSDate</h1><ul>
<li><strong>NSDate</strong>: 用于处理日期的类，它提供日期的创建、比较、计算时间间隔等功能。</li>
<li><strong>NSDate</strong> 是一个类簇，我们所使用的 <strong>NSDate</strong> 对象，都是 <strong>NSDate</strong> 的私有子类的实体。</li>
<li><strong>NSDate</strong> 存储的是 <strong>GMT</strong> 时间，使用的时候会根据当前应用指定的 <strong>时区</strong> 进行时间上的增减，以供计算或显示。</li>
</ul>
<h3 id="创建时间对象"><a href="#创建时间对象" class="headerlink" title="创建时间对象"></a>创建时间对象</h3><ul>
<li>当前时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 现在时间</span><br><span class="line">NSDate *now1 = [NSDate date];</span><br><span class="line">// 现在时间（同上）</span><br><span class="line">NSDate *now2 = [[NSDate alloc] init];</span><br><span class="line">NSDate *now3 = [NSDate new];</span><br></pre></td></tr></table></figure>
<ul>
<li>未来时间和过去时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 可以表示的最远的未来时间 : 4001-01-01 00:00:00 +0000</span><br><span class="line">NSDate *distantFuture = [NSDate distantFuture];</span><br><span class="line">// 可以表示的最早的过去时间 : 0000-12-30 00:00:00 +0000</span><br><span class="line">NSDate *distantPast = [NSDate distantPast];</span><br></pre></td></tr></table></figure>
<ul>
<li>创建相对时间 = 某个时间节点 + 时间戳（<strong>NSTimeInterval</strong>）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ----------------------------- 类方法 --------------------------------</span><br><span class="line">// 相对于当前时间</span><br><span class="line">NSDate *dateFromNow = [NSDate dateWithTimeIntervalSinceNow:0];</span><br><span class="line">// 相对于给定的某个已知时间</span><br><span class="line">NSDate *dateFromAnotherDate = [NSDate dateWithTimeInterval:0 sinceDate:now];</span><br><span class="line">// 相对于2001年1月1日0时0分0秒</span><br><span class="line">NSDate *dateFromReferenceDate = [NSDate dateWithTimeIntervalSinceReferenceDate:0];</span><br><span class="line">// 相对于1970年1月1日0时0分0秒</span><br><span class="line">NSDate *dateFrom1970 = [NSDate dateWithTimeIntervalSince1970:0];</span><br><span class="line"></span><br><span class="line">// ------------------------------ 实例化方法 (同上)-------------------------------</span><br><span class="line">// 相对于当前时间</span><br><span class="line">NSDate *dateFromNow2 = [[NSDate alloc] initWithTimeIntervalSinceNow:0];</span><br><span class="line">// 相对于给定的某个已知时间</span><br><span class="line">NSDate *dateFromAnotherDate2 = [[NSDate alloc] initWithTimeInterval:0 sinceDate:now];</span><br><span class="line">// 相对于2001年1月1日0时0分0秒</span><br><span class="line">NSDate *dateFromReferenceDate2 = [[NSDate alloc] initWithTimeIntervalSinceReferenceDate:0];</span><br><span class="line">// 相对于1970年1月1日0时0分0秒</span><br><span class="line">NSDate *dateFrom19702 = [[NSDate alloc] initWithTimeIntervalSince1970:0];</span><br></pre></td></tr></table></figure>
<ul>
<li>昨天、今天、明天</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 24H 的时间戳值</span><br><span class="line">NSTimeInterval time = 24 * 60 * 60;  </span><br><span class="line"></span><br><span class="line">//昨天此刻的时间</span><br><span class="line">NSDate *yesterday = [[NSDate alloc] initWithTimeIntervalSinceNow:- time];</span><br><span class="line">//现在的时间</span><br><span class="line">NSDate *today = [[NSDate alloc] initWithTimeIntervalSinceNow:0]; </span><br><span class="line">//明天此刻的时间</span><br><span class="line">NSDate 	*tomorrow = [[NSDate alloc] initWithTimeIntervalSinceNow:time];</span><br></pre></td></tr></table></figure>
<ul>
<li>日期的比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// -------------------------------------------------------------</span><br><span class="line">// 1. 通过 compare: 比较</span><br><span class="line">NSComparisonResult result = [tomorrow compare:yesterday];</span><br><span class="line">switch (result) &#123;</span><br><span class="line">    case NSOrderedAscending:</span><br><span class="line">        // 升序</span><br><span class="line">        NSLog(@&quot;tomorrow &lt; yesterday&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case NSOrderedSame:</span><br><span class="line">        // 相同</span><br><span class="line">        NSLog(@&quot;tomorrow = yesterday&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case NSOrderedDescending:</span><br><span class="line">        // 降序</span><br><span class="line">        NSLog(@&quot;tomorrow &gt; yesterday&quot;);</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">// 2. 通过时间戳值比较</span><br><span class="line">if ([date1 timeIntervalSince1970] &gt;</span><br><span class="line">    [date3 timeIntervalSince1970])&#123;</span><br><span class="line">    NSLog(@&quot;date1 &gt; date3&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    NSLog(@&quot;date1 &lt; date3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">// 3. isEqualToDate:</span><br><span class="line">if (![yesterday isEqualToDate:tomorrow]) &#123;</span><br><span class="line">NSLog(@&quot;不同的一天&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">// 4. earlierDate:</span><br><span class="line">// 比较两个给定日期并返回更早的日期</span><br><span class="line">NSDate *earlierDate = [tomorrow earlierDate:yesterday];</span><br><span class="line">NSLog(@&quot;earlierDate: %@&quot;,earlierDate);	// earlierDate: Wed Apr 12 12:30:36 2017</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">// 5. laterDate:</span><br><span class="line">// 比较两个给定日期并返回更晚的日期</span><br><span class="line">NSDate *laterDate = [tomorrow laterDate:yesterday];</span><br><span class="line">NSLog(@&quot;laterDate: %@&quot;,laterDate);	// laterDate: Fri Apr 14 12:30:36 2017</span><br></pre></td></tr></table></figure>
<ul>
<li>创建某个指定日期</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//mikey.hireDate = [NSDate dateWithNaturalLanguageString:@&quot;Aug 2nd,2010&quot;];</span><br><span class="line"></span><br><span class="line">//Specifying date</span><br><span class="line">NSDateComponents *components = [NSDateComponents new];</span><br><span class="line">[components setYear:2010];</span><br><span class="line">[components setDay:2];</span><br><span class="line">[components setMonth:8];</span><br><span class="line">//We need this calendar so that we can use -dateFromComponents function:)</span><br><span class="line">NSCalendar *gregorian = [[NSCalendar alloc] initWithCalendarIdentifier: NSCalendarIdentifierGregorian];</span><br><span class="line">//Assigning final date to our Object/Employee</span><br><span class="line">mikey.hireDate = [gregorian dateFromComponents: components];</span><br><span class="line">//Giving date nice look (Aug %day, %year)</span><br><span class="line">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</span><br><span class="line">dateFormatter.timeStyle = NSDateFormatterNoStyle;</span><br><span class="line">dateFormatter.dateStyle = NSDateFormatterMediumStyle;</span><br><span class="line">//Displays time in ENG (or localization), i get russian output by default without these two lines: Август 2, 2010</span><br><span class="line">NSLocale *usLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US&quot;];</span><br><span class="line">[dateFormatter setLocale:usLocale];</span><br><span class="line">//Applying dateFormatter to our date(mikey.hireDate), because it needs to look fancy... the result will be string, i just don&apos;t know how to make mikey.hireDate look right (%month %day, %year) without converting it to String    :&#125;</span><br><span class="line">NSString *finalDateItsStringNow = [dateFormatter stringFromDate:mikey.hireDate];</span><br><span class="line"></span><br><span class="line">//----------</span><br><span class="line">NSCalendar *calendar = [NSCalendar currentCalendar];</span><br><span class="line">NSDateComponents *components = [[NSDateComponents alloc] init];</span><br><span class="line">[components setYear:1998];</span><br><span class="line">[components setMonth:5];</span><br><span class="line">[components setDay:1];</span><br><span class="line">NSDate *birthday = [calendar dateFromComponents:components];</span><br></pre></td></tr></table></figure>
<h1 id="NSTimeInterval"><a href="#NSTimeInterval" class="headerlink" title="NSTimeInterval"></a>NSTimeInterval</h1><ul>
<li><strong>NSTimeInterval（时间戳）</strong>：用于指定两个时间节点之间的时间间隔（以秒为单位）。</li>
<li><strong>NSTimeInterval</strong> 始终以 <strong>秒</strong> 为单位指定; 它在10,000年的范围内产生了亚毫秒的精度。</li>
</ul>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef double NSTimeInterval;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取时间戳</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// -------------------------------------------------------------</span><br><span class="line">// 给定时间 相对于 现在时间 的时间戳</span><br><span class="line">NSDate *now = [NSDate date];</span><br><span class="line">NSTimeInterval timeInterval = [now timeIntervalSinceNow];</span><br><span class="line">NSLog(@&quot;timeInterval is %f&quot;,timeInterval); // timeInterval is -0.000023</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">// 两个给定时间节点 之间的时间戳</span><br><span class="line">NSDate *distantFuture = [NSDate distantFuture];</span><br><span class="line">NSDate *distantPast = [NSDate distantPast];</span><br><span class="line">NSTimeInterval timeInterval = [distantFuture timeIntervalSinceDate:distantPast];</span><br><span class="line">NSLog(@&quot;timeInterval is %.f&quot;,timeInterval);	// timeInterval is 126227980800</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">// 2001年1月1日0时0分0秒 与 现在时间 之间的时间戳</span><br><span class="line">NSDate *now = [NSDate date];</span><br><span class="line">NSTimeInterval timeInterval = [now timeIntervalSinceReferenceDate];</span><br><span class="line">NSLog(@&quot;timeInterval is %f&quot;,timeInterval); // timeInterval is 513745346.558782</span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">// 1970年1月1日0时0分0秒 与 现在时间 之间的时间戳</span><br><span class="line">NSDate *now = [NSDate date];</span><br><span class="line">NSTimeInterval timeInterval = [now timeIntervalSince1970];</span><br><span class="line">NSLog(@&quot;timeInterval is %f&quot;,timeInterval); // timeInterval is 1492052119.655184</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>NSDate</strong>对象 与 时间戳（<strong>NSTimeInterval</strong>） 相互转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// NSDate对象 ------&gt; 相对于1970年的时间戳</span><br><span class="line">NSDate *now =[[NSDate alloc] init]; //创建此刻的时间</span><br><span class="line">NSTimeInterval timeInterval = [now timeIntervalSince1970]; </span><br><span class="line"></span><br><span class="line">// 相对于1970年的时间戳 ------&gt; NSDate 对象</span><br><span class="line">NSDate *date = [NSDate dateWithTimeIntervalSince1970:timeInterval]; //获取时间</span><br></pre></td></tr></table></figure>
<ul>
<li>数字字符串 ——&gt; 时间戳 ——&gt; <strong>NSDate</strong> 对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *timeString = @&quot;1234567890&quot;;</span><br><span class="line">NSDate *convertDate = [NSDate dateWithTimeIntervalSince1970:[timeString doubleValue]];</span><br><span class="line">NSLog(@&quot;convertDate %@&quot;, convertDate);	// convertDate Sat Feb 14 07:31:30 2009</span><br></pre></td></tr></table></figure>
<h1 id="NSDateFormatter"><a href="#NSDateFormatter" class="headerlink" title="NSDateFormatter"></a>NSDateFormatter</h1><p><strong>NSDateFormatter</strong> 是 <strong>NSFormatter</strong> 的子类。另，<strong>NSFormatter</strong> 的用途是“将数据在字符串与特定类型的对象之间转换”，目前 <strong>NSFormatter</strong> 只有两个子类 <strong>NSNumberFormatter</strong> 和 <strong>NSDateFormatter</strong>。</p>
<p>尽管 <strong>NSDateFormatter</strong> 提供了许多已定义好的时间格式，但是开发中开发人员更加喜欢自定义时间格式。</p>
<p>过多使用 <strong>NSDateFormatter</strong> 将影响程序的性能，且程序中 <strong>NSDateFormatter</strong> 对象的时间格式基本一致，所以使用 <strong>NSDateFormatter</strong> 的时候尽量使用单例模式。</p>
<ul>
<li><a href="http://www.jianshu.com/p/82c1104aea6c" target="_blank" rel="noopener">性能优化之 NSDateFormatter</a></li>
</ul>
<ol>
<li><p>将时间字符串转换到 <strong>NSDate</strong> 对象，一般都是使用”年月日 时分秒”，数据库中的date类型基本上也是这样的时间类型。 格式一般为：yyyy-MM-dd HH:mm:ss。</p>
<blockquote>
<p>⚠️ yyyy是小写的；大写的YYYY的意思有些不同——“将这一年中第一周的周日当作今年的第一天”，因此有时结果和yyyy相同，有时就会不同。</p>
</blockquote>
</li>
<li><p>将 <strong>NSDate</strong> 对象转换成特定格式的字符串。</p>
<p>转换后的字符串会根据设备的“区域格式”，显示特定语言的结果。假如程序需要保证不同语言环境下显示一致，请注意这方面的问题，使用其他代替方法！</p>
</li>
</ol>
<p>日期格式RFC文档：<a href="http://www.unicode.org/reports/tr35/tr35-25.html#Date_Format_Patterns" target="_blank" rel="noopener">Date_Format_Patterns</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">NSLog(@&quot;date = %@\n&quot;,date);</span><br><span class="line">// date = 2017-10-27 05:03:09 +0000</span><br><span class="line"></span><br><span class="line">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</span><br><span class="line">[dateFormatter setTimeZone:[NSTimeZone defaultTimeZone]];</span><br><span class="line">[dateFormatter setLocale:[NSLocale currentLocale]];</span><br><span class="line">[dateFormatter setDateFormat:@&quot;yyyy-MM-dd aHH:mm:ss&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 2017-10-27 下午13:30:52</span><br><span class="line"></span><br><span class="line">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;公元（G=GG=GGG=GGGG=GGGGG）&apos;:G&apos;=&apos;GG&apos;=&apos;GGG&apos;=&apos;GGGG&apos;=&apos;GGGGG&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 公元（G=GG=GGG=GGGG=GGGGG）:公元=公元=公元=公元=公元</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;年度（y=yy=yyy=yyyy=yyyyy）&apos;:y&apos;=&apos;yy&apos;=&apos;yyy&apos;=&apos;yyyy&apos;=&apos;yyyyy&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 年度（y=yy=yyy=yyyy=yyyyy）:2017=17=2017=2017=02017</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;季度（Q=QQ=QQQ=QQQQ）&apos;:Q&apos;=&apos;QQ&apos;=&apos;QQQ&apos;=&apos;QQQQ&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 季度（Q=QQ=QQQ=QQQQ）:4=04=4季度=第四季度</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;季度（q=qq=qqq=qqq）&apos;:q&apos;=&apos;qq&apos;=&apos;qqq&apos;=&apos;qqqq&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 季度（q=qq=qqq=qqq）:4=04=4季度=第四季度</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;月份（M=MM=MMM=MMMM=MMMMM）&apos;:M&apos;=&apos;MM&apos;=&apos;MMM&apos;=&apos;MMMM&apos;=&apos;MMMMM&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 月份（M=MM=MMM=MMMM=MMMMM）:10=10=10月=十月=10</span><br><span class="line">// 月份（M=MM=MMM=MMMM=MMMMM）:3=03=3月=三月=3</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;本年第几周（w）&apos;:w&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 本年第几周（w）:43</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;本月第几周（W）&apos;:W&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 本月第几周（W）:4</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;本年第几天（D）&apos;:D&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 本年第几天（D）:300</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;本月第几天（d=dd）&apos;:d&apos;=&apos;dd&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 本月第几天（d=dd）:27=27</span><br><span class="line">// 本月第几天（d=dd）:3=03</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;本周第几天（F）&apos;:F&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 本周第几天（F）:4</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;星期（e=ee=eee=eeee=eeeee）&apos;:e&apos;=&apos;ee&apos;=&apos;eee&apos;=&apos;eeee&apos;=&apos;eeeee&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 星期（e=ee=eee=eeee=eeeee）:6=06=周五=星期五=五</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;星期（c=ccc=cccc=ccccc）&apos;:c&apos;=&apos;ccc&apos;=&apos;cccc&apos;=&apos;ccccc&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 星期（c=ccc=cccc=ccccc）:6=周五=星期五=五</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;上午/下午（a）&apos;:a&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 上午/下午（a）:下午</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;小时（h=hh=H=HH）&apos;:h&apos;=&apos;hh&apos;=&apos;H&apos;=&apos;HH&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 小时（h=hh=H=HH）:1=01=13=13</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;分钟（m=mm）&apos;:m&apos;=&apos;mm&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 分钟（m=mm）:3=03</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;秒（s=ss）&apos;:s&apos;=&apos;ss&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 秒（s=ss）:9=09</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;毫秒（S）&apos;:S&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 毫秒（S）:9</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;一天中的毫秒（A）&apos;:A&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 一天中的毫秒（A）:46989943</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;时区（z/zz/zzz=zzzz=v=vvvv）&apos;:z&apos;=&apos;zzzz&apos;=&apos;v&apos;=&apos;vvvv&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 时区（z/zz/zzz=zzzz=v=vvvv）:GMT+8=中国标准时间=中国时间=中国标准时间</span><br><span class="line"></span><br><span class="line">[dateFormatter setDateFormat:@&quot;&apos;时区编号（Z/ZZ/ZZZ=ZZZZ）&apos;:Z&apos;=&apos;ZZZZ&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:date]);</span><br><span class="line">// 时区编号（Z/ZZ/ZZZ=ZZZZ）:+0800=GMT+08:00</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>NSDate</strong> 对象 —&gt; 格式化日期字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">//设置日期的格式 ：2015年01月03日 03：32：12</span><br><span class="line">NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init];</span><br><span class="line">[dateFormat setDateFormat:@&quot;yyyy年MM月dd日 HH:mm:ss&quot;];</span><br><span class="line">NSString *dateString = [dateFormat stringFromDate:date];</span><br><span class="line">NSLog(@&quot;当前系统时间：%@ \n 格式化后的时间字符串：%@&quot;,date,dateString);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>当前系统时间：</strong> <strong>2017-04-13 04:38:23 +0000 </strong></p>
<p><strong>格式化后的时间字符串：</strong> <strong>2017</strong> <strong>年</strong> <strong>04</strong> <strong>月</strong> <strong>13</strong> <strong>日</strong> <strong>12:38:23</strong></p>
</blockquote>
<ul>
<li>日期字符串 —&gt; <strong>NSDate</strong> 对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;2014-03-21 15:55:55&quot;;</span><br><span class="line">// 设置字符串的日期格式</span><br><span class="line">NSDateFormatter *dateFormater = [[NSDateFormatter alloc] init];</span><br><span class="line">[dateFormater setDateFormat:@&quot;yyyy-M-d HH:mm:ss&quot;];</span><br><span class="line"></span><br><span class="line">NSDate *date = [dateFormater dateFromString:str];</span><br><span class="line">NSLog(@&quot;date:%@&quot;,date); // date:Fri Mar 21 15:55:55 2014</span><br></pre></td></tr></table></figure>
<blockquote>
<p>⚠️ 日期字符串转换为 <strong>NSDate</strong> 对象时，设置的 <strong>NSDateFormatter</strong> 对象是字符串的日期格式，而不是转换后的 <strong>NSDate</strong> 对象格式。</p>
</blockquote>
<ul>
<li><p>NSString —&gt; NSDate —&gt; NSString</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYModel 框架方法、DateTool 方法</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)modelCustomTransformFromDictionary:(<span class="built_in">NSDictionary</span> *)dic &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义转换日期</span></span><br><span class="line">    <span class="built_in">NSString</span> *treatmentDateString = dic[<span class="string">@"就诊时间"</span>];</span><br><span class="line">    <span class="keyword">if</span> (![treatmentDateString isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string -&gt; date -&gt; string</span></span><br><span class="line">    <span class="comment">// (yyyy-MM-dd HH:mm:ss) -&gt; (yyyy年MM月dd日 HH:mm:ss)</span></span><br><span class="line">    <span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> dateWithString:treatmentDateString formatString:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">    _treatmentDate = [date formattedDateWithFormat:<span class="string">@"yyyy年MM月dd日"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>NSDateFormatterStyle</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, NSDateFormatterStyle) &#123;    // date and time format styles</span><br><span class="line">    NSDateFormatterNoStyle = kCFDateFormatterNoStyle,</span><br><span class="line">    NSDateFormatterShortStyle = kCFDateFormatterShortStyle,</span><br><span class="line">    NSDateFormatterMediumStyle = kCFDateFormatterMediumStyle,</span><br><span class="line">    NSDateFormatterLongStyle = kCFDateFormatterLongStyle,</span><br><span class="line">    NSDateFormatterFullStyle = kCFDateFormatterFullStyle</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (NSDateFormatter *)dateFormatter  </span><br><span class="line">&#123;  </span><br><span class="line">    static NSDateFormatter *dateFormatter;  </span><br><span class="line">    if (!dateFormatter) &#123;  </span><br><span class="line">        dateFormatter = [[NSDateFormatter alloc] init];  </span><br><span class="line">          </span><br><span class="line">        dateFormatter = [[NSDateFormatter alloc] init];  </span><br><span class="line">        // NSDateFormatterStyle几种取值样式  </span><br><span class="line">        // NSDateFormatterNoStyle  </span><br><span class="line">        // 例如： （其实就是空白的，不显示）  </span><br><span class="line">  </span><br><span class="line">        // NSDateFormatterShortStyle  </span><br><span class="line">        // 例如：下午7:00 | 15/5/19  </span><br><span class="line">          </span><br><span class="line">        // NSDateFormatterMediumStyle  </span><br><span class="line">        // 例如：下午7:00:00 | 2013年5月19日  </span><br><span class="line">          </span><br><span class="line">        // NSDateFormatterLongStyle  </span><br><span class="line">        // 例如：GMT +8下午7:00:00 | 2013年5月19日  </span><br><span class="line">          </span><br><span class="line">        // NSDateFormatterFullStyle  </span><br><span class="line">        // 例如：中国标准时间下午7:00:00 | 2013年5月19日 星期日  </span><br><span class="line">        dateFormatter.timeStyle = NSDateFormatterFullStyle;  </span><br><span class="line">        dateFormatter.dateStyle = NSDateFormatterLongStyle;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return dateFormatter;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="NSTimeZone"><a href="#NSTimeZone" class="headerlink" title="NSTimeZone"></a>NSTimeZone</h1><ul>
<li>时区是一个地理名字，是为了克服各个地区或国家之间在使用时间上的混乱。</li>
</ul>
<h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><ol>
<li><ul>
<li>GMT 0:00 格林威治标准时间; </li>
<li>UTC +00:00 校准的全球时间; </li>
<li>CCD +08:00 中国标准时间 ;</li>
</ul>
</li>
<li>夏时制，英文”DaylightSavingTime”。夏季时将时区内的时间提前（一般为1小时），以节省资源，提高效率。使用夏时制期间，当前时区相对于GMT的时间偏移量会发生变化。在某些应用中可能需要考虑。</li>
<li>任何时区都以 <strong>GMT</strong> 为基准，即，任何 <strong>NSTimeZone</strong> 对象所代表的时区都是相对于 <strong>GMT</strong> 的，这里的相对性是 <strong>NSTimeZone</strong> 中最重要的属性，我们称之为当前时区相对于GMT的偏移量。一旦知道了一个偏移量，便可以确定一个时区。在iOS中，偏移量是以”秒”为单位的。</li>
<li><strong>NSTimeZone</strong> 是一个类簇，我们所使用的任何 <strong>NSTimeZone</strong> 对象都是 <strong>NSTimeZone</strong> 的私有子类。</li>
<li>iOS中的时间类 <strong>NSDate</strong> 中存储的时间，都是相对于 <strong>GMT</strong> 的，我们使用 <strong>NSDate</strong> 时，会根据App的时区设置返回与时区对应的数据。</li>
<li><p>iOS系统中的 <figure class="highlight plain"><figcaption><span>地理位置名称 或 时区别名 得到的时区信息。时区别名都是与具体的地理位置一一对应的。(已越狱的童鞋请看)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">7. iOS中的时区表示方法：```GMT+0800``` 、```GMT-0800```。(【+：东区】【 -：西区】【 08：小时数】【 00：分钟数】)。 ```GMT+0830 ```就是指比GMT早8小时外加30分钟的时区。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* ```+ (NSArray *)knownTimeZoneNames;</span><br></pre></td></tr></table></figure></p>
<p>返回列出系统已知的所有时区ID的字符串数组。</p>
</li>
</ol>
<ul>
<li><figure class="highlight plain"><figcaption><span>(NSDictionary *)abbreviationDictionary;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  获取所有的时区名称缩写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ ```+ (id)timeZoneWithName:(NSString *)tzName;</span><br></pre></td></tr></table></figure>
<p>由时区的名称获得对应的NSTimeZone对象<br>通过时区名称可以获得时区文件，通过时区文件就可以获得“偏移量”，“名称缩写”，“是否使用夏时制”等信息。</p>
</li>
</ul>
<ul>
<li><figure class="highlight plain"><figcaption><span>*)abbreviation;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  由时区名称缩写获得对应的NSTimeZone对象</span><br><span class="line">  &gt; 这里的时区名称缩写有两种情况：</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; * 第一种是上面说的HKT这样的缩写，与时区名称一一对应，通过这样的缩写获得的NSTimeZone对象，与使用时区名称获得得NSTimeZone对象一样。（大概读取得是同一个时区文件）</span><br><span class="line">  &gt; * 第二种是&quot;GMT+0800&quot;这样格式得缩写，其实这就是偏移量。通过偏移量在iOS中是不能读到与之对应得时区文件的，因此就无法知道“时区名称”，“名称缩写”，“是否使用夏时制”这样的信息了。默认情况下，&quot;时区名称&quot;和&quot;名称缩写&quot;都会赋值为&quot;GMT+0800&quot;，&quot;是否使用夏时制&quot;则不会设置（默认不使用）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ ```+ (id)timeZoneForSecondsFromGMT:(NSInteger)seconds;``` </span><br><span class="line">  由偏移量获得对应的NSTimeZone对象</span><br><span class="line"></span><br><span class="line">  &gt; 只说一点：通过偏移量获得的 **NSTimeZone** 对象的“市区名称”，“名称缩写”都会赋值为&quot;GMT+0800&quot;，&quot;是否使用夏时制&quot;则不会设置（默认不使用）。</span><br><span class="line">  &gt;  注意！！！！该方法不做参数的范围检查！！！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 根据指定时区格式化日期</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```objective-c</span><br><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">//设置日期的格式</span><br><span class="line">NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init];</span><br><span class="line">[dateFormat setDateFormat:@&quot;yyyy年MM月dd日 HH:mm:ss&quot;];</span><br><span class="line"></span><br><span class="line">//获取到所有时区的名字</span><br><span class="line">NSArray *zoneName = [NSTimeZone knownTimeZoneNames];</span><br><span class="line">NSLog(@&quot;%@&quot;,zoneName);</span><br><span class="line"></span><br><span class="line">//设置时区为纽约时区</span><br><span class="line">NSTimeZone *timeZone = [[NSTimeZone alloc] initWithName:@&quot;America/New_York&quot;];</span><br><span class="line">[dateFormat setTimeZone:timeZone];</span><br><span class="line">  </span><br><span class="line">NSString *dateString = [dateFormat stringFromDate:date];</span><br><span class="line">NSLog(@&quot;当前时间：%@ \n纽约时间:%@&quot;,date,dateString);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><strong>当前时间：</strong> <strong>2017-04-13 04:46:23 +0000 </strong></p>
<p><strong>纽约时间：</strong> <strong>2017</strong> <strong>年</strong> <strong>04</strong> <strong>月</strong> <strong>13</strong> <strong>日</strong> <strong>00:46:23</strong></p>
</blockquote>
<h1 id="NSLocale"><a href="#NSLocale" class="headerlink" title="NSLocale"></a>NSLocale</h1><p>若你只开发中国区的应用，需要保证用户修改当前语言环境时应用的显示不发生变化。而像NSDateFormatter这样的类，会根据设备的设置，自动返回不同语言的数据。为了保证返回数据的语言一致，我们需要设置NSLocale。 下面的代码就可以保证在任何语言环境下，只返回中文的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSLocale *locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh&quot;];</span><br><span class="line">NSDateFormatter *secondDateFormatter = [[NSDateFormatter alloc] init];</span><br><span class="line">[secondDateFormatter setDateFormat:@&quot;cccc&quot;];</span><br><span class="line">secondDateFormatter.locale = locale;</span><br><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">NSLog(@&quot;%@&quot;, [secondDateFormatter stringFromDate:date]);</span><br></pre></td></tr></table></figure>
<p>当然，像上面的需求很罕见。</p>
<p>作为大家都不常用的一个类，NSLocale类是将与国家和语言相关的信息进行简单的组合，包括货币，文学方面的信息。 货币：货币的国际名称（人民币的国际货币名称是CNY）；货币符号（人民币的国际货币符号是¥） 文学：标点符号，文字的书写顺序（左右顺序），引用的起止符号等等 若做金融一类的应用可能会用到NSLocale这个类。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h5 id="日期说明符号对照一览表"><a href="#日期说明符号对照一览表" class="headerlink" title="日期说明符号对照一览表"></a>日期说明符号对照一览表</h5><ul>
<li><a href="http://unicode.org/reports/tr35/tr35-10.html#Date_Format_Patterns" target="_blank" rel="noopener">UNICODE LOCALE DATA MARKUP LANGUAGE (LDML)</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">// -------------------------------------------------------------</span><br><span class="line">d 月中的某一天。一位数的日期没有前导零。  </span><br><span class="line"></span><br><span class="line">dd 月中的某一天。一位数的日期有一个前导零。  </span><br><span class="line"></span><br><span class="line">ddd 周中某天的缩写名称,在 AbbreviatedDayNames 中定义。  </span><br><span class="line"></span><br><span class="line">dddd 周中某天的完整名称,在 DayNames 中定义。  </span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">M 月份数字。一位数的月份没有前导零。  </span><br><span class="line"></span><br><span class="line">MM 月份数字。一位数的月份有一个前导零。  </span><br><span class="line"></span><br><span class="line">MMM 月份的缩写名称,在 AbbreviatedMonthNames 中定义。  </span><br><span class="line"></span><br><span class="line">MMMM 月份的完整名称,在 MonthNames 中定义。  </span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">y 不包含纪元的年份。如果不包含纪元的年份小于 10,则显示不具有前导零的年份。  </span><br><span class="line"></span><br><span class="line">yy 不包含纪元的年份。如果不包含纪元的年份小于 10,则显示具有前导零的年份。  </span><br><span class="line"></span><br><span class="line">yyyy 包括纪元的四位数的年份。  </span><br><span class="line"></span><br><span class="line">gg 时期或纪元。如果要设置格式的日期不具有关联的时期或纪元字符串,则忽略该模式。   </span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">h 12小时制的小时。一位数的小时数没有前导零。  </span><br><span class="line"></span><br><span class="line">hh 12小时制的小时。一位数的小时数有前导零。  </span><br><span class="line"></span><br><span class="line">H 24小时制的小时。一位数的小时数没有前导零。  </span><br><span class="line"></span><br><span class="line">HH 24小时制的小时。一位数的小时数有前导零。  </span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">m 分钟。一位数的分钟数没有前导零。  </span><br><span class="line"></span><br><span class="line">mm 分钟。一位数的分钟数有一个前导零。   </span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">s 秒。一位数的秒数没有前导零。   </span><br><span class="line"></span><br><span class="line">ss 秒。一位数的秒数有一个前导零。   </span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">f 秒的小数精度为一位。其余数字被截断。  </span><br><span class="line"></span><br><span class="line">ff 秒的小数精度为两位。其余数字被截断。  </span><br><span class="line"></span><br><span class="line">fff 秒的小数精度为三位。其余数字被截断。  </span><br><span class="line"></span><br><span class="line">ffff 秒的小数精度为四位。其余数字被截断。  </span><br><span class="line"></span><br><span class="line">fffff 秒的小数精度为五位。其余数字被截断。  </span><br><span class="line"></span><br><span class="line">ffffff 秒的小数精度为六位。其余数字被截断。  </span><br><span class="line"></span><br><span class="line">fffffff 秒的小数精度为七位。其余数字被截断。  </span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">t 在 AMDesignator 或 PMDesignator 中定义的 AM/PM 指示项的第一个字符(如果存在)。   </span><br><span class="line"></span><br><span class="line">tt 在 AMDesignator 或 PMDesignator 中定义的 AM/PM 指示项(如果存在)。  </span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">z 时区偏移量(“+”或“-”后 仅跟小时)。一位数的小时数没有前导零。例如,太平洋标准时间是“-8”。   </span><br><span class="line"></span><br><span class="line">zz 时区偏移量(“+”或“-”后 仅跟小时)。一位数的小时数有前导零。例如,太平洋标准时间是“-08”。   </span><br><span class="line"></span><br><span class="line">zzz 完整时区偏移量(“+”或“-”后 跟有小时和分钟)。一位数的小时数和分钟数有前导零。例如,太平 洋标准时间是“-08:00”。  </span><br><span class="line"></span><br><span class="line">// -------------------------------------------------------------</span><br><span class="line">: 在 TimeSeparator 中定义的默认时间分隔符。  </span><br><span class="line"></span><br><span class="line">/ 在 DateSeparator 中定义的默认日期分隔符。  </span><br><span class="line"></span><br><span class="line">% c 其中 c 是格式模式(如果单独使 )。如果格式模式与原义字符或其他格式模式合并,则可以省略 “%”字符。  </span><br><span class="line"></span><br><span class="line">\ c 其中 c 是任意字符。照原义显示字符。若要显示反斜杠字符,请使 “\”。</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://my.oschina.net/yongbin45/blog/150114" target="_blank" rel="noopener">iOS时间那点事–NSDate</a></li>
<li><a href="https://my.oschina.net/yongbin45/blog/150667" target="_blank" rel="noopener">iOS时间那点事–NSDateFormatter</a></li>
<li><a href="https://my.oschina.net/yongbin45/blog/151376" target="_blank" rel="noopener">iOS时间那点事–NSTimeZone</a></li>
<li><a href="https://my.oschina.net/yongbin45/blog/156130" target="_blank" rel="noopener">ios时间那点事–NSLocale</a></li>
<li><a href="http://blog.csdn.net/ahut_qyb_6737/article/details/42494211" target="_blank" rel="noopener"><a href="http://blog.csdn.net/ahut_qyb_6737/article/details/42494211" target="_blank" rel="noopener">NSDateFormatterStyle 几种取值的区别</a></a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/03/Objective-C_简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/03/Objective-C_简介/" class="post-title-link" itemprop="url">Objective-C_简介</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-03 13:28:00" itemprop="dateCreated datePublished" datetime="2016-08-03T13:28:00+08:00">2016-08-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-15 21:14:23" itemprop="dateModified" datetime="2019-04-15T21:14:23+08:00">2019-04-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C-编程/" itemprop="url" rel="index"><span itemprop="name">Objective-C 编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/03/Objective-C_简介/" class="leancloud_visitors" data-flag-title="Objective-C_简介">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <p>###简介<br><strong>Object-C</strong> 通常写作 <strong>Objective-C</strong> 或者 <strong>Obj-C</strong> 或 <strong>OC</strong>，是根据C语言所衍生出来的语言，继承了C语言的特性，是扩充C的面向对象编程语言。<br><strong>Object-C</strong> 是一种<strong>面向对象</strong>的计算机语言。而C是<strong>面向过程</strong>的语言。<br><strong>Object-C</strong> 是MAC OSX和iOS开发的基础语言。</p>
<p>###优点及缺点</p>
<ul>
<li>Object-C 是非常“实际”的语言。它使用一个用C写成，很小的运行库，OC写成的程序通常不会比其原始码大很多。</li>
<li>Objective-C 的最初版本并不支持垃圾回收。</li>
<li>Objective-C 不包括命名空间机制(namespace mechanism)。</li>
<li>虽然 Objective-C 是C的母集，但它也不视C的基本型别为第一级的对象。</li>
<li>和C++不同，Objective-C 不支持运算子重载（它不支持ad-hoc多型）。</li>
<li>Object-C 仅支持单一父类继承，不支持多重继承。</li>
</ul>
<p>###和C++的比较</p>
<ol>
<li><p>目前好象只有<strong>Apple</strong>使用Objective-C作为其支持的语言吧。</p>
</li>
<li><p>与C++的不同之处有：</p>
<ul>
<li>O-C中所有的类都必须继承自NSObject;</li>
<li>O-C中所有对象都是指针的形式;</li>
<li>O-C用self代替this;</li>
<li>O-C使用id代替void;</li>
<li>O-C使用nil表示NULL;</li>
<li>O-C只支持单继承;</li>
<li>O-C使用YES/NO表示TRUE/FALSE;</li>
<li>O-C使用#import代替#include;</li>
<li>O-C中用消息表示类的方法，并采用<figure class="highlight plain"><figcaption><span>method:argv]```调用形式;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">	* O-C支持反射机制;</span><br><span class="line">	* O-C支持Dynamic Typing, Dynamic Binding和Dynamic Loading.</span><br><span class="line"></span><br><span class="line">3. 与C++的相同之处有：</span><br><span class="line">	* 与C共享的部分一致;</span><br><span class="line">	* 可以使用```assert(BOOL)```, 一般用```NSCParameterAssert(BOOL)```代替。</span><br><span class="line"></span><br><span class="line">4. O-C中的命名前缀说明：</span><br><span class="line">	* NS-：NextStep;</span><br><span class="line">	* CF-：Core Foundation;</span><br><span class="line">	* CA-：Core Animation;</span><br><span class="line">	* CG-：Core Graphics;</span><br><span class="line">	* UI-：User Interface;</span><br><span class="line"></span><br><span class="line">5. O-C中的消息特殊性：</span><br><span class="line">	* 调用消息的类可以不知道如何响应这个消息。如果它不知道如何处理这个消息，它会自动的将这个消息转给其他的类，比如它的父类。</span><br><span class="line">	* 调用消息的类可以是nil。在C++中，在使用类方法之前，我们都需要检查对象是否为空，所以在实现析构函数的时候，常会有如下的代码，如```if (var) &#123; delete var; &#125; ```但是在 Objective-C 中，我们就可以直接写```[var release];即使var == nil```, 也不会有问题。</span><br><span class="line"></span><br><span class="line">6. O-C中的函数声明格式有：</span><br><span class="line">	* ```-/+ (return type) function_name```;</span><br><span class="line">	* ```-/+ (return type) function_name : (parameter type) parameter```;</span><br><span class="line">	* ```-/+ (return type) function_name : (parameter type) parameter1 otherParameter: (parameter_type) parameter2```;</span><br><span class="line">	* 以上参数说明:-表示一般函数，+表示静态函数。otherParameter是参数的别名(第一个参数的别名省略),在函数调用时方便指定。</span><br><span class="line"></span><br><span class="line">7. O-C中的构造/析构函数:</span><br><span class="line">	* O-C中的 `init()/release()` 对应于C++的构造/析构函数。`alloc()/dealloc()`也就对应于C++的new和delete,其中的`dealloc()`由于引用计数的自动调用而不用手动调用。</span><br><span class="line">	* O-C中父类的`init()/release()`函数需要子类的手动调用。而且每次都必须调用。不同于C++的自动调用。</span><br><span class="line">	* 构造函数(- (id) init)调用形如:```CSample* pSample=[CSample alloc] init]```;其中alloc(+ (id) alloc)是继承来的static函数，init是继承来的一般函数，如重写一般函数时，则相当于C++的覆盖(不带参数)或重载(带参数)。</span><br><span class="line">	* 析构函数(- (void) release)将引用计数减1，当=0时父类的release()会自动调用dealloc(- (void) dealloc);</span><br><span class="line"></span><br><span class="line">8. 当O-C没有数据成员时，可省略&#123;&#125;,建议保留。</span><br><span class="line"></span><br><span class="line">9. 继承下来的方法，如：-(id) init可以头文件中省略，建议保留.</span><br><span class="line"></span><br><span class="line">10. 0-C中只有数据成员的访问限制，没有方法的访问限制。</span><br><span class="line">	* 同C++一样，数据成员有三种访问限制public, protected, private，缺省是protected。   </span><br><span class="line">	示例：   </span><br><span class="line">&gt; @interface AccessExample: NSObject &#123;    </span><br><span class="line">`@public`  </span><br><span class="line">int publicVar;   </span><br><span class="line">`@protected`  </span><br><span class="line">int protectedVar;   </span><br><span class="line">`@private`   </span><br><span class="line">int privateVar;   </span><br><span class="line">&#125;   </span><br><span class="line">@end   </span><br><span class="line"></span><br><span class="line">方法的访问限制可通过Category（类别）实现，示例代码：</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>// MyClass 类<br>@interface MyClass<br>-(void) sayHello<br>{<br>NSLog(@”Hello”);<br>}<br>@end<br>// MyClass  的扩展类<br>@interface MyClass(Private)<br>-(void) kissGoodbye;<br>@end<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">11</span>. O-C中没有类的静态变量，只有全局变量</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>. O-C中的数组NSArray可以保存不同类型的数据。</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>. O-C也支持run-time时的类型检查   </span><br><span class="line">```- (BOOL) isKindOfClass: classObj```   用于判断该对象是否属于某个类或者它的子类。</span><br><span class="line">```- (BOOL) isMemberOfClass: classObj```   用于判断该对象是否属于某个类（这里不包括子类) 。</span><br><span class="line">```- (BOOL) respondsToSelector: selector```   用于判断该对象是否能响应某个消息。这里，我们可以将@selector后面带的参数理解为C++中的函数指针。   </span><br><span class="line"><span class="symbol">注意:</span><span class="number">1</span>）不要忘了@    </span><br><span class="line">　　 <span class="number">2</span>）@selector后面用的是()，而不是[]。    </span><br><span class="line">　　<span class="number">3</span>）要在消息名称后面跟：，无论这个消息是否带参数。    </span><br><span class="line"><span class="symbol">	　　	如：```[pSquare    respondsToSelector:@selector(Set: andHeight:</span>)]。```   </span><br><span class="line">```+ (BOOL) instancesRespondToSelector: selector```   用于判断该类是否能响应某个消息。这是一个静态函数。   </span><br><span class="line">```-(id) performSelector: selector ：```   调用对象的selector方法。   </span><br><span class="line">```conformsToProtocol``` 类似于```respondsToSelector ```，用于动态检查某个对象是否遵守某个协议。</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>. Category：范畴/扩展类：在没有源代码的情况下，为一个已经存在的类添加一些新的功能</span><br><span class="line">	* 只能添加新的方法，不能添加新的数据成员；</span><br><span class="line">	* Category的名字必须是唯一的。</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>. Protocol：协议类：相当于C++中的纯虚类   </span><br><span class="line">	* 形如：</span><br></pre></td></tr></table></figure></p>
<p>//创建协议</p>
<p>#import &lt;Foundation/Foundation.h&gt;<br>@protocol MyProtocol <nsobject></nsobject></p>
<p>//规则1<br>//规则2</p>
<p>@required    //表示修饰的协议方法必须实现<br>//完成作业的协议方法</p>
<ul>
<li>(void)finishTask;</li>
</ul>
<p>//不能迟到的协议方法<br>-(void)dontLate;</p>
<p>@optional   //表示修饰的协议可选,可实现/可不实现<br>//穿戴整洁</p>
<ul>
<li>(void)wearNeat;</li>
</ul>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>//  类签订协议:&lt;协议名&gt;<br>@interface Student: NSObject &lt; MyProtocol &gt; {</p>
<p>//实现协议方法</p>
<ul>
<li><p>(void)finishTask{…}<br>-(void)dontLate{…}</p>
<p>} @end</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>使用：<br>Student * student1 = [[Student alloc] init];<br>id&lt; MyProtocol &gt; student1 = dat;<br>[var print]。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 说明：我们首先声明了MyProtocol协议，任何遵守这个协议的类，都必须实现<span class="keyword">@required</span>中的方法。在Objective-C 中，我们通过&lt;&gt;来表示遵守某个协议。当某个类声明要遵守某个协议之后，它就必须在.m文件中实现这个协议中的所有方法。使用<span class="keyword">id</span>&lt; MyProtocol &gt; 作为类型，而不是象C++中的MyProtocol* var。 </span><br><span class="line"></span><br><span class="line"><span class="number">16.</span> <span class="keyword">IBOutlet</span>, <span class="keyword">IBAction</span>: 告诉<span class="built_in">XCode</span>之后会使用Interface Builder关联该插座变量、动作。如果你希望在Interface Builder中能看到这个控件对象，那么在定义的时候前面加上<span class="keyword">IBOutlet</span>，在IB里就能看到这个对象的outlet，如果你希望在Interface Builder里控制某个对象执行某些动作，就在方法前面加上**(<span class="keyword">IBAction</span>)**。</span><br><span class="line">形如：</span><br></pre></td></tr></table></figure>
<p>//声明一个属性questionLabel，可以指向UILabel对象<br>  @property(nonatomic,weak) IBOutlet UILabel *questionLabel;<br>//方法：实现Bottond动作</p>
<ul>
<li>(IBAction)showQuestion:(id)sender{<br>//…<br>}<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">17.</span> <span class="string">尽量避免在一行语句中进行两层以上的嵌套.</span></span><br><span class="line"></span><br><span class="line"><span class="number">18.</span> <span class="string">消息转发：`-</span> <span class="string">(void)</span> <span class="attr">forwardInvocation:</span> <span class="string">(NSInvocation</span> <span class="string">*)anInvocation;`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 扩展的关键字</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### @interface</span></span><br><span class="line"><span class="string">类型声明,类似于c++中的class，区别在于OC中的声明与实现是强制分开的，**@interface存放于.h文件中，而@implementation存放于.m文件中。**@interface关键字用于类型的声明，包括数据成员、方法声明、属性等。方法的参数传递采用中缀符的形式，利用“：”分割参数名和被传递参数，类型的声明以@interface开头，以@end结束，通常一个类型的声明采用下面的结构：</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>@class someOtherObject //外部类型声明<br>@interface NewClassName : ParentClassName //类型声明 子类：父类<br>{<br>//    定义属性<br>//    全局变量，成员变量，实例变量<br>    NSInteger _age;  //年龄<br>    NSString *_name;  //姓名<br>    float _weight;  //体重<br>}<br>//方法定义<br>-(void)shopping；//不带参数的方法<br>-(void)goshopping:(float)price; //带参数的方法<br>-(id)someMethod:(int)someArg someOtherArgName:(int)someOtherArg;<br>//类方法,使用类名调用的方法 [类名 方法]<br>//以’+’开头<br>+(id)someMethod:(int)someArg;<br>-(id)init; //初始化方法<br>@propertyint num; //属性,为属性自动生成set和get方法<br>@end<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### @<span class="keyword">implementation</span></span><br><span class="line">对应于@interface的类型声明，@<span class="keyword">implementation</span>表示一个类型的实现过程，存放于‘.m’文件中，同样以@end结束，实现的格式通常如下：</span><br></pre></td></tr></table></figure></p>
<p>//预编译指令，只编译 .m 文件，而 .h 文件导入到此处处理。<br>#import “Person.h”<br>@implementation NewClassName<br>-(id)someMethod:(int)someArg someOtherArgName:(int)someOtherArg<br>{<br>//实现代码<br>}<br>+(id)someMethod:(int)someArg<br>{<br>//类方法实现代码<br>//与实例方法的区别：类方法中不能使用属性<br> }<br>@synthesize num=i; //将属性与变量进行对应<br>@end<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### new、alloc</span><br><span class="line">Object-C中的方法调用形式采用消息发送的方式，通常调用的形式如  </span><br><span class="line">`[someObject someMethod:firstArg someOtherArgName:otherArg]`   </span><br><span class="line">实例的初始化也采用消息发送的形式，可以简单的调用类型的new方法来获取一个实例对象，简单实例化的方法通常是：   </span><br><span class="line">`someObject *obj = [someObject new]; `<span class="comment">//类的实例化    </span></span><br><span class="line">    </span><br><span class="line">**new** 方法的实际过程是调用 **alloc** 和 **init** 方法，因此如果需要采用自定义的方法来初始化实例，则需要自己重写init方法，通常的初始化方式为：    </span><br><span class="line">`someObject *obj = [[someObject alloc] init]; `<span class="comment">//采用无参数的init实例化   </span></span><br><span class="line">`someObject *obj = [[someObject alloc] initWithArg:Arg]; `<span class="comment">//采用参数的实例化 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### @<span class="keyword">class</span></span><br><span class="line">**@<span class="keyword">class</span>**是一个前向引用声明，类似于C++中的friend友元声明，其作用是告诉编译器其后面的字段代表一个类型名称，尽管不知道类型的具体实现，但是只需要将其作为一个类型名称处理即可。通常在使用复合的结构时可以采用**@<span class="keyword">class</span>**来减少头文件的相互引用，如果出现循环依赖，则需要依靠**@<span class="keyword">class</span>**来避免引用的死循环。   </span><br><span class="line">* @<span class="keyword">class</span>可以解决#<span class="keyword">import</span>引起的相互导入.   </span><br><span class="line">* 在头文件里要使用其他类,一般用@<span class="keyword">class</span>, 在实现文件用#<span class="keyword">import</span>导入类文件。   </span><br><span class="line">通常使用形式为：</span><br></pre></td></tr></table></figure></p>
<p><code>@class</code> someOtherObject;<br><code>@interface</code> someObject:NSObject<br>{<br>someOtherObject *obj;<br>}<br>@end<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#### #import </span></span><br><span class="line">类似于C语言中的 **<span class="meta">#include**，导入一个头文件,获取该头文件中类的定义—方法和属性。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#### @property</span></span><br><span class="line">* 尽管可以使用obj-&gt;arr的形式去强制读取对象的成员变量，但是良好的编程形式是对外界提供成员变量的读写接口。**<span class="keyword">@property</span>**关键字提供了外界对成员变量的访问接口，**其本质是自动为某一个属性生成set和get方法**。</span><br><span class="line">* 根据不同的需要，可以添加 **<span class="keyword">readonly</span>**（只读，相当于只添加get不添加set方法）或者 **<span class="keyword">readwrite</span>**（读写，如果不添加则为默认）；</span><br><span class="line">* 还有三种赋值方式可选 ：**<span class="keyword">assign</span>**（直接赋值，通常用于基本类型），**<span class="keyword">retain</span>**（释放旧值，增加新的retaincount），**<span class="keyword">copy</span>**（常用于字符串，生成一个新的拷贝）.      </span><br><span class="line"></span><br><span class="line"> **格式**：</span><br><span class="line"></span><br><span class="line">	<span class="keyword">@property</span>(原子性©,赋值©,读写性©)<span class="built_in">NSString</span> *XXX;  </span><br><span class="line">	      <span class="number">1.</span>原子性    </span><br><span class="line">	        * atomic:多线程环境下，存在线程保护；   </span><br><span class="line">	        * <span class="keyword">nonatomic</span>:多线程环境下，不存在线程保护；   </span><br><span class="line">	      <span class="number">2.</span>赋值     </span><br><span class="line">	        *  <span class="keyword">assign</span>:直接赋值，默认；(对象之外的类型使用)   </span><br><span class="line">	        * <span class="keyword">retain</span>：保留对象；（所有的对象，都使用<span class="keyword">retain</span>）   </span><br><span class="line">	        * <span class="keyword">copy</span>:拷贝对象；<span class="built_in">NSString</span>的对象都使用<span class="keyword">copy</span>    </span><br><span class="line">	      <span class="number">3.</span>读写性     </span><br><span class="line">	        * <span class="keyword">readwrite</span>:生成<span class="keyword">getter</span>、<span class="keyword">setter</span>方法，默认；   </span><br><span class="line">	        * <span class="keyword">readonly</span>:只生成<span class="keyword">getter</span>方法   </span><br><span class="line"></span><br><span class="line"> **作用**：   </span><br><span class="line"> <span class="number">1.</span>生成一个 _XXX 属性，此属性是 private ,不能被继承；   </span><br><span class="line"> <span class="number">2.</span>自动为该属性生成 set 和 get 方法。   </span><br><span class="line"> 通常使用的方式如下： </span><br><span class="line">```  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">someObject</span>:<span class="title">NSObject</span>   </span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">//成员变量    </span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>,<span class="keyword">readonly</span>) <span class="keyword">int</span> num; <span class="comment">//属性(注意无需下划线)   </span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<h4 id="synthesize"><a href="#synthesize" class="headerlink" title="@synthesize"></a>@synthesize</h4><p>与 <strong>@property</strong> 对应，将一个外在属性与成员变量相关联，定义在 <strong>@implementation</strong> 中，如果属性名与变量名一致则可以省略变量名。常用方法：</p>
<pre><code>@implementation someObject 

@synthesize num=i;//如果属性名也为i，则可以直接写为 @synthesize i 

//更改属性名，将默认的 _username 改为 _name
@synthesize username = _name;  
@end   
</code></pre><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ul>
<li>内存管理是关于如何管理 <strong>对象</strong> 生命周期的编程原则。</li>
<li>Object-C采用<strong>引用计数</strong>的方式进行内存管理，由于所有的对象都继承于 <strong>NSObject</strong>，因此所有的对象都可以接受 <strong>NSObject</strong> 的三个方法：<br><code>-(id)retain;</code>   //retain方法将对象的引用计数加1并返回该对象<br><code>-(void)release;</code> //release将引用计数减1<br><code>-(unsigned)retainCount;</code> //retainCount方法返回对象当前的引用计数   </li>
<li>当采用<strong>new</strong>、<strong>alloc</strong>、<strong>copy</strong>方法创建一个对象时，它的引用计数被置为1，如果程序中对该对象进行操作，则应根据需要，通过调用<strong>retain</strong>和<strong>release</strong>方法来保证该对象在不需要的时候被清除。当一个对象的引用计数被置为0后，系统会自动向对象发送一个<strong>dealloc</strong>消息，将其占有的资源释放。通常情况下，如果一个对象的初始化过程调用了其他资源，则应该重写该对象的<strong>dealloc</strong>过程，保证在对象的销毁期正确释放这些资源。</li>
<li>Object-C进行内存管理的3条规则是：   </li>
</ul>
<ol>
<li>如果使用<strong>new</strong>、<strong>alloc</strong>或<strong>copy</strong>操作获得一个对象，则该对象的保留计数器值为1.      </li>
<li>如果通过任何其他方法获得一个对象，则假设该对象的保留计数器值为1，而且已经被设置为自动释放.   </li>
</ol>
<ul>
<li><p>如果保留了某个对象，则必须保持retain方法和release方法的使用次数相等。</p>
</li>
<li><p><strong>retainCount</strong>:内存管理默认为系统自动.<br>内存管理改为手动方法：选中Project -&gt; Build settings -&gt; 搜索框搜索“arc”,将 Object-C Automatic Reference Counting值设置为No；<br><em>手动内存管理(MRC)黄金法则:</em>如果对一个对象使用了 <strong>alloc</strong>,<strong>[mutable]copy</strong>,<strong>retain</strong>, 那么你必须使用相应的 <strong>release</strong> 或者 <strong>autorelease</strong> 释放.</p>
</li>
<li><p>为了更加方便的进行能存管理，cocoa中提供了一个自动释放池（<strong>autorelease pool</strong>）的概念，每一个类都继承了一个<strong>autorelease</strong>方法，当调用对象的<strong>autorelease</strong>方法时，该对象会被加入到开始创建的自动释放池中。当程序进行到不再需要自动释放池中的对象时，将自动释放池释放的时候会向池中的所有对象发送一个release消息，从而保证不再需要的对象被正确的释放。通常的用法如下：</p>
</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool *pool = <span class="comment">[<span class="comment">[NSAutoreleasePool alloc]</span> init]</span>;   </span><br><span class="line">someObject * obj = <span class="comment">[<span class="comment">[someObject alloc]</span> init]</span>;   </span><br><span class="line"><span class="comment">[obj autorelease]</span>; //将 obj 对象加入自动释放池中，引用计数不会-1.   </span><br><span class="line">//其他代码  </span><br><span class="line"><span class="comment">[pool release]</span>; //执行该语句时，系统会向池内所有的对象发送release消息；</span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果对obj进行的其他<strong>retain</strong>操作和<strong>release</strong>操作保持一致的话，则会将obj的引用计数变为0，从而调用它的<strong>dealloc</strong>方法进行资源释放.</p>
<h4 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h4><ul>
<li>ARC自动引用计数(automatic reference counting),提供自动管理内存的功能。</li>
<li>不需要手动管理引用计数,不需要也不允许retain、release、autorelease。</li>
<li>注意版本的支持是在iOS4(不支持弱引用)、iOS5上。</li>
</ul>
<h4 id="内存中的区域划分"><a href="#内存中的区域划分" class="headerlink" title="内存中的区域划分"></a>内存中的区域划分</h4><ul>
<li><strong>栈</strong>:栈区(stack)由系统自动分配和释放 ,存放局部变量的值等。</li>
<li><strong>堆</strong>:一般由程序员分配和释放,如果不释放,则出现内存泄露。程序退出时, 系统会回收你的内存。特点:无序、速度慢、容量大。</li>
<li><strong>静态存储区</strong>:全局变量(外部变量)和静态变量都存放在静态区域。当程序结束时,系统回收。</li>
<li><strong>常量区</strong>:存放常量的内存区域,程序结束时,系统回收。</li>
<li><strong>代码区</strong>:存放二进制代码的区域。</li>
</ul>
<h5 id="数组内存管理"><a href="#数组内存管理" class="headerlink" title="数组内存管理"></a>数组内存管理</h5><ul>
<li>如果一个对象被添加到数组,那么这个对象的引用计数会被 <strong>retain</strong> 而 +1.</li>
<li>数组销毁或者 <strong>removeAllObjects</strong>,会给每一个元素发送 <strong>release</strong> 消息。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//对数组中的每一个元素发送<span class="keyword">release</span>消息  </span><br><span class="line">[<span class="built_in">array</span> removeAllObjects]; </span><br><span class="line"></span><br><span class="line">//移除下标为1的元素,同时向它发送<span class="keyword">release</span>消息  </span><br><span class="line">[<span class="built_in">array</span> removeObjectAtIndex:<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="类方法创建的内存管理"><a href="#类方法创建的内存管理" class="headerlink" title="类方法创建的内存管理"></a>类方法创建的内存管理</h4><ul>
<li><strong>Foundation</strong> 中的类可以通过 <strong>alloc</strong> 创建和 <strong>类方法</strong> 创建,区别在于内存管理不一样。</li>
<li><strong>类方法</strong> 创建的对象是加入了自动释放池。</li>
<li>新语法（简便写法）创建的对象和类方法创建的对象相同,由自动释放池管理。</li>
</ul>
<h4 id="Category-（类别、类目）"><a href="#Category-（类别、类目）" class="headerlink" title="Category （类别、类目）"></a>Category （类别、类目）</h4><ul>
<li>类目是为现有的类提供一个新的方法的方法，即使没有一个类的源代码，仍然可以向类中添加一个方法以方便使用。</li>
<li>通过类目扩展的方法,子类也能继承下来。</li>
<li>类目不能为原始类增加属性.</li>
<li>无法调用原始类的方法.</li>
<li>类目的主要目的有3个：将类的实现分散到多个不同的文件或框架中，创建对私有方法的前向引用，向对象添加非正式协议。<br \> </li>
<li>类目的定义和类的定义相似。在.h文件里声明,.m文件里实现方法。</li>
<li>定义类目的文件命名规则: 类名+类目名称,如“NSString+Revert”。     </li>
</ul>
<p><strong>类目的创建：</strong> 菜单选File -&gt; New -&gt; File -&gt; Object-C File -&gt;选择File Type为 Category</p>
<p>类别的声明方法：</p>
<pre><code>@interface NSString (Extension)
{
//        NSString *s = @&quot;hello&quot;;  错误！类目不能创建属性！！！
}

// 要扩展的方法 
-(id)someMethod:(int)someArg; 

//覆写父类方法
- (NSArray&lt;NSString *&gt; *)componentsSeparatedByString:(NSString *)separator;

@end 
</code></pre><p>类别的实现方法：</p>
<pre><code>@implementation NSString (Extension)

-(id)someMethod:(int)someArg; {
//实现代码
}

- (NSArray&lt;NSString *&gt; *)componentsSeparatedByString:(NSString *)separator{
//无法调用原始类的方法
//实现代码
return expression;
}
@end  
</code></pre><h4 id="延展"><a href="#延展" class="headerlink" title="延展"></a>延展</h4><p>在类的实现文件.m中定义类目,叫<strong>延展</strong>。</p>
<pre><code>//延展：使用类目声明方法，在实现类中实现此方法
//延展可以在.h中声明,也可以在.m中声明
@interface Persion (p2)

-(id)someMethod:(int)someArg;

@end
</code></pre><h4 id="protocol-（协议）"><a href="#protocol-（协议）" class="headerlink" title="@protocol （协议）"></a>@protocol （协议）</h4><ul>
<li>Object-C中的协议类似于java中的接口，通过<strong>@protocol</strong>关键字定义一个或多个需要遵从协议的对象实现的方法。</li>
<li>协议本身不是类，它定义了一组方法，让其他类来实现。</li>
<li>在类实现时需要将协议中规定的方法都予以实现。Object C 2.0增加了2个新的协议修饰符<strong>@optional</strong>和<strong>@required</strong>，可以规定协议中的方法是否为必须实现的方法。   </li>
<li><strong>创建方式：</strong>菜单选File -&gt; New -&gt; File -&gt; Object-C File -&gt;自定义协议名，选择File Type为 Protocl。<br \><br>协议定义的方法：<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`<span class="variable">@protocol</span>` MyProtocol &lt; NSObject &gt; &lt;br \&gt;   </span><br><span class="line"> <span class="built_in">`@required`</span> <span class="comment">//表示修饰的协议方法必须实现    </span></span><br><span class="line">-(void)someMethod1; <span class="comment">//协议方法 &lt;br \&gt;   </span></span><br><span class="line">`<span class="variable">@optional</span>` <span class="comment">//表示修饰的协议可选，可实现/可不实现      </span></span><br><span class="line">-(void)someMethod2;     </span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>采用协议的方法需在类声明时使用尖括号注明其需要使用的协议：<br><code>@interface someObject:NSObject &lt;MyProtocol&gt;</code><br>然后在 .m 文件中添加协议中需要实现的方法。</p>
<h4 id="self-和-super"><a href="#self-和-super" class="headerlink" title="self 和 super"></a>self 和 super</h4><ul>
<li>self指的是类对象本身;</li>
<li>super是父类对象本身;</li>
<li>self用来调用本类对象的方法;</li>
<li>self关键字先从本类中查找是否有此方法，如果没有，再从父类中调用此方法;</li>
<li>super调用从父类继承下来的方法;</li>
<li>super关键字直接调用父类中定义的方法.</li>
</ul>
<p>本文部分或参考自：<a href="http://baike.baidu.com/link?url=da9znr6i-KHqdfvWMs1YVSHwjL009DT8hwE_ETIm8iaEXxcHo8tblkzLd4fxZkHF-EEIAjDHbxNLLjhYxutiwK" target="_blank" rel="noopener">百度百科：Objective-C</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/30/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/32/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg" alt="独木舟的木">
            
              <p class="site-author-name" itemprop="name">独木舟的木</p>
              <div class="site-description motion-element" itemprop="description">有时候阳光很好 有时候阳光很暗</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">311</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">74</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Andy0570" title="GitHub &rarr; https://github.com/Andy0570" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:andywhm@163.com" title="E-Mail &rarr; mailto:andywhm@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          
             <div class="cc-license motion-element" itemprop="license">
              
              
                
              
              
              
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
             </div>
          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">独木舟的木</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





  



  






  



  
    
    
      
    
  
  <script color="17,119,176" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>













  
  <script src="//cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/npm/fastclick@1/lib/fastclick.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/npm/jquery-lazyload@1/jquery.lazyload.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  
  
  
    
  

  
    
      
    
  

  
  
  
    <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
    <script>
      
        window.addEventListener('load', () => {
      
        quicklink({
          timeout: 3000,
          priority: true,
          ignores: [uri => uri.includes('#'),uri => uri == 'https://andy0570.com/page/31/',]
        });
      
        });
      
    </script>
  


  



  



  
  
  
    
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">

  
  
    
  
  <script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.js"></script>
  

  <script src="/js/algolia-search.js?v=7.1.0"></script>



  
  
  <script>
    
    function showTime(Counter) {
      var entries = [];
      var $visitors = $('.leancloud_visitors');

      $visitors.each(function() {
        entries.push( $(this).attr('id').trim() );
      });

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url: { '$in': entries } }) })
        .done(function({ results }) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if (countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'S7i1Y8YorMKFPaYbJbekD5el-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'S7i1Y8YorMKFPaYbJbekD5el-gzGzoHsz',
                'X-LC-Key': 'brOnU8mOQvSjpipJvdKUAIbU',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            if ($('.post-title-link').length >= 1) {
              showTime(Counter);
            }
          
        });
    });
  </script>



  

  

  

  

  

  

  

  

  
  
  
    
  
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script>pangu.spacingPage();</script>


  
  
  
    
  
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1/bookmark.min.js"></script>
  <script>
  
    bookmark.loadBookmark();
  
  </script>


  

  

  


  <!-- red heart -->
  <script type="text/javascript" src="/js/src/love.js"></script>
  
</body>
</html>
