<!DOCTYPE html>













<html class="theme-next gemini" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
      
    
    
      
    
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">



  
  
    
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/han-css@3/dist/han.min.css">













  
  
    
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">







  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/panda/apple-touch-icon.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/panda/favicon-32x32.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/panda/favicon-16x16.png?v=7.1.0">


  <link rel="mask-icon" href="/images/panda/safari-pinned-tab.svg?v=7.1.0" color="#222">


  <link rel="manifest" href="/images/panda/site.webmanifest">


  <meta name="msapplication-config" content="/images/panda/browserconfig.xml">





<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: true,
    fastclick: true,
    lazyload: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '0E2AON8EZF',
      apiKey: '22fbefd84c8343239f5c04365b9728de',
      indexName: 'MyBlogPlatform',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="有时候阳光很好 有时候阳光很暗">
<meta name="keywords" content="独木舟的木">
<meta property="og:type" content="website">
<meta property="og:title" content="独木舟的木">
<meta property="og:url" content="https://andy0570.com/page/31/index.html">
<meta property="og:site_name" content="独木舟的木">
<meta property="og:description" content="有时候阳光很好 有时候阳光很暗">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="独木舟的木">
<meta name="twitter:description" content="有时候阳光很好 有时候阳光很暗">



  <link rel="alternate" href="/atom.xml" title="独木舟的木" type="application/atom+xml">



  
  
  <link rel="canonical" href="https://andy0570.com/page/31/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>独木舟的木</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8229a094facca297f211d61323fd9fde";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/andy0570" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">独木舟的木</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">iOS Developer</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">14</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">37</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">317</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/andy0570" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/26/《iOS编程（第四版）》Demo4：Hyponsister/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/26/《iOS编程（第四版）》Demo4：Hyponsister/" class="post-title-link" itemprop="url">《iOS编程（第四版）》Demo4：Hyponsister</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-26 13:23:00" itemprop="dateCreated datePublished" datetime="2016-08-26T13:23:00+08:00">2016-08-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-18 00:18:50" itemprop="dateModified" datetime="2019-04-18T00:18:50+08:00">2019-04-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/26/《iOS编程（第四版）》Demo4：Hyponsister/" class="leancloud_visitors" data-flag-title="《iOS编程（第四版）》Demo4：Hyponsister">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<blockquote>
<p>重绘与UIScrollView</p>
</blockquote>
<p><strong>UIScrollView</strong>类为展示内容比应用程序窗口大的视图提供支持。它允许用户通过触控手势卷起内容并且通过捏合手势放大缩小内容。<br>通常情况下，<strong>UIScrollView</strong>对象适用于那些尺寸大于屏幕的视图。当某个视图是<strong>UIScrollView</strong>对象的子视图时，该对象会画出该视图的某块区域（形状为矩形）。当用户按住这块矩形区域并移动手指（即拖动，pan）时，<strong>UIScrollView</strong>对象会改变该矩形所显示的子视图区域。</p>
<h3 id="在UIScrollView中放一张2倍于窗口大小的视图"><a href="#在UIScrollView中放一张2倍于窗口大小的视图" class="headerlink" title="在UIScrollView中放一张2倍于窗口大小的视图"></a>在UIScrollView中放一张2倍于窗口大小的视图</h3><p>Demo：<br><img src="http://upload-images.jianshu.io/upload_images/2648731-c2708b32240252d3.gif?imageMogr2/auto-orient/strip" alt="ScrollViewDemo.gif"></p>
<p>视图层次：UIWindow -&gt;UIViewControl -&gt; UIScrollView -&gt; HyponsisView视图。</p>
<p>实现方法：覆盖 UIViewController 中的 <code>viewDidLoad</code> 方法，创建视图层次结构。<br>​<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------------------创建一个超大视图--------------------------</span></span><br><span class="line">    <span class="comment">// 根视图控制器 中放 UIScrollView ,UIScrollView 中放 HyponsisView</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// UIScrollView</span></span><br><span class="line">    <span class="built_in">CGRect</span> screenRect = <span class="keyword">self</span>.view.frame;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// HyponsisView</span></span><br><span class="line">    <span class="built_in">CGRect</span> bigRect = screenRect;</span><br><span class="line">    bigRect.size.width *= <span class="number">2.0</span>;</span><br><span class="line">    bigRect.size.height *= <span class="number">2.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个 UIScrollView 对象，将其尺寸设置为窗口大小</span></span><br><span class="line">    <span class="built_in">UIScrollView</span> *scrollView = [[<span class="built_in">UIScrollView</span> alloc] initWithFrame:screenRect];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.view = scrollView;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个有着超大尺寸的 HQLHypnosisView 对象并将其加入 UIScrollView 对象</span></span><br><span class="line">    HQLHypnosisView *hyponsisView = [[HQLHypnosisView alloc] initWithFrame:bigRect];</span><br><span class="line">    </span><br><span class="line">    [scrollView addSubview:hyponsisView];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//告诉 UIScrollView 对象“取景”范围有多大</span></span><br><span class="line">    scrollView.contentSize = bigRect.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="拖动与分页显示"><a href="#拖动与分页显示" class="headerlink" title="拖动与分页显示"></a>拖动与分页显示</h3><ul>
<li>UIScrollView 对象的分页实现原理是：UIScrollView 对象会根据其 bounds 的尺寸，将 contentSize 分割为尺寸相同的多个区域。拖动结束后，UIScrollView 实例会自动滚动并只显示其中的一个区域。</li>
</ul>
<p>在UIScrollView中放左右两张视图<br>Demo：<br><img src="http://upload-images.jianshu.io/upload_images/2648731-77b5b883dab47070.gif?imageMogr2/auto-orient/strip" alt="ScrollViewDemo2.gif"></p>
<p>同样覆盖<code>viewDidLoad</code>方法创建视图层次结构：</p>
<pre><code>//---------------------拖动与分页------------------------
</code></pre><p>​<br>​    //创建两个 CGRect 结构分别作为 UIScrollView 对象和 HQLHypnosisView 对象的 frame</p>
<pre><code>CGRect screenRect = self.view.frame;

//设置 UIScrollView 对象的 contentSize 的宽度是屏幕宽度的2倍，高度不变
CGRect bigRect = screenRect;
bigRect.size.width *= 2.0;

//创建一个 UIScrollView 对象，将其尺寸设置为窗口大小
UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:screenRect];

//设置UIScrollView 对象的“镜头”的边和其显示的某个视图的边对齐
[scrollView setPagingEnabled:YES];

self.view = scrollView;

//创建第一个大小与屏幕相同的 HQLPictureView 对象并将其加入 UIScrollView 对象
HQLPictureView *pictureView = [[HQLPictureView alloc] initWithFrame:screenRect];
[scrollView addSubview:pictureView];

//创建第二个大小与屏幕相同的 HQLHypnosisView 对象并放置在第一个 HQLPictureView 对象的右侧，使其刚好移除屏幕外
screenRect.origin.x +=screenRect.size.width;

HQLHypnosisView *anotherView = [[HQLHypnosisView alloc] initWithFrame:screenRect];

[scrollView addSubview:anotherView];

//告诉 UIScrollView 对象“取景”范围有多大
scrollView.contentSize = bigRect.size;
</code></pre><p><a href="https://github.com/Andy0570/Hyponsister" target="_blank" rel="noopener">GitHub代码</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/24/UIKit框架_窗口和视图介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/24/UIKit框架_窗口和视图介绍/" class="post-title-link" itemprop="url">UIKit框架_窗口和视图介绍</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-24 14:01:00" itemprop="dateCreated datePublished" datetime="2016-08-24T14:01:00+08:00">2016-08-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-18 00:39:23" itemprop="dateModified" datetime="2019-04-18T00:39:23+08:00">2019-04-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/24/UIKit框架_窗口和视图介绍/" class="leancloud_visitors" data-flag-title="UIKit框架_窗口和视图介绍">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>本文转载自:<br><a href="http://www.cnblogs.com/CHONGCHONG2008/archive/2012/08/02/2619366.html" target="_blank" rel="noopener">http://www.cnblogs.com/CHONGCHONG2008/archive/2012/08/02/2619366.html</a></p>
<h2 id="窗口和视图"><a href="#窗口和视图" class="headerlink" title="窗口和视图"></a>窗口和视图</h2><p>窗口和视图是为iPhone应用程序构造用户界面的可视组件。<br>窗口为内容显示提供背景平台，而视图负责绝大部分的内容描画，并负责响应用户的交互。</p>
<h3 id="什么是窗口和视图？"><a href="#什么是窗口和视图？" class="headerlink" title="什么是窗口和视图？"></a>什么是窗口和视图？</h3><p>和Mac OS X一样，iPhone OS通过窗口和视图在屏幕上展现图形内容。虽然窗口和视图对象之间在两个平台上有很多相似性，但是具体到每个平台上，它们的作用都有轻微的差别。</p>
<h2 id="UIWindow的作用"><a href="#UIWindow的作用" class="headerlink" title="UIWindow的作用"></a>UIWindow的作用</h2><p>和Mac OS X的应用程序有所不同，iPhone应用程序通常只有一个窗口，表示为一个UIWindow类的实例。您的应用程序在启动时创建这个窗口（或者从nib文件进行装载），并往窗口中加入一或多个视图，然后将它显示出来。窗口显示出来之后，您很少需要再次引用它。</p>
<p>在iPhone OS中，窗口对象并没有像关闭框或标题栏这样的视觉装饰，用户不能直接对其进行关闭或其它操作。所有对窗口的操作都需要通过其编程接口来实现。应用程序可以借助窗口对象来进行事件传递。窗口对象会持续跟踪当前的第一响应者对象，并在UIApplication对象提出请求时将事件传递它。</p>
<p>还有一件可能让有经验的Mac OS X开发者觉得奇怪的事是UIWindow类的继承关系。在Mac OS X中，NSWindow的父类是NSResponder；而在iPhone OS中，UIWindow的父类是UIView。因此，窗口在iPhone OS中也是一个视图对象。不管其起源如何，您通常可以将iPhone OS上的窗口和Mac OS X的窗口同样对待。也就是说，您通常不必直接操作UIWindow对象中与视图有关的属性变量。</p>
<p>在创建应用程序窗口时，您应该总是将其初始的边框尺寸设置为整个屏幕的大小。如果您的窗口是从nib文件装载得到，Interface Builder并不允许创建比屏幕尺寸小的窗口；然而，如果您的窗口是通过编程方式创建的，则必须在创建时传入期望的边框矩形。除了屏幕矩形之外，没有理由传入其它边框矩形。屏幕矩形可以通过UIScreen对象来取得，具体代码如下所示：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.window = <span class="comment">[<span class="comment">[UIWindow alloc]</span> initWithFrame:<span class="comment">[<span class="comment">[UIScreen mainScreen]</span> bounds]</span>]</span>;</span><br><span class="line">    </span><br><span class="line">// 设置根视图控制器</span><br><span class="line">ViewController *viewController = <span class="comment">[<span class="comment">[ViewController alloc]</span> init]</span>;</span><br><span class="line">self.window.rootViewController = viewController;</span><br><span class="line">    </span><br><span class="line">self.window.backgroundColor = <span class="comment">[UIColor whiteColor]</span>;</span><br><span class="line"><span class="comment">[self.window makeKeyAndVisible]</span>;</span><br></pre></td></tr></table></figure>
<p>虽然iPhone OS支持将一个窗口叠放在其它窗口的上方，但是您的应用程序永远不应创建多个窗口。系统自身使用额外的窗口来显示系统状态条、重要的警告、以及位于应用程序窗口上方的其它消息。如果您希望在自己的内容上方显示警告，可以使用UIKit提供的警告视图，而不应创建额外的窗口。</p>
<h2 id="UIView是作用视图"><a href="#UIView是作用视图" class="headerlink" title="UIView是作用视图"></a>UIView是作用视图</h2><p>是UIView类的实例，负责在屏幕上定义一个矩形区域。在iPhone的应用程序中，视图在展示用户界面及响应用户界面交互方面发挥关键作用。每个视图对象都要负责渲染视图矩形区域中的内容，并响应该区域中发生的触碰事件。这一双重行为意味着视图是应用程序与用户交互的重要机制。在一个基于模型-视图-控制器的应用程序中，视图对象明显属于视图部分。</p>
<p>除了显示内容和处理事件之外，视图还可以用于管理一或多个子视图。子视图是指嵌入到另一视图对象边框内部的视图对象，而被嵌入的视图则被称为父视图或超视图。视图的这种布局方式被称为视图层次，一个视图可以包含任意数量的子视图，通过为子视图添加子视图的方式，视图可以实现任意深度的嵌套。视图在视图层次中的组织方式决定了在屏幕上显示的内容，原因是子视图总是被显示在其父视图的上方；这个组织方法还决定了视图如何响应事件和变化。每个父视图都负责管理其直接的子视图，即根据需要调整它们的位置和尺寸，以及响应它们没有处理的事件。</p>
<p>由于视图对象是应用程序和用户交互的主要途径，所以需要在很多方面发挥作用，下面是其中的一小部分：</p>
<pre><code>1. 描画和动画
    * 视图负责对其所属的矩形区域进行描画。
    * 某些视图属性变量可以以动画的形式过渡到新的值。

2. 布局和子视图管理
    * 视图管理着一个子视图列表。
    * 视图定义了自身相对于其父视图的尺寸调整行为。
    * 必要时，视图可以通过代码调整其子视图的尺寸和位置。
    * 视图可以将其坐标系统下的点转换为其它视图或窗口坐标系统下的点。

3. 事件处理
   *  视图可以接收触摸事件。
   * 视图是响应者链的参与者。
</code></pre><p>在iPhone应用程序中，视图和视图控制器紧密协作，管理若干方面的视图行为。视图控制器的作用是处理视图的装载与卸载、处理由于设备旋转导致的界面旋转，以及和用于构建复杂用户界面的高级导航对象进行交互。</p>
<h2 id="UIKit的视图类"><a href="#UIKit的视图类" class="headerlink" title="UIKit的视图类"></a>UIKit的视图类</h2><p>UIView类定义了视图的基本行为，但并不定义其视觉表示。相反，UIKit通过其子类来为像文本框、按键、及工具条这样的标准界面元素定义具体的外观和行为。图1显示了所有UIKit视图类的层次框图。除了UIView和UIControl类是例外，这个框图中的大多数视图都设计为可直接使用，或者和委托对象结合使用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-2f32405cffed1812.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1 视图的类层次"></p>
<p>这个视图层次可以分为如下几个大类：</p>
<ol>
<li><p>容器</p>
<p> 容器视图用于增强其它视图的功能，或者为视图内容提供额外的视觉分隔。比如，<strong>UIScrollView</strong> 类可以用于显示因内容太大而无法显示在一个屏幕上的视图。<strong>UITableView</strong> 类是 <strong>UIScrollView</strong> 类的子类，用于管理数据列表。表格的行可以支持选择，所以通常也用于层次数据的导航—比如用于挖掘一组有层次结构的对象。</p>
<p> <strong>UIToolbar</strong> 对象则是一个特殊类型的容器，用于为一或多个类似于按键的项提供视觉分组。工具条通常出现在屏幕的底部。Safari、Mail、和Photos程序都使用工具条来显示一些按键，这些按键代表经常使用的命令。工具条可以一直显示，也可以根据应用程序的需要进行显示。</p>
</li>
<li><p>控件</p>
<p> 控件用于创建大多数应用程序的用户界面。控件是一种特殊类型的视图，继承自 <strong>UIControl</strong> 超类，通常用于显示一个具体的值，并处理修改这个值所需要的所有用户交互。控件通常使用标准的系统范式（比如目标-动作模式和委托模式）来通知应用程序发生了用户交互。控件包括按键、文本框、滑块、和切换开关。</p>
</li>
<li><p>显示视图</p>
<p> 控件和很多其它类型的视图都提供了交互行为，而另外一些视图则只是用于简单地显示信息。具有这种行为的 <strong>UIKit</strong> 类包括<strong>UIImageView、 UILabel、UIProgressView、UIActivityIndicatorView</strong>。</p>
</li>
<li><p>文本和web视图</p>
<p> 文本和web视图为应用程序提供更为高级的显示多行文本的方法。<strong>UITextView</strong> 类支持在滚动区域内显示和编辑多行文本；而 <strong>UIWebView</strong> 类则提供了显示HTML内容的方法，通过这个类，您可以将图形和高级的文本格式选项集成到应用程序中，并以定制的方式对内容进行布局。</p>
</li>
<li><p>警告视图和动作表单</p>
<p>警告视图和动作表单用于即刻取得用户的注意。它们向用户显示一条消息，同时还有一或多个可选的按键，用户通过这些按键来响应消息。警告视图和动作表单的功能类似，但是外观和行为不同。举例来说， <strong>UIAlertView</strong> 类在屏幕上弹出一个蓝色的警告框，而 <strong>UIActionSheet</strong> 类则从屏幕的底部滑出动作框。</p>
</li>
<li><p>导航视图</p>
<p> 页签条和导航条和视图控制器结合使用，为用户提供从一个屏幕到另一个屏幕的导航工具。在使用时，您通常不必直接创建 <strong>UITabBar</strong> 和 <strong>UINavigationBar</strong> 的项，而是通过恰当的控制器接口或 <strong>Interface Builder</strong> 来对其进行配置。</p>
</li>
<li><p>窗口</p>
<p> 窗口提供一个描画内容的表面，是所有其它视图的根容器。每个应用程序通常都只有一个窗口。</p>
</li>
</ol>
<p>除了视图之外， <strong>UIKit</strong> 还提供了视图控制器，用于管理这些对象。更多信息请参见“视图控制器的作用”部分。</p>
<h2 id="视图控制器的作用"><a href="#视图控制器的作用" class="headerlink" title="视图控制器的作用"></a>视图控制器的作用</h2><p>运行在iPhone OS上的应用程序在如何组织内容和如何将内容呈现给用户方面有很多选择。含有很多内容的应用程序可以将内容分为多个屏幕。在运行时，每个屏幕的背后都是一组视图对象，负责显示该屏幕的数据。一个屏幕的视图后面是一个视图控制器其作用是管理那些视图上显示的数据，并协调它们和应用程序其它部分的关系。</p>
<p><strong>UIViewController</strong> 类负责创建其管理的视图及在低内存时将它们从内容中移出。视图控制器还为某些标准的系统行为提供自动响应。比如，在响应设备方向变化时，如果应用程序支持该方向，视图控制器可以对其管理的视图进行尺寸调整，使其适应新的方向。您也可以通过视图控制器来将新的视图以模式框的方式显示在当前视图的上方。</p>
<p>除了基础的 <strong>UIViewController</strong> 类之外，UIKit还包含很多高级子类，用于处理平台共有的某些高级接口。特别需要提到的是，导航控制器用于显示多屏具有一定层次结构的内容；而页签条控制器则支持用户在一组不同的屏幕之间切换，每个屏幕都代表应用程序的一种不同的操作模式。</p>
<p>有关如何通过视图控制器管理用户界面上视图的更多信息，请参见iPhone OS的视图控制器编程指南。</p>
<h2 id="视图架构和几何属性"><a href="#视图架构和几何属性" class="headerlink" title="视图架构和几何属性"></a>视图架构和几何属性</h2><p>由于视图是iPhone应用程序的焦点对象，所以对视图与系统其它部分的交互机制有所了解是很重要的。<strong>UIKit</strong> 中的标准视图类为应用程序免费提供相当数量的行为，还提供了一些定义良好的集成点，您可以通过这些集成点来对标准行为进行定制，完成应用程序需要做的工作。</p>
<p>本文的下面部分将解释视图的标准行为，并说明哪些地方可以集成您的定制代码。如果需要特定类的集成点信息，请参见该类的参考文档。您可以从<strong>UIKit</strong>框架参考中取得所有类参考文档的列表。</p>
<h3 id="视图交互模型"><a href="#视图交互模型" class="headerlink" title="视图交互模型"></a>视图交互模型</h3><p>任何时候，当用户和您的程序界面进行交互、或者您的代码以编程的方式进行某些修改时，<strong>UIKit</strong> 内部都会发生一个复杂的事件序列。在事件序列的一些特定的点上，<strong>UIKit</strong> 会调用您的视图类，使它们有机会代表应用程序进行事件响应。理解这些调用点是很重要的，有助于理解您的视图对象和系统在哪里进行结合。图2显示了从用户触击屏幕到图形系统更新屏幕内容这一过程的基本事件序列。以编程方式触发事件的基本步骤与此相同，只是没有最初的用户交互。<br>UIKit interactions with your view objects<br><img src="http://upload-images.jianshu.io/upload_images/2648731-f6608fdfd7ef0a2a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2 UIKit和您的视图对象之间的交互"></p>
<p>下面的步骤说明进一步刨析了图2中的事件序列，解释了序列的每个阶段都发生了什么，以及应用程序可能如何进行响应。</p>
<ol>
<li>用户触击屏幕。</li>
<li>硬件将触击事件报告给UIKit框架。</li>
<li>UIKit框架将触击信息封装为一个UIEvent对象，并派发给恰当的视图（有关UIKit如何将事件递送给您的视图的详细解释，请参见“事件的传递”部分）。</li>
<li>视图的事件处理方法可以通过下面的方式来响应事件：<ul>
<li>调整视图或其子视图的属性变量（边框、边界、透明度等）。</li>
<li>将视图（或其子视图）标识为需要修改布局。</li>
<li>将视图（或其子视图）标识为布局需要重画。</li>
<li>将数据发生的变化通报给控制器。</li>
</ul>
</li>
<li><p>当然，上述的哪些事情需要做及调用什么方法来完成是由视图来决定的。<br>如果视图被标识为需要重新布局，<strong>UIKit</strong>就调用视图的<code>layoutSubviews:</code>方法。</p>
<p>您可以在自己的定制视图中重载这个方法，以便调整子视图的尺寸和位置。举例来说，如果一个视图具有很大的滚动区域，就需要使用几个子视图来“平铺”，而不是创建一个内存很可能装不下的大视图。在这个方法的实现中，视图可以隐藏所有不需显示在屏幕上的子视图，或者在重新定位之后将它们用于显示新的内容。作为这个过程的一部分，视图也可以将用于“平铺”的子视图标识为需要重画。</p>
</li>
<li><p>如果视图的任何部分被标识为需要重画，<strong>UIKit</strong> 就调用该视图的<code>drawRect:</code>方法。</p>
<p> UIKit只对那些需要重画的视图调用这个方法。在这个方法的实现中，所有视图都应该尽可能快地重画指定的区域，且都应该只重画自己的内容，不应该描画子视图的内容。在这个调用点上，视图不应该尝试进一步改变其属性或布局。</p>
<p> 所有更新过的视图都和其它可视内容进行合成，然后发送给图形硬件进行显示。</p>
</li>
<li><p>图形硬件将渲染完成的内容转移到屏幕。</p>
</li>
</ol>
<p>请注意：上述的更新模型主要适用于采纳内置视图和描画技术的应用程序。如果您的应用程序使用<strong>OpenGL ES</strong>来描画内容，则通常要配置一个全屏的视图，然后直接在<strong>OpenGL</strong>的图形上下文中进行描画。您的视图仍然需要处理触碰事件，但不需要对子视图进行布局或者实现<code>drawRect:</code>方法。有关<strong>OpenGL ES</strong>的更多信息，请参见“用<strong>OpenGL ES</strong>进行描画”部分。</p>
<p>基于上述的步骤说明可以看出，UIKit为您自己定制的视图提供如下主要的结合点：</p>
<pre><code>下面这些事件处理方法：

    touchesBegan:withEvent:

    touchesMoved:withEvent:

    touchesEnded:withEvent:

    touchesCancelled:withEvent:

layoutSubviews方法

drawRect:方法
</code></pre><p>大多数定制视图通过实现这些方法来得到自己期望的行为。您可能不需要重载所有方法，举例来说，如果您实现的视图是固定尺寸的，则可能不需要重载<code>layoutSubviews</code>方法。类似地，如果您实现的视图只是显示简单的内容，比如文本或图像，则通常可以通过简单地嵌入 <strong>UIImageView</strong> 和 <strong>UILabel</strong> 对象作为子视图来避免描画。</p>
<p>重要的是要记住，这些是主要的结合点，但不是全部。UIView类中有几个方法的设计目的就是让子类重载的。您可以通过查阅 <strong>UIView</strong>类参考中的描述来了解哪些方法可以被重载。</p>
<h2 id="视图渲染架构"><a href="#视图渲染架构" class="headerlink" title="视图渲染架构"></a>视图渲染架构</h2><p>虽然您通过视图来表示屏幕上的内容，但是 <strong>UIView</strong> 类自身的很多基础行为却严重依赖于另一个对象。<strong>UIKit</strong> 中每个视图对象的背后都有一个 <strong>Core Animation</strong> 层对象，它是一个 <strong>CALayer</strong> 类的实例，该类为视图内容的布局和渲染、以及合成和动画提供基础性的支持。</p>
<p>和<strong>Mac OS X</strong>（在这个平台上<strong>Core Animation</strong>支持是可选的）不同的是，<strong>iPhone OS</strong>将<strong>Core Animation</strong>集成到视图渲染实现的核心。虽然<strong>Core Animation</strong>发挥核心作用，但是<strong>UIKit</strong>在<strong>Core Animation</strong>上面提供一个透明的接口层，使编程体验更为流畅。这个透明的接口使开发者在大多数情况下不必直接访问<strong>Core Animation</strong>的层，而是通过<strong>UIView</strong>的方法和属性声明取得类似的行为。然而，当<strong>UIView</strong>类没有提供您需要的接口时，<strong>Core Animation</strong>就变得重要了，在那种情况下，您可以深入到<strong>Core Animation</strong>层，在应用程序中实现一些复杂的渲染。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/23/iOS 编程：UITextFiled/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/23/iOS 编程：UITextFiled/" class="post-title-link" itemprop="url">iOS 编程：UITextField</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-23 17:45:00" itemprop="dateCreated datePublished" datetime="2016-08-23T17:45:00+08:00">2016-08-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-18 00:32:48" itemprop="dateModified" datetime="2019-04-18T00:32:48+08:00">2019-04-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/23/iOS 编程：UITextFiled/" class="leancloud_visitors" data-flag-title="iOS 编程：UITextField">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p><strong>UITextField</strong> 对象用于在你的界面上显示一个可编辑的文本区域。使用文本区域可以收集来自用户使用屏幕上的键盘输入的基于文本的信息。键盘可以被配置为不同的输入类型，如纯文本，电子邮件，数字，等等。文本区域使用目标操作机制和委托对象来报告在编辑过程中所做的更改。</p>
<h3 id="初始化textFiled-，设置位置及大小"><a href="#初始化textFiled-，设置位置及大小" class="headerlink" title="初始化textFiled ，设置位置及大小"></a>初始化textFiled ，设置位置及大小</h3><pre><code>CGRect textFiledRect = CGRectMake(87, 70, 240, 30);
UITextField *textFiled = [[UITextField alloc] initWithFrame:textFiledRect];
</code></pre><h3 id="设置UITextFiled对象的边框样式"><a href="#设置UITextFiled对象的边框样式" class="headerlink" title="设置UITextFiled对象的边框样式"></a>设置UITextFiled对象的边框样式</h3><pre><code>textFiled.borderStyle = UITextBorderStyleRoundedRect;
</code></pre><p>如果设置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">*样式类型：*</span><br><span class="line"></span><br><span class="line">* UITextBorderStyleNone,</span><br><span class="line">* UITextBorderStyleLine,</span><br><span class="line">* UITextBorderStyleBezel,</span><br><span class="line">* UITextBorderStyleRoundedRect</span><br><span class="line">  </span><br><span class="line">### 设置输入框的背景颜色</span><br><span class="line">    textFiled.backgroundColor = [UIColor whiteColor];</span><br><span class="line"></span><br><span class="line">### 设置背景</span><br><span class="line">注意： 只有在 UITextBorderStyleNone 样式下，设置背景图才会生效，且图片大小小于 text 的frame时，图片会拉伸。</span><br><span class="line"></span><br><span class="line">    textFiled.borderStyle = UITextBorderStyleNone;</span><br><span class="line">    textFiled.background = [UIImage imageNamed:@&quot;***.png&quot;];</span><br><span class="line"></span><br><span class="line">### 设置enable值为NO时的背景</span><br><span class="line">    textFiled.disabledBackground = [UIImage imageNamed:@&quot;***.png&quot;];</span><br><span class="line"></span><br><span class="line">### 当输入框无内容时，设置占位符提示</span><br><span class="line">    textFiled.placeholder = @&quot;Hypontize me&quot;;</span><br><span class="line"></span><br><span class="line">### 设置输入框默认文本值</span><br><span class="line">    textFiled.text = @&quot;默认值&quot;;</span><br><span class="line"></span><br><span class="line">### 设置输入框内容的字体样式和大小</span><br><span class="line">    textFiled.font = [UIFont fontWithName:@&quot;Arial&quot; size:16];</span><br><span class="line"></span><br><span class="line">### 设置字体颜色</span><br><span class="line">    textFiled.textColor = [UIColor blueColor];</span><br><span class="line"></span><br><span class="line">### 输入框中是否显示×号，用于清空输入框内容</span><br><span class="line">    textFiled.clearButtonMode = UITextFieldViewModeAlways;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line">*样式类型：*</span><br><span class="line"></span><br><span class="line">* UITextFieldViewModeNever, 从不出现</span><br><span class="line">* UITextFieldViewModeWhileEditing,  编辑时出现</span><br><span class="line">* UITextFieldViewModeUnlessEditing, 编辑外出现</span><br><span class="line">* UITextFieldViewModeAlways 一直出现</span><br><span class="line">  </span><br><span class="line">### 用于密码输入：每输入一个字符就变成*</span><br><span class="line">    textFiled.secureTextEntry = YES;</span><br><span class="line"></span><br><span class="line">### 自动大小写功能</span><br><span class="line">    textFiled.autocapitalizationType = UITextAutocapitalizationTypeWords;</span><br><span class="line">*样式类型：*</span><br><span class="line">*  UITextAutocapitalizationTypeNone   //关闭</span><br><span class="line">* UITextAutocapitalizationTypeWords     //单词</span><br><span class="line">* UITextAutocapitalizationTypeSentences //句子</span><br><span class="line">* UITextAutocapitalizationTypeAllCharacters //所有字母</span><br><span class="line"></span><br><span class="line">### 换行键自动监测功能</span><br><span class="line">如果将该属性设置为YES，*UITextField* 对象会自动监测用户输入，并根据是否输入了文字启用/禁用换行键,如果文本内容长度为0，则禁用换行键，如果文本内容长度不为0，则启用换行键.</span><br><span class="line"></span><br><span class="line">    textFiled.enablesReturnKeyAutomatically = YES;</span><br><span class="line"></span><br><span class="line">### 拼写建议</span><br><span class="line">可以提供用户输错的单词并提供修改建议</span><br><span class="line"></span><br><span class="line">    textFiled.autocorrectionType = UITextAutocorrectionTypeYes;</span><br><span class="line"></span><br><span class="line">*样式类型：*</span><br><span class="line"></span><br><span class="line">* UITextAutocorrectionTypeDefault</span><br><span class="line">* UITextAutocorrectionTypeNo</span><br><span class="line">* UITextAutocorrectionTypeYes</span><br><span class="line"></span><br><span class="line">### 再次编辑就清空</span><br><span class="line">    textFiled.clearsOnBeginEditing = YES;</span><br><span class="line"></span><br><span class="line">### 内容对齐方式</span><br><span class="line">    textFiled.textAlignment =  NSTextAlignmentCenter;</span><br><span class="line"></span><br><span class="line">*样式类型：*</span><br><span class="line"></span><br><span class="line">* NSTextAlignmentLeft      = 0,    // 自视左对齐</span><br><span class="line">* NSTextAlignmentCenter    = 1,    // 居中</span><br><span class="line">* NSTextAlignmentRight     = 2,    // 右对齐   </span><br><span class="line">  </span><br><span class="line">### 内容的垂直对齐方式</span><br><span class="line">    textFiled.contentVerticalAlignment = UIControlContentVerticalAlignmentCenter;</span><br><span class="line"></span><br><span class="line">*样式类型：*</span><br><span class="line"></span><br><span class="line">* UIControlContentVerticalAlignmentCenter  = 0</span><br><span class="line">* UIControlContentVerticalAlignmentTop     = 1</span><br><span class="line">* UIControlContentVerticalAlignmentBottom  = 2</span><br><span class="line">* UIControlContentVerticalAlignmentFill    = 3</span><br><span class="line">  </span><br><span class="line">### 文本自适应文本窗口大小</span><br><span class="line">默认是保持原来大小,而让长文本滚动</span><br><span class="line"></span><br><span class="line">    textFiled.adjustsFontSizeToFitWidth = YES;</span><br><span class="line">    //设置文本最小字体，adjustsFontSizeToFitWidth=YES 时才起作用</span><br><span class="line">    textFiled.minimumFontSize = 10;</span><br><span class="line"></span><br><span class="line">### 设置键盘样式</span><br><span class="line">    textFiled.keyboardType = UIKeyboardTypeDefault;</span><br><span class="line"></span><br><span class="line">*样式类型：*</span><br><span class="line"></span><br><span class="line">* UIKeyboardTypeDefault,                // 默认键盘，支持所有字符</span><br><span class="line">* UIKeyboardTypeASCIICapable,           // 支持ASCII的默认键盘</span><br><span class="line">* UIKeyboardTypeNumbersAndPunctuation,  // 标准电话键盘，支持＋＊＃字符</span><br><span class="line">* UIKeyboardTypeURL,                    // URL键盘，支持.com按钮 只支持URL字符</span><br><span class="line">* UIKeyboardTypeNumberPad,              // 数字键盘</span><br><span class="line">* UIKeyboardTypePhonePad,               // 电话键盘</span><br><span class="line">* UIKeyboardTypeNamePhonePad,           // 电话键盘，也支持输入人名</span><br><span class="line">* UIKeyboardTypeEmailAddress,           // 用于输入电子邮件地址的键盘</span><br><span class="line">* UIKeyboardTypeDecimalPad NS_ENUM_AVAILABLE_IOS(4_1),   // 数字键盘 有数字和小数点</span><br><span class="line">* UIKeyboardTypeTwitter NS_ENUM_AVAILABLE_IOS(5_0),      // 优化的键盘，方便输入@、#字符，用于twitter文本输入</span><br><span class="line">* UIKeyboardTypeWebSearch NS_ENUM_AVAILABLE_IOS(7_0),    // 支持添加链接的默认键盘类型</span><br><span class="line">* UIKeyboardTypeAlphabet = UIKeyboardTypeASCIICapable, // Deprecated</span><br><span class="line"></span><br><span class="line">样式参考：[UIKeyboardType 图解](http://www.jianshu.com/p/446768b350c6)</span><br><span class="line">    </span><br><span class="line">### 软键盘换行键默认显示值</span><br><span class="line">    textFiled.returnKeyType = UIReturnKeyDone;</span><br><span class="line"></span><br><span class="line">*样式类型：*</span><br><span class="line"></span><br><span class="line">* UIReturnKeyDefault,   默认灰色按钮，标有Return</span><br><span class="line">* UIReturnKeyGo,        标有Go的蓝色按钮</span><br><span class="line">* UIReturnKeyGoogle,    标有Google的蓝色按钮，用于搜索</span><br><span class="line">* UIReturnKeyJoin,      标有Join的蓝色按钮</span><br><span class="line">* UIReturnKeyNext,      标有Next的蓝色按钮</span><br><span class="line">* UIReturnKeyRoute,     标有Route的蓝色按钮</span><br><span class="line">* UIReturnKeySearch,    标有Search的蓝色按钮</span><br><span class="line">* UIReturnKeySend,      标有Send的蓝色按钮</span><br><span class="line">* UIReturnKeyYahoo,     标有Yahoo的蓝色按钮</span><br><span class="line">* UIReturnKeyDone,      标有Done的蓝色按钮</span><br><span class="line">* UIReturnKeyEmergencyCall,     紧急呼叫按钮</span><br><span class="line">* UIReturnKeyContinue NS_ENUM_AVAILABLE_IOS(9_0),   标有Continue的蓝色按钮</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">### 键盘外观</span><br><span class="line">    textFiled.keyboardAppearance = UIKeyboardAppearanceAlert;</span><br><span class="line"></span><br><span class="line">*样式类型：*</span><br><span class="line"></span><br><span class="line">* UIKeyboardAppearanceDefault,          // 默认外观</span><br><span class="line">* UIKeyboardAppearanceDark NS_ENUM_AVAILABLE_IOS(7_0),</span><br><span class="line">* UIKeyboardAppearanceLight NS_ENUM_AVAILABLE_IOS(7_0),</span><br><span class="line">* UIKeyboardAppearanceAlert = UIKeyboardAppearanceDark,  // Deprecated</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">### 最右侧加图片</span><br><span class="line">    UIImageView *image = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@&quot;***.png&quot;]];</span><br><span class="line">    textFiled.rightView = image;</span><br><span class="line">    textFiled.rightViewMode = UITextFieldViewModeAlways;</span><br><span class="line"></span><br><span class="line">### 设置左侧图片</span><br><span class="line"></span><br><span class="line">    // 设置左侧图片</span><br><span class="line">    self.textField1.leftView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, CGRectGetHeight(self.textField1.frame), CGRectGetHeight(self.textField1.frame))];</span><br><span class="line">    self.textField1.leftViewMode = UITextFieldViewModeAlways;</span><br><span class="line">    </span><br><span class="line">    UIImageView* imgUser = [[UIImageView alloc] initWithFrame:CGRectMake(9, 9, 22, 22)];</span><br><span class="line">    imgUser.image = [UIImage imageNamed:@&quot;iconfont-user&quot;];</span><br><span class="line">    [self.textField1.leftView addSubview:imgUser];</span><br><span class="line"></span><br><span class="line">*样式类型：*</span><br><span class="line">    </span><br><span class="line">* UITextFieldViewModeNever,</span><br><span class="line">* UITextFieldViewModeWhileEditing,</span><br><span class="line">* UITextFieldViewModeUnlessEditing,</span><br><span class="line">* UITextFieldViewModeAlways</span><br><span class="line">  </span><br><span class="line">### 把textFiled添加到视图中</span><br><span class="line">    [backgroundView addSubview:textFiled];</span><br><span class="line"></span><br><span class="line">### 按return键盘放弃第一响应者</span><br><span class="line">UITextfield实例要遵守```UITextFieldDelegate```协议：</span><br><span class="line"></span><br><span class="line">    //设置代理，用于实现协议</span><br><span class="line">    //声明textFiled的代理是我，我会去实现把键盘往下收的方法 这个方法在UITextFieldDelegate里所以我们要采用UITextFieldDelegate这个协议</span><br><span class="line">    textFiled.delegate = self;</span><br><span class="line">    </span><br><span class="line">    - (BOOL)textFieldShouldReturn:(UITextField *)textField</span><br><span class="line">    &#123;</span><br><span class="line">        [textField resignFirstResponder];    </span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">### 重写绘制行为</span><br><span class="line">除了```UITextField```对象的风格选项，你还可以定制化```UITextField```对象，为他添加许多不同的重写方法，来改变文本字段的显示行为。这些方法都会返回一个```CGRect```结构，制定了文本字段每个部件的边界范围。以下方法都可以重写。</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">– textRectForBounds:　　  　//重写来重置文字区域</span><br><span class="line">– drawTextInRect:　　      　//改变绘文字属性.重写时调用super可以按默认图形属性绘制,若自己完全重写绘制函数，就不用调用super了.</span><br><span class="line">– placeholderRectForBounds:　　//重写来重置占位符区域</span><br><span class="line">– drawPlaceholderInRect:　　//重写改变绘制占位符属性.重写时调用super可以按默认图形属性绘制,若自己完全重写绘制函数，就不用调用super了.</span><br><span class="line">– borderRectForBounds:　　//重写来重置边缘区域</span><br><span class="line">– editingRectForBounds:　　//重写来重置编辑区域</span><br><span class="line">– clearButtonRectForBounds:　　//重写来重置clearButton位置,改变size可能导致button的图片失真</span><br><span class="line">– leftViewRectForBounds:</span><br><span class="line">– rightViewRectForBounds:</span><br></pre></td></tr></table></figure></p>
<h3 id="委托方法"><a href="#委托方法" class="headerlink" title="委托方法"></a>委托方法</h3><ol>
<li><strong>目标-动作（Target-Action）设计模式：</strong>当某个特定的事件发生时（例如按下按钮），发生事件的一方会向指定的目标对象发送一个之前设定好的动作消息。</li>
<li>在目标-动作中，针对不同的事件，需要创建不同的动作消息。<strong>UIButton</strong> 对象的事件比较简单，通常只需要处理点击事件；相反，像 <strong>UITextField</strong>这类事件复杂的对象，Apple使用委托设计模式。 <strong>UITextField</strong>对象具有一个委托属性，通过为 <strong>UITextField</strong>对象设置委托， <strong>UITextField</strong>对象会在发生事件时向委托发送响应的消息，由委托处理该事件。</li>
<li>凡是支持委托的对象，其背后都有一个相应的协议，如果一个类实现了某个协议中规定的方法，就称这个类遵守（conform）了该协议。</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UITextFieldDelegate协议</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UITextFieldDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@optional</span>   <span class="comment">//写在该指令之后的所有方法全部声明为可选的</span></span><br><span class="line"><span class="variable">@required</span>  <span class="comment">//必须实现的方法</span></span><br></pre></td></tr></table></figure>
<p>对于编辑 UITextField 对象文本内容的事件，有以下两个对应的委托方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始编辑时触发，文本字段将成为first responder</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">textFieldDidBeginEditing:</span>(UITextField *)textField;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法被触发时，输入框已经结束编辑状态</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">textFieldDidEndEditing:</span>(UITextField *)textField;             </span><br><span class="line"><span class="comment">// may be called if forced even if shouldEndEditing returns NO (e.g. view removed from window) or endEditing:YES called</span></span><br></pre></td></tr></table></figure>
<p>还有一类带有返回值的委托方法，用于从委托中查询需要的信息</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> - <span class="built_in">BOOL</span>)textFieldShouldBeginEditing:(<span class="built_in">UITextField</span> *)textField &#123;</span><br><span class="line">（输入框询问是否可以编辑，<span class="literal">YES</span>可以编辑，<span class="literal">NO</span>不能编辑）</span><br><span class="line"> <span class="comment">//返回一个BOOL值，指定是否循序文本字段开始编辑,返回NO时不能唤起键盘进行编辑。</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> - (<span class="built_in">BOOL</span>)textFieldShouldEndEditing:(<span class="built_in">UITextField</span> *)textField &#123;</span><br><span class="line">  <span class="comment">//返回BOOL值，指定是否允许文本字段结束编辑，当编辑结束，文本字段会放弃first responder状态　</span></span><br><span class="line">  <span class="comment">//要想在用户结束编辑时阻止文本字段消失，可以返回NO　</span></span><br><span class="line">  <span class="comment">//这对一些文本字段必须始终保持活跃状态的程序很有用，比如即时消息</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;　<span class="comment">//一直处于编辑状态</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> - (<span class="built_in">BOOL</span>)textField:(<span class="built_in">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class="built_in">NSRange</span>)range replacementString:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当用户使用自动更正功能，把输入的文字修改为推荐的文字时，就会调用这个方法。　</span></span><br><span class="line">	<span class="comment">//这对于想要加入撤销选项的应用程序特别有用　</span></span><br><span class="line">	<span class="comment">//可以跟踪字段内所做的最后一次修改，也可以对所有编辑做日志记录,用作审计用途。　　 </span></span><br><span class="line">	<span class="comment">//要防止文字被改变可以返回NO　</span></span><br><span class="line">	<span class="comment">//这个方法的参数中有一个NSRange对象，指明了被改变文字的位置，建议修改的文本也在其中　</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> - (<span class="built_in">BOOL</span>)textFieldShouldClear:(<span class="built_in">UITextField</span> *)textField &#123;</span><br><span class="line"><span class="comment">//返回一个BOOL值指明是否允许根据用户请求清除内容　</span></span><br><span class="line"><span class="comment">//可以设置在特定条件下才允许清除内容　</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;　<span class="comment">//返回YES，输入内容后，点击右边的清除按钮可以清除，返回NO，点击清除不起作用	</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> - (<span class="built_in">BOOL</span>)textFieldShouldReturn:(<span class="built_in">UITextField</span> *)textField &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回一个BOOL值，指明是否允许在按下回车键时结束编辑　</span></span><br><span class="line">	<span class="comment">//如果允许要调用resignFirstResponder 方法，这会导致结束编辑，而键盘会被收起[textField 	resignFirstResponder];</span></span><br><span class="line">	<span class="comment">//查一下resign（放弃）这个单词的意思就明白这个方法了　</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如 <strong>UITextField</strong> 对象的委托属性为 <strong>HQLHyponsisViewController</strong>自身，<strong>HQLHyponsisViewController</strong>类实现了 <strong>UITextFieldDelegate</strong>协议，当“return”键被按下时触发协议方法， <strong>HQLHyponsisViewController.m</strong> 文件中实现的<code>textFieldShouldReturn:</code>方法被调用。</p>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p><strong>UITextField</strong> 派生自 <strong>UIControl</strong>，所以 <strong>UIControl</strong> 类中的通知系统在文本字段中也可以使用。除了 <strong>UIControl</strong> 类的标准事件，你还可以使用下列 <strong>UITextField</strong>  类特有的事件. </p>
<p>只有这三个:<br><figure class="highlight plain"><figcaption><span>```  </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```UITextFieldTextDidChangeNotification</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>``` </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当文本字段退出编辑模式时触发。通知的object属性存储了最终文本。 </span><br><span class="line">因为文本字段要使用键盘输入文字，所以下面这些事件发生时，也会发送动作通知.</span><br><span class="line"></span><br><span class="line">	UIKeyboardWillShowNotification 　//键盘显示之前发送</span><br><span class="line">	UIKeyboardDidShowNotification  　//键盘显示之后发送</span><br><span class="line">	UIKeyboardWillHideNotification 　//键盘隐藏之前发送</span><br><span class="line">	UIKeyboardDidHideNotification  　//键盘隐藏之后发送</span><br><span class="line"></span><br><span class="line">#### 监听UITextField的值判断是否禁用按钮</span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)viewDidLoad {<br>  [super viewDidLoad];<br>  // 添加通知<br>  [[NSNotificationCenter defaultCenter] addObserver:self</p>
<pre><code>selector:@selector(textFieldTextDidChanged:)
    name:UITextFieldTextDidChangeNotification
  object:nil];
</code></pre><p>}</p>
</li>
<li><p>(void)dealloc {<br>  // 移除通知<br>  [[NSNotificationCenter defaultCenter] removeObserver:self];<br>}</p>
</li>
</ul>
<p>#pragma mark - NSNotification</p>
<ul>
<li>(void)textFieldTextDidChanged:(NSNotification *)notification {<br>  BOOL isTextFieldTextNull = (self.usernameTextField.text.length == 0)||(self.passwordTextField.text.length == 0) ;<br>  self.loginButton.enabled = !isTextFieldTextNull;<br>}<br><code>`</code></li>
</ul>
<h3 id="在storyboard中设置UITextField"><a href="#在storyboard中设置UITextField" class="headerlink" title="在storyboard中设置UITextField"></a>在storyboard中设置UITextField</h3><ol>
<li>Text ：设置文本框的默认文本。</li>
<li>Placeholder ： 可以在文本框中显示灰色的字，用于提示用户应该在这个文本框输入什么内容。当这个文本框中输入了数据时，用于提示的灰色的字将会自动消失。</li>
<li>Background ：</li>
<li>Disabled ： 若选中此项，用户将不能更改文本框内容。</li>
<li>接下来是三个按钮，用来设置对齐方式。</li>
<li>Border Style ： 选择边界风格。</li>
<li>Clear Button ： 这是一个下拉菜单，你可以选择清除按钮什么时候出现，所谓清除按钮就是出一个现在文本框右边的小 X ，你可以有以下选择：<ul>
<li>Never appears ： 从不出现</li>
<li>Appears while editing ： 编辑时出现</li>
<li>Appears unless editing ： </li>
<li>Is always visible ： 总是可见</li>
</ul>
</li>
<li>Clear when editing begins ： 若选中此项，则当开始编辑这个文本框时，文本框中之前的内容会被清除掉。比如，你现在这个文本框 A 中输入了 “What” ，之后去编辑文本框 B，若再回来编辑文本框 A ，则其中的 “What” 会被立即清除。</li>
<li>Text Color ： 设置文本框中文本的颜色。</li>
<li>Font ： 设置文本的字体与字号。</li>
<li>Min Font Size ： 设置文本框可以显示的最小字体（不过我感觉没什么用）</li>
<li>Adjust To Fit ： 指定当文本框尺寸减小时，文本框中的文本是否也要缩小。选择它，可以使得全部文本都可见，即使文本很长。但是这个选项要跟 Min Font Size 配合使用，文本再缩小，也不会小于设定的 Min Font Size 。<br>接下来的部分用于设置键盘如何显示。</li>
<li>Captitalization ： 设置大写。下拉菜单中有四个选项：<ul>
<li>None ： 不设置大写</li>
<li>Words ： 每个单词首字母大写，这里的单词指的是以空格分开的字符串</li>
<li>Sentances ： 每个句子的第一个字母大写，这里的句子是以句号加空格分开的字符串</li>
<li>All Characters ： 所以字母大写</li>
</ul>
</li>
<li>Correction ： 检查拼写，默认是 YES 。</li>
<li>Keyboard ： 选择键盘类型，比如全数字、字母和数字等。</li>
<li>Appearance：</li>
<li>Return Key ： 选择返回键，可以选择 Search 、 Return 、 Done 等。</li>
<li>Auto-enable Return Key ： 如选择此项，则只有至少在文本框输入一个字符后键盘的返回键才有效。</li>
<li>Secure ： 当你的文本框用作密码输入框时，可以选择这个选项，此时，字符显示为星号。</li>
</ol>
<ol>
<li>Alignment Horizontal 水平对齐方式</li>
<li>Alignment Vertical 垂直对齐方式</li>
<li>用于返回一个BOOL值　输入框是否 Selected(选中) Enabled(可用) Highlighted(高亮)</li>
</ol>
<h3 id="限制只能输入特定的字符"><a href="#限制只能输入特定的字符" class="headerlink" title="限制只能输入特定的字符"></a>限制只能输入特定的字符</h3><pre><code>(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string{
NSCharacterSet *cs;
//invertedSet方法是去反字符,把所有的除了NUMBERS 里的字符都找出来(包含去空格功能)

cs = [[NSCharacterSet characterSetWithCharactersInString:NUMBERS]invertedSet];
</code></pre><p>​<br>​    // componentsJoinedByString 用于根据一个字符串来将数组连接成一个新的字符串。<br>​    NSString *filtered = [[string componentsSeparatedByCharactersInSet:cs]componentsJoinedByString:@””]; //按cs分离出数组,数组按@””分离出字符串<br>​<br>​    BOOL canChange = [string isEqualToString:filtered];<br>​<br>    return canChange;<br>    //这样写了以后，输入非数字时不能输入<br>    }</p>
<p>上面那个NUMBERS是一个宏，可以在文件顶部定义：</p>
<pre><code>#define NUMBERS @”0123456789n” （这个代表可以输入数字和换行，请注意这个n，如果不写这个，Done按键将不会触发，如果用在SearchBar中，将会不触发Search事件，因为你自己限制不让输入n，好惨，我在项目中才发现的。）
</code></pre><p>所以，如果你要限制输入英文和数字的话，就可以把这个定义为：</p>
<pre><code>#define kAlphaNum   @”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789″。
</code></pre><p>当然，你还可以在以上方法return之前，做一提示的，比如提示用户只能输入数字之类的。如果你觉得有需要的话。</p>
<h3 id="限制只能输入一定长度的字符"><a href="#限制只能输入一定长度的字符" class="headerlink" title="限制只能输入一定长度的字符"></a>限制只能输入一定长度的字符</h3><pre><code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string; 
{　
//string就是此时输入的那个字符 textField就是此时正在输入的那个输入框 返回YES就是可以改变输入框的值 NO相反

if ([string isEqualToString:@&quot;n&quot;])　
//按回车可以改变 
//这里这个字符写什么，就只能输入什么
{ 
    return YES; 
} 

NSString * toBeString = [textField.text stringByReplacingCharactersInRange:range withString:string]; //得到输入框的内容

if (self.myTextField == textField)　
//判断是否时我们想要限定的那个输入框
{ 
    if ([toBeString length] &gt; 20) { 
    //如果输入框内容大于20则弹出警告
textField.text = [toBeString substringToIndex:20]; 
UIAlertView *alert = [[[UIAlertView alloc] initWithTitle:nil message:@&quot;超过最大字数不能输入了&quot; delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil, nil] autorelease]; 
//iOS8.3以后用 UIAlertController [alert show]; 

/*
UIAlertController *alertView = [UIAlertController alertControllerWithTitle:@&quot;提示&quot;message:@&quot;超过最大字数不能输入了&quot;preferredStyle:UIAlertControllerStyleActionSheet];
    [selfpresentViewController:alertViewanimated:YEScompletion:nil];
*/


        return NO; 
    } 
} 
return YES; 
}
</code></pre><ul>
<li><a href="http://blog.csdn.net/u010850094/article/details/51525964" target="_blank" rel="noopener">http://blog.csdn.net/u010850094/article/details/51525964</a></li>
<li><a href="http://www.jianshu.com/p/b3ad55a55448" target="_blank" rel="noopener">如何设计出更好的表单？</a></li>
</ul>
<h3 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h3>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/23/iOS 编程：icon和启动图尺寸/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/23/iOS 编程：icon和启动图尺寸/" class="post-title-link" itemprop="url">iOS 编程：icon和启动图尺寸</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-23 14:33:00" itemprop="dateCreated datePublished" datetime="2016-08-23T14:33:00+08:00">2016-08-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-17 17:23:15" itemprop="dateModified" datetime="2019-04-17T17:23:15+08:00">2019-04-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/23/iOS 编程：icon和启动图尺寸/" class="leancloud_visitors" data-flag-title="iOS 编程：icon和启动图尺寸">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>Retina显示屏拥有很高的分辨率——其中4英寸屏幕是640像素×1136像素，3.5英寸屏幕是640像素×960像素（之前的屏幕分辨率是320像素×480像素）。</p>
<p>对于矢量图像，不用做任何处理就能够在两种设备上有最好的显示效果。</p>
<p>如果应用是通过Core Graphics函数绘图的，那么画出的图像在不同的设备上会有不同的显示效果。Core Graphics以点为单位描述线、曲线和文字等。对于非Retina显示屏，一个点是一个像素。对于Retina显示屏，一个点是2像素×2像素。</p>
<p>开发者需要为高分辨率的图片文件加上后缀名@2×。</p>
<h4 id="加载画面尺寸"><a href="#加载画面尺寸" class="headerlink" title="加载画面尺寸"></a>加载画面尺寸</h4><p><img src="http://upload-images.jianshu.io/upload_images/2648731-bf4d81ba91cc856e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h3 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h3><p><a href="http://www.cnblogs.com/shaoting/p/4941634.html" target="_blank" rel="noopener">iOS开发：icon和启动图尺寸</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/19/iOS 编程：用 Core Graphics 画各种图形/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/19/iOS 编程：用 Core Graphics 画各种图形/" class="post-title-link" itemprop="url">iOS 编程：用 Core Graphics 画各种图形</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-19 10:18:00" itemprop="dateCreated datePublished" datetime="2016-08-19T10:18:00+08:00">2016-08-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-17 17:24:35" itemprop="dateModified" datetime="2019-04-17T17:24:35+08:00">2019-04-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/19/iOS 编程：用 Core Graphics 画各种图形/" class="leancloud_visitors" data-flag-title="iOS 编程：用 Core Graphics 画各种图形">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-3dcdf1527bdf692f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-08-25 下午5.06.58.png"> </p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>无论绘制JPEG、PDF还是视图的图层，都是由 <strong>Core Graphics</strong> 框架完成的。</li>
<li><strong>Core Graphics</strong> 中最重要的“对象”是图形上下文（graphics context）,图形上下文是 <strong>CGContextRef</strong> 的“对象”，负责存储绘画状态（例如画笔颜色和线条粗细）和绘制内容所处的内存空间。</li>
</ul>
<blockquote>
</blockquote>
<p>注：<br> 带有 <strong>Ref</strong> 后缀的类型是 <strong>Core Graphics</strong> 中用来模拟面向对象机制的C结构。<br>带有 <strong>Ref</strong> 后缀类型的对象可能具有指向其他 <strong>Core Graphics</strong> “对象”的强引用指针，并成为这些“对象”的拥有者。但是ARC无法识别这类强引用和“对象”所有权，必须在使用完成之后手动释放。<br>规则是：如果使用名称中带有create 或者 copy 的函数创建了一个 <strong>Core Graphics</strong> “对象”，就必须调用对应的Release函数并传入该对象的指针。</p>
<h5 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect:"></a>drawRect:</h5><ul>
<li>视图的 <code>drawRect：</code>方法在执行之前，系统首先为视图的图层创建一个图形上下文，然后为绘画状态设置一些默认参数。</li>
<li><code>drawRect：</code>方法开始执行时，随着图形上下文不断执行绘画操作，图层上的内容也会随之改变。</li>
<li><code>drawRect：</code>方法执行完毕后，系统会将图层与其他图层一起组合完成完整的图像并显示在屏幕上。</li>
</ul>
<p>视图会根据 <code>drawRect：</code>方法将自己绘制到图层上，UIView 的子类可以覆盖 <code>drawRect：</code>方法，完成自定义的绘图任务。</p>
<hr>
<h2 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h2><p>使用 <strong>CGContext</strong></p>
<h3 id="边框圆"><a href="#边框圆" class="headerlink" title="边框圆"></a>边框圆</h3><pre><code>//一个不透明的Quartz 2D绘画环境，相当于一个画布
CGContextRef context = UIGraphicsGetCurrentContext();

CGContextSetRGBStrokeColor(context, 1, 0, 0, 1);//画笔的颜色

CGContextSetLineWidth(context, 1.0);//线宽

CGContextAddArc(context,
                100, 20, 15, 0, M_PI * 2.0, 0);//添加圆

CGContextDrawPath(context, kCGPathStroke);//绘制路径
</code></pre><p>​    </p>
<h3 id="边框圆（方法与上类似，待修改完善）"><a href="#边框圆（方法与上类似，待修改完善）" class="headerlink" title="边框圆（方法与上类似，待修改完善）"></a>边框圆（方法与上类似，待修改完善）</h3><pre><code>CGContextSetRGBStrokeColor(context, 1, 0, 0, 1);

CGMutablePathRef path = CGPathCreateMutable();

//创建用于转移坐标的transform
CGAffineTransform trandform =CGAffineTransformMakeTranslation(80, 40);

CGPathAddArc(path, &amp;trandform, 80, 40, 25, 0, M_PI * 2.0, YES);

CGContextAddPath(context, path);

CGContextDrawPath(context, kCGPathStroke);

CGPathRelease(path);
</code></pre><h3 id="填充圆，无边框"><a href="#填充圆，无边框" class="headerlink" title="填充圆，无边框"></a>填充圆，无边框</h3><pre><code>CGContextAddArc(context, 150, 30, 30, 0, M_PI * 2.0, 0);//添加一个圆

CGContextDrawPath(context, kCGPathFill);//仅填充
</code></pre><h3 id="画边框圆，并填充圆"><a href="#画边框圆，并填充圆" class="headerlink" title="画边框圆，并填充圆"></a>画边框圆，并填充圆</h3><pre><code>UIColor *myColor = [UIColor colorWithRed:1 green:0 blue:0 alpha:1];

CGContextSetFillColorWithColor(context, myColor.CGColor);//填充颜色

CGContextSetLineWidth(context, 3.0);//线宽

CGContextAddArc(context, 250, 40, 40, 0, M_PI * 2.0, 0);//添加一个圆

CGContextDrawPath(context, kCGPathFillStroke);//绘制路径并填充
</code></pre><h3 id="使用-UIBezierPath（贝塞尔曲线）绘制圆形"><a href="#使用-UIBezierPath（贝塞尔曲线）绘制圆形" class="headerlink" title="使用 UIBezierPath（贝塞尔曲线）绘制圆形"></a>使用 UIBezierPath（贝塞尔曲线）绘制圆形</h3><ul>
<li><strong>UIBezierPath</strong> 和 <strong>UIColor</strong> 的所有绘图功能都可以通过直接调用 <strong>Core Graphics</strong> 函数完成。</li>
<li><strong>UIBezierPath</strong> 类，其实是将 <strong>Core Graphics</strong>代码封装在了一系列方法中，以便开发者调用，降低了绘图的难度。</li>
<li>但是有些功能只能使用 <strong>Core Graphics</strong> 完成，如：绘制渐变。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置圆心    </span></span><br><span class="line"><span class="built_in">CGPoint</span> centre = <span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">60</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置半径   </span></span><br><span class="line"><span class="keyword">float</span> radius = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  UIBezierPath 用来绘制直线或曲线，从而组成各种形状   </span></span><br><span class="line"><span class="built_in">UIBezierPath</span> *bezierPath = [[<span class="built_in">UIBezierPath</span> alloc]init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义路径：以中心点为圆心、radious的值为半径定义一个0到M_PI*2.0弧度的路径（整圆)</span></span><br><span class="line">[bezierPath addArcWithCenter:centre</span><br><span class="line">                          radius:radius</span><br><span class="line">                      startAngle:<span class="number">0.0</span></span><br><span class="line">                        endAngle:PI * <span class="number">2.0</span></span><br><span class="line">                       clockwise:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线条宽度</span></span><br><span class="line">bezierPath.lineWidth = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线条颜色</span></span><br><span class="line">[[<span class="built_in">UIColor</span> lightGrayColor] setStroke];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制路径</span></span><br><span class="line">[bezierPath stroke];</span><br></pre></td></tr></table></figure>
<h5 id="绘制同心圆"><a href="#绘制同心圆" class="headerlink" title="绘制同心圆"></a>绘制同心圆</h5><pre><code>//获取当前画板边界
CGRect bounds=self.bounds;

//根据bounds计算中心点
CGPoint center;
center.x = bounds.origin.x + bounds.size.width / 2.0;
center.y = bounds.origin.y + bounds.size.height / 2.0;

//使最外层圆形成为视图的外接圆
//使用视图的对角线作为最外层圆形的直径
float maxRadius = hypot(bounds.size.width, bounds.size.height)/ 2.0;

UIBezierPath *path = [[UIBezierPath alloc] init];

for (float currentRadius = maxRadius;
     currentRadius&gt;0;
     currentRadius -=20)
{
    //每次绘制新圆前，抬笔，重置起始点
    [path moveToPoint:CGPointMake(center.x +currentRadius, center.y)];

    [path addArcWithCenter:center
                    radius:currentRadius
                startAngle:0.0
                  endAngle:M_PI * 2.0
                 clockwise:YES];
}

//设置线条宽度为10点
path.lineWidth = 10;

//设置绘制颜色为浅灰色
[[UIColor lightGrayColor] setStroke];

//绘制路径
[path stroke];
</code></pre><hr>
<h3 id="画线及弧线"><a href="#画线及弧线" class="headerlink" title="画线及弧线"></a>画线及弧线</h3><h5 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h5><pre><code>CGPoint point[3];
point[0] = CGPointMake(100, 120);
point[1] = CGPointMake(130, 120);
point[2] = CGPointMake(120, 100);

//CGContextAddLines(&lt;#CGContextRef  _Nullable c#&gt;, &lt;#const CGPoint * _Nullable points#&gt;, &lt;#size_t count#&gt;)// （context画布，坐标数组，坐标数）
CGContextAddLines(context, point, 3);//添加线

CGContextDrawPath(context, kCGPathStroke);//根据坐标绘制路径
</code></pre><h5 id="画笑脸弧线"><a href="#画笑脸弧线" class="headerlink" title="画笑脸弧线"></a>画笑脸弧线</h5><pre><code>//左眼
CGContextSetRGBStrokeColor(context, 0, 0, 1, 1);//改变画笔颜色

CGContextMoveToPoint(context, 140, 120);//开始坐标p1

//CGContextAddArcToPoint(context, &lt;#CGFloat x1#&gt;, &lt;#CGFloat y1#&gt;, &lt;#CGFloat x2#&gt;, &lt;#CGFloat y2#&gt;, &lt;#CGFloat radius#&gt;)
//开始坐标p1与（x1,y1）相连,（x1,y1）与（x2,y2）相连
CGContextAddArcToPoint(context, 150, 110, 160, 120, 20);

CGContextStrokePath(context);

//右眼
CGContextMoveToPoint(context, 180, 120);
CGContextAddArcToPoint(context, 190, 110, 200, 120, 20);
CGContextStrokePath(context);

//嘴巴
CGContextMoveToPoint(context, 160, 150);
CGContextAddArcToPoint(context, 170, 160, 180, 150, 20);
CGContextStrokePath(context);
</code></pre><hr>
<h3 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h3><h5 id="画矩形框"><a href="#画矩形框" class="headerlink" title="画矩形框"></a>画矩形框</h5><pre><code>CGContextStrokeRect(context, CGRectMake(100, 200, 50, 20));
</code></pre><h5 id="画填充块"><a href="#画填充块" class="headerlink" title="画填充块"></a>画填充块</h5><pre><code>CGContextFillRect(context, CGRectMake(160, 200, 50, 20));
</code></pre><h5 id="画矩形，并填充颜色"><a href="#画矩形，并填充颜色" class="headerlink" title="画矩形，并填充颜色"></a>画矩形，并填充颜色</h5><pre><code>UIColor *myRectColor = [UIColor blueColor];
CGContextSetFillColorWithColor(context, myRectColor.CGColor);//填充颜色

UIColor *myRectFrameColor = [UIColor redColor];
CGContextSetStrokeColorWithColor(context, myRectFrameColor.CGColor);//线框颜色

CGContextAddRect(context, CGRectMake(100, 230, 100, 50));//画框
CGContextSetLineWidth(context, 2.0);//线宽
CGContextDrawPath(context, kCGPathFillStroke);//绘画路径
</code></pre><h5 id="画矩形，并填充渐变色"><a href="#画矩形，并填充渐变色" class="headerlink" title="画矩形，并填充渐变色"></a>画矩形，并填充渐变色</h5><pre><code>CGContextSaveGState(UIGraphicsGetCurrentContext());

//设置渐变
CGFloat locations [2] ={0.0,1.0};
CGFloat components[8] ={1.0,0.0,0.0,1.0,    //起始颜色为红色
    0.0,1.0,0.0,1.0};   //终止颜色为黄色

//色彩范围容器
CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();

//渐变属性：颜色空间、颜色、位置、有效数量
//CGGradientCreateWithColorComponents:创建包含渐变的CGGradientRef对象
CGGradientRef gradient = CGGradientCreateWithColorComponents(colorspace, components, locations, 2);

//画矩形
CGContextMoveToPoint(context, 250, 230);
CGContextAddLineToPoint(context, 350, 230);
CGContextAddLineToPoint(context, 350, 280);
CGContextAddLineToPoint(context, 250, 280);
CGContextClip(context);//裁剪路径

//控制渐变的方向和形状
CGPoint startPoint = CGPointMake(250,230);
CGPoint endPoint = CGPointMake(350,280);

//绘制线性渐变
CGContextDrawLinearGradient(context, gradient, startPoint, endPoint, kCGGradientDrawsAfterEndLocation);

CGGradientRelease(gradient);
CGColorSpaceRelease(colorspace);

//恢复Graphical Context图形上下文
CGContextRestoreGState(UIGraphicsGetCurrentContext());
</code></pre><hr>
<h3 id="画扇形和椭圆"><a href="#画扇形和椭圆" class="headerlink" title="画扇形和椭圆"></a>画扇形和椭圆</h3><h5 id="画扇形就是画圆，只不过设置角度的大小，形成一个扇形"><a href="#画扇形就是画圆，只不过设置角度的大小，形成一个扇形" class="headerlink" title="画扇形就是画圆，只不过设置角度的大小，形成一个扇形"></a>画扇形就是画圆，只不过设置角度的大小，形成一个扇形</h5><pre><code>UIColor *color1 = [UIColor colorWithRed:227 green:237 blue:205 alpha:1];
CGContextSetFillColorWithColor(context, color1.CGColor);//填充颜色

//以10为半径围绕圆形画指定角度的扇形
CGContextMoveToPoint(context, 40, 380);
CGContextAddArc(context, 40, 380, 40, -60 * M_PI /180, - 120 * M_PI /180, 1);
CGContextClosePath(context);//路径结束标志

CGContextDrawPath(context, kCGPathFillStroke);//绘制路径
</code></pre><hr>
<h5 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h5><pre><code>CGContextAddEllipseInRect(context, CGRectMake(100, 340, 40, 20));

CGContextDrawPath(context, kCGPathFillStroke);
</code></pre><hr>
<h3 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h3><pre><code>//只要三个点就行，跟画一条线方式一样，把三点连起来
CGPoint triangle[3];//坐标数组
triangle[0] = CGPointMake(60, 430);
triangle[1] = CGPointMake(20, 470);
triangle[2] = CGPointMake(80, 480);

CGContextAddLines(context, triangle, 3);//添加线
CGContextClosePath(context);//封闭路径

UIColor *fillcolor = [UIColor brownColor];
CGContextSetFillColorWithColor(context, fillcolor.CGColor);//填充色

CGContextDrawPath(context, kCGPathFillStroke);//根据坐标绘制路径并填充
</code></pre><h3 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h3><pre><code>//获得当前画板
CGContextRef context = UIGraphicsGetCurrentContext();

CGRect bounds = self.bounds;

//标记
CGContextBeginPath(context);

//设置起点
CGContextMoveToPoint(context,bounds.size.width / 2.0,bounds.size.height /2.0+70);
CGContextAddLineToPoint(context, bounds.size.width / 2.0 - 60, bounds.size.height / 2.0 +120);
CGContextAddLineToPoint(context, bounds.size.width / 2.0 + 60, bounds.size.height / 2.0 +120);
//路径结束标志
CGContextClosePath(context);

//设置边框颜色
[[UIColor grayColor] setStroke];
//绘制路径
CGContextDrawPath(context, kCGPathStroke);
</code></pre><hr>
<h3 id="画圆角矩形"><a href="#画圆角矩形" class="headerlink" title="画圆角矩形"></a>画圆角矩形</h3><pre><code>float fw = 160;
float fh = 500;

CGContextMoveToPoint(context, fw+20, fh);//开始坐标，右边开始

//圆弧与(x1,y1)(x2,y2)的直线相切
//CGContextAddArcToPoint(&lt;#CGContextRef  _Nullable c#&gt;, 
                                &lt;#CGFloat x1#&gt;, 
                                &lt;#CGFloat y1#&gt;, 
                                &lt;#CGFloat x2#&gt;, 
                                &lt;#CGFloat y2#&gt;, 
                                &lt;#CGFloat radius#&gt;); 

CGContextAddArcToPoint(context, fw, fh, fw, fh+20, 10);//左上角角度
CGContextAddArcToPoint(context, fw, 600, fw+20, 600, 10);//左下角角度
CGContextAddArcToPoint(context, 280, 600, 280, 580, 10);//右下角
CGContextAddArcToPoint(context,280, fh, 260, fh, 10);//右上角
CGContextClosePath(context);//封闭路径
CGContextDrawPath(context, kCGPathStroke);//根据坐标绘制路径
</code></pre><hr>
<h3 id="画贝塞尔曲线"><a href="#画贝塞尔曲线" class="headerlink" title="画贝塞尔曲线"></a>画贝塞尔曲线</h3><h5 id="二次曲线"><a href="#二次曲线" class="headerlink" title="二次曲线"></a>二次曲线</h5><pre><code>CGContextMoveToPoint(context, 90, 630);//设置path的起点

//设置贝塞尔曲线的控制点坐标(cpx,cpy)和终点坐标(x,y)
//CGContextAddQuadCurveToPoint(&lt;#CGContextRef  _Nullable c#&gt;, &lt;#CGFloat cpx#&gt;, &lt;#CGFloat cpy#&gt;, &lt;#CGFloat x#&gt;, &lt;#CGFloat y#&gt;);
CGContextAddQuadCurveToPoint(context, 90, 720, 150, 630);

CGContextStrokePath(context);
</code></pre><h5 id="三次曲线函数"><a href="#三次曲线函数" class="headerlink" title="三次曲线函数"></a>三次曲线函数</h5><pre><code>CGContextMoveToPoint(context, 180, 630);//设置path起点

//CGContextAddCurveToPoint(&lt;#CGContextRef  _Nullable c#&gt;, &lt;#CGFloat cp1x#&gt;, &lt;#CGFloat cp1y#&gt;, &lt;#CGFloat cp2x#&gt;, &lt;#CGFloat cp2y#&gt;, &lt;#CGFloat x#&gt;, &lt;#CGFloat y#&gt;)
CGContextAddCurveToPoint(context, 225, 570, 225, 690, 270, 630);
CGContextStrokePath(context);
</code></pre><hr>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><pre><code>UIImage *myImage =[UIImage imageNamed:@&quot;monk.jpg&quot;];
[myImage drawInRect:CGRectMake(80, 680, 80, 56)];

//保持图片大小在point点开始画图
[myImage drawAtPoint:CGPointMake(0, 0)];

//使图片上下颠倒
CGContextDrawImage(context, CGRectMake(200, 680, 80, 56), myImage.CGImage);

//平铺图    
CGContextDrawTiledImage(context, CGRectMake(&lt;#CGFloat x#&gt;, &lt;#CGFloat y#&gt;, &lt;#CGFloat width#&gt;, &lt;#CGFloat height#&gt;), &lt;#CGImageRef  _Nullable image#&gt;);
</code></pre><hr>
<h3 id="为图片添加阴影"><a href="#为图片添加阴影" class="headerlink" title="为图片添加阴影"></a>为图片添加阴影</h3><ul>
<li>绘制阴影之前，需要将阴影效果添加到一个图形上下文中，之后在该图形上下文中绘制的所有不透明图片都会带有阴影效果。</li>
<li>复写父类 <strong>UIView</strong> 的 <code>drawRect:</code> 方法，绘制自定义图形：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 保存绘图状态</span></span><br><span class="line"><span class="built_in">CGContextSaveGState</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>());</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 添加阴影：设置阴影偏移量、模糊指数</span></span><br><span class="line"><span class="built_in">CGContextSetShadow</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(), <span class="built_in">CGSizeMake</span>(<span class="number">4</span>, <span class="number">7</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建UIImage对象</span></span><br><span class="line"><span class="built_in">UIImage</span> *logoImage2 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"logo.png"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将图像绘制到视图</span></span><br><span class="line"><span class="built_in">CGRect</span> logoBounds = <span class="built_in">CGRectMake</span>(bounds.size.width/<span class="number">2.0</span><span class="number">-100</span>, bounds.size.height/<span class="number">2.0</span><span class="number">-140</span>, <span class="number">200</span>, <span class="number">280</span>);</span><br><span class="line">[logoImage2 drawInRect:logoBounds];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复绘图状态</span></span><br><span class="line"><span class="built_in">CGContextRestoreGState</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>());</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//设置渐变</span></span><br><span class="line">   <span class="built_in">CGContextSaveGState</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>());</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">CGFloat</span> locations [<span class="number">2</span>] =&#123;<span class="number">0.0</span>,<span class="number">1.0</span>&#125;;</span><br><span class="line">   <span class="built_in">CGFloat</span> components[<span class="number">8</span>] =&#123;<span class="number">1.0</span>,<span class="number">0.5</span>,<span class="number">0.0</span>,<span class="number">1.0</span>,    <span class="comment">//起始颜色为红色</span></span><br><span class="line">       <span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>&#125;;   <span class="comment">//终止颜色为黄色</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//色彩范围容器</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> colorspace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//渐变属性：颜色空间、颜色、位置、有效数量</span></span><br><span class="line">   <span class="comment">//CGGradientCreateWithColorComponents:创建包含渐变的CGGradientRef对象</span></span><br><span class="line">   <span class="built_in">CGGradientRef</span> gradient = <span class="built_in">CGGradientCreateWithColorComponents</span>(colorspace, components, locations, <span class="number">2</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">CGPoint</span> startPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">   <span class="built_in">CGPoint</span> endPoint = <span class="built_in">CGPointMake</span>(bounds.size.width,bounds.size.height);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//绘制线性渐变</span></span><br><span class="line">   <span class="built_in">CGContextDrawLinearGradient</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(), gradient, startPoint, endPoint, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">CGGradientRelease</span>(gradient);</span><br><span class="line">   <span class="built_in">CGColorSpaceRelease</span>(colorspace);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//恢复Graphical Context图形上下文</span></span><br><span class="line">   <span class="built_in">CGContextRestoreGState</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>());</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置表头视图背景渐变</span></span><br><span class="line">- (<span class="keyword">void</span>)setTableHeaderViewBackgroundGradient &#123;</span><br><span class="line">    <span class="comment">// 创建 CAGradientLayer 对象</span></span><br><span class="line">    <span class="built_in">CAGradientLayer</span> *gradient = [<span class="built_in">CAGradientLayer</span> layer];</span><br><span class="line">    <span class="comment">// 设置 CAGradientLayer 对象的 frame</span></span><br><span class="line">    gradient.frame = <span class="keyword">self</span>.tableHeaderView.frame;</span><br><span class="line">    <span class="comment">// 创建渐变色数组，需要转换为 CGColor 颜色</span></span><br><span class="line">    gradient.colors = @[ (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> colorWithRed:<span class="number">62</span> /<span class="number">255.0</span>f</span><br><span class="line">                                             green:<span class="number">145</span>/<span class="number">255.0</span>f</span><br><span class="line">                                              blue:<span class="number">255</span>/<span class="number">255.0</span>f</span><br><span class="line">                                             alpha:<span class="number">1.0</span>].CGColor,</span><br><span class="line">                         (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> colorWithRed:<span class="number">73</span> /<span class="number">255.0</span></span><br><span class="line">                                             green:<span class="number">196</span>/<span class="number">255.0</span></span><br><span class="line">                                              blue:<span class="number">255</span>/<span class="number">255.0</span></span><br><span class="line">                                             alpha:<span class="number">1</span>].CGColor];</span><br><span class="line">    <span class="comment">// 设置三种颜色变化点，取值范围 0.0~1.0</span></span><br><span class="line">    gradient.locations = @[@(<span class="number">0.1</span>f),@(<span class="number">1.0</span>f)];</span><br><span class="line">    <span class="comment">// 设置渐变颜色方向</span></span><br><span class="line">    gradient.startPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    gradient.endPoint = <span class="built_in">CGPointMake</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 添加渐变到 UIView 上</span></span><br><span class="line">    [<span class="keyword">self</span>.tableHeaderView.layer insertSublayer:gradient atIndex:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在-UIView-子类对象上画一条线"><a href="#在-UIView-子类对象上画一条线" class="headerlink" title="在 UIView 子类对象上画一条线"></a>在 UIView 子类对象上画一条线</h3><p>覆盖子类 <code>drawRect:</code>方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在用户名和密码之间添加线</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    <span class="comment">// 获得当前画板</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">// 设置线宽</span></span><br><span class="line">    <span class="built_in">CGContextSetLineWidth</span>(context, <span class="number">0.2</span>);</span><br><span class="line">    <span class="comment">// 标记</span></span><br><span class="line">    <span class="built_in">CGContextBeginPath</span>(context);</span><br><span class="line">    <span class="comment">// 路径起点</span></span><br><span class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, <span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 路径终点</span></span><br><span class="line">    <span class="built_in">CGContextAddLineToPoint</span>(context, <span class="keyword">self</span>.frame.size.width - <span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 路径结束标志</span></span><br><span class="line">    <span class="built_in">CGContextClosePath</span>(context);</span><br><span class="line">    <span class="comment">// 设置画线颜色</span></span><br><span class="line">    [[<span class="built_in">UIColor</span> grayColor] setStroke];</span><br><span class="line">    <span class="comment">// 绘制路径</span></span><br><span class="line">    <span class="built_in">CGContextStrokePath</span>(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h3><blockquote>
<p>摘自：<a href="http://bihongbo.com/2016/01/03/memoryGhostdrawRect/" target="_blank" rel="noopener">内存恶鬼drawRect</a> </p>
</blockquote>
<p><strong>CAShapeLayer</strong> 是一个通过<strong>矢量图形</strong>而不是 <code>bitmap</code> 来绘制的图层子类。用 <code>CGPath</code> 来定义想要绘制的图形，<strong>CAShapeLayer</strong> 会自动渲染。它可以完美替代我们的直接使用 <strong>Core Graphics</strong> 绘制 <code>layer</code>，对比之下使用<strong>CAShapeLayer</strong> 有以下优点：</p>
<ul>
<li>渲染快速。<strong>CAShapeLayer</strong> 使用了硬件加速，绘制同一图形会比用 Core Graphics 快很多。</li>
<li>高效使用内存。一个 <strong>CAShapeLayer</strong> 不需要像普通 CALayer 一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</li>
<li>不会被图层边界剪裁掉。</li>
<li>不会出现像素化。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CAShapeLayer *brownRectLayer = [CAShapeLayer layer];</span><br><span class="line">brownRectLayer.frame = CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height);</span><br><span class="line">UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)];</span><br><span class="line">brownRectLayer.path = path.CGPath;</span><br><span class="line">brownRectLayer.fillColor = [UIColor brownColor].CGColor;</span><br><span class="line">[self.view.layer addSublayer:brownRectLayer];</span><br><span class="line"></span><br><span class="line">CAShapeLayer *whiteRectLayer = [CAShapeLayer layer];</span><br><span class="line">whiteRectLayer.frame = CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height);</span><br><span class="line">UIBezierPath *path1 = [UIBezierPath bezierPathWithRect:CGRectMake(self.view.frame.size.width / 2 - 25, self.view.frame.size.height / 2 - 25, 50, 50)];</span><br><span class="line">whiteRectLayer.path = path1.CGPath;</span><br><span class="line">whiteRectLayer.fillColor = [UIColor whiteColor].CGColor;</span><br><span class="line">[self.view.layer addSublayer:whiteRectLayer];</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-8c1cf2356ae2e4e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://blog.csdn.net/rhljiayou/article/details/9919713" target="_blank" rel="noopener">IOS用CGContextRef画各种图形</a></li>
<li><a href="http://www.jianshu.com/p/8c2bda98ad6e" target="_blank" rel="noopener">Core Graphics-绘图使用介绍</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/18/iOS 编程：UILabel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/18/iOS 编程：UILabel/" class="post-title-link" itemprop="url">iOS 编程：UILabel</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-18 17:59:00" itemprop="dateCreated datePublished" datetime="2016-08-18T17:59:00+08:00">2016-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-18 00:30:07" itemprop="dateModified" datetime="2019-04-18T00:30:07+08:00">2019-04-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/18/iOS 编程：UILabel/" class="leancloud_visitors" data-flag-title="iOS 编程：UILabel">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p><strong>UILabel</strong> 显示一行或多行只读文本的视图，通常与其他控件一起使用以描述其预期目的。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Core-attributes-核心属性"><a href="#Core-attributes-核心属性" class="headerlink" title="Core attributes 核心属性"></a>Core attributes 核心属性</h3><p>Text（ <code>text</code>、<code>attributedText</code> ）、<code>textColor</code>、<code>font</code>、<code>textAligment</code>、Lines（ <code>numberOfLines</code> ）、Behavior（  <code>enabled</code>、<code>highlighted</code> ）。</p>
<ul>
<li><p><code>font</code> ：默认字体为：system font 17 plain</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 通常的几种设置方法</span><br><span class="line">label.font = [UIFont systemFontOfSize:20];</span><br><span class="line">label.font = [UIFont boldSystemFontOfSize:20];</span><br><span class="line">label.font = [UIFont italicSystemFontOfSize:20];</span><br><span class="line">label.font = [UIFont fontWithName:@&quot;Arial&quot; size:20]; // PS：字体名可以打开「字体册」应用查找</span><br><span class="line">label.font = [UIFont systemFontOfSize:20 weight:UIFontWeightUltraLight];</span><br></pre></td></tr></table></figure>
<p>系统字体参考：<a href="https://blog.csdn.net/u013943420/article/details/82776026" target="_blank" rel="noopener">iOS 查看系统所有字体 (带效果图)</a></p>
<p>以下为字体大小为20 号时的显示情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-3f8468cceb702616.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
</li>
</ul>
<ul>
<li><p><code>textAligment</code> ：文本对齐方式，默认设置为 <code>NSTextAlignmentNatural</code>，实际测试默认为左对齐，即<code>NSTextAlignmentLeft</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    /* Values for NSTextAlignment */</span><br><span class="line">    typedef NS_ENUM(NSInteger, NSTextAlignment) &#123;</span><br><span class="line">        NSTextAlignmentLeft      = 0,    // 左对齐</span><br><span class="line">#if TARGET_OS_iPhone</span><br><span class="line">        NSTextAlignmentCenter    = 1,    // 居中</span><br><span class="line">        NSTextAlignmentRight     = 2,    // 右对齐</span><br><span class="line">#else /* !TARGET_OS_iPhone */</span><br><span class="line">        NSTextAlignmentRight     = 1,    // 右对齐</span><br><span class="line">        NSTextAlignmentCenter    = 2,    // 居中</span><br><span class="line">#endif</span><br><span class="line">        NSTextAlignmentJustified = 3,    // Fully-justified. The last line in a paragraph is natural-aligned.</span><br><span class="line">        NSTextAlignmentNatural   = 4,    // Indicates the default alignment for script</span><br><span class="line">    &#125; NS_ENUM_AVAILABLE_IOS(6_0);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>numberOfLines</code>：默认为1行。如果设置为 0，则代表不限制行数。</p>
</li>
<li><p><code>enabled</code> ：此属性仅确定标签的绘制方式。 禁用时文字有些暗淡，表示它处于非活动状态。 此属性默认设置为YES。</p>
<p> 如图所示：上方为 <code>enabled = NO</code>,下方为  <code>enabled = YES</code>。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/2648731-591635bd3ba14397.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
</li>
</ul>
<ul>
<li><p><code>highlighted</code>: 高亮属性，该属性用于当 UILabel 作为其他控件的子视图时，作为按下状态时的属性。</p>
<blockquote>
<p>the ‘highlight’ property is used by subclasses for such things as pressed states. it’s useful to make it part of the base class as a user property.</p>
</blockquote>
</li>
<li><p><code>userInteractionEnabled</code>: 是否能与用户交互？</p>
</li>
</ul>
<h3 id="Spacing-attributes-间距属性"><a href="#Spacing-attributes-间距属性" class="headerlink" title="Spacing attributes 间距属性"></a>Spacing attributes 间距属性</h3><p>Baseline ( <code>baselineAdjustment</code> )、LineBreaks （ <code>lineBreakMode</code>）、Autoshrink （ <code>minimumScaleFactor</code>、<code>allowsDefaultTighteningForTruncation</code> ）</p>
<ul>
<li><p><code>baselineAdjustment</code>  ：文本基线对齐方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 控制文本的基线位置，只有文本的行数为1时有效</span><br><span class="line">// adjustsFontSizeToFitWidth = YES 并且文本需要缩小时才会起作用。</span><br><span class="line">typedef NS_ENUM(NSInteger, UIBaselineAdjustment) &#123;</span><br><span class="line">    UIBaselineAdjustmentAlignBaselines = 0, // default. used when shrinking text to position based on the original baseline     </span><br><span class="line">    UIBaselineAdjustmentAlignCenters,       // 文本中线与label中线对齐</span><br><span class="line">    UIBaselineAdjustmentNone,               // 文本最低端与label中线对齐</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​      从左至右分别为：0、1、2 三种情况：</p>
<p>​      <img src="http://upload-images.jianshu.io/upload_images/2648731-8080621c80879a87.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li><p><code>lineBreakMode</code>：超出 label 边界的文字截取方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, NSLineBreakMode) &#123;</span><br><span class="line">    NSLineBreakByWordWrapping = 0,  // 默认，以单词为边界 &quot;my word&quot;</span><br><span class="line">    NSLineBreakByCharWrapping,		// 以字符为边界 &quot;my wor&quot;</span><br><span class="line">    NSLineBreakByClipping,		    // 到边界为止，碰到边界就剪辑</span><br><span class="line">    NSLineBreakByTruncatingHead,	// 省略开头: &quot;...wxyz&quot;</span><br><span class="line">    NSLineBreakByTruncatingTail,	// 省略结尾: &quot;abcd...&quot;</span><br><span class="line">    NSLineBreakByTruncatingMiddle	// 省略中间:  &quot;ab...yz&quot;,多行时作用于最后一行</span><br><span class="line">&#125; NS_ENUM_AVAILABLE(10_0, 6_0);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Advanced-appearance-attributes-高级外观属性"><a href="#Advanced-appearance-attributes-高级外观属性" class="headerlink" title="Advanced appearance attributes 高级外观属性"></a>Advanced appearance attributes 高级外观属性</h3><p><code>highlightedTextColor</code>、<code>shadowColor</code>、<code>shadowOffset</code></p>
<h2 id="使用-UILabel"><a href="#使用-UILabel" class="headerlink" title="使用 UILabel"></a>使用 UILabel</h2><h3 id="通常的使用方式"><a href="#通常的使用方式" class="headerlink" title="通常的使用方式"></a>通常的使用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建 UILabel 对象</span><br><span class="line">UILabel *label = [[UILabel alloc] init];</span><br><span class="line">label.frame = CGRectMake(15, 100, 125, 24);</span><br><span class="line">label.tag = 5;</span><br><span class="line">label.text = @&quot;Hello World！&quot;;</span><br><span class="line">label.font = [UIFont systemFontOfSize:20];</span><br><span class="line">label.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">label.textColor = [UIColor blueColor];</span><br><span class="line">label.backgroundColor = [UIColor lightGrayColor];</span><br><span class="line">label.lineBreakMode = NSLineBreakByTruncatingTail;</span><br><span class="line">label.numberOfLines = 0;</span><br><span class="line">[self.view addSubview:label];</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-417f7e1b641cd040.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h3 id="设置自动缩小文本字体以适应-label-宽度"><a href="#设置自动缩小文本字体以适应-label-宽度" class="headerlink" title="设置自动缩小文本字体以适应 label 宽度"></a>设置自动缩小文本字体以适应 label 宽度</h3><ul>
<li><code>adjustsFontSizeToFitWidth</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">UILabel *label2 = [[UILabel alloc] initWithFrame:CGRectMake(15, 150, 80, 35)];</span><br><span class="line">label2.text = @&quot;Hello World！&quot;;</span><br><span class="line">label2.font = [UIFont systemFontOfSize:20];</span><br><span class="line">label2.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">label2.backgroundColor = [UIColor flatWhiteColor];</span><br><span class="line"></span><br><span class="line">// 当 Label 的宽度小于完整字符串宽度时，缩小文本字体以适应宽度</span><br><span class="line">label2.adjustsFontSizeToFitWidth = YES;</span><br><span class="line"></span><br><span class="line">// 当 adjustsFontSizeToFitWidth = YES 时，如果文本 font 要缩小时,</span><br><span class="line">// 可以设置 baselineAdjustment来控制文本的基线位置，只有文本行数为1时有效。</span><br><span class="line">label2.baselineAdjustment = UIBaselineAdjustmentAlignCenters;</span><br><span class="line">label2.numberOfLines = 1; // 默认为1，可以省略</span><br><span class="line"></span><br><span class="line">// 字体最小比例因子</span><br><span class="line">// 当文本字体缩小时，缩放比例 &gt;= minimumScaleFactor</span><br><span class="line">label2.minimumScaleFactor = 0.5;</span><br><span class="line"></span><br><span class="line">[self.view addSubview:label2];</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-21fbbd3f02cd87bd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h3 id="如何根据字符串长度设置-label-的frame-？"><a href="#如何根据字符串长度设置-label-的frame-？" class="headerlink" title="如何根据字符串长度设置 label 的frame ？"></a>如何根据字符串长度设置 label 的<code>frame</code> ？</h3><p>根据字符串长度计算出 <code>CGSize</code>，然后赋值给 label 的<code>frame</code>：</p>
<p>计算字符串长度有2个可用的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (CGSize)sizeWithAttributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attrs NS_AVAILABLE(10_0, 7_0);</span><br><span class="line"></span><br><span class="line">- (CGRect)boundingRectWithSize:(CGSize)size options:(NSStringDrawingOptions)options attributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attributes context:(nullable NSStringDrawingContext *)context NS_AVAILABLE(10_11, 7_0);</span><br></pre></td></tr></table></figure>
<h4 id="方法一示例代码："><a href="#方法一示例代码：" class="headerlink" title="方法一示例代码："></a>方法一示例代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 需要显示的字符串</span><br><span class="line">NSString *string = @&quot;Hello World！&quot;;</span><br><span class="line">// 字符串在  UILabel 上显示时所使用的字体</span><br><span class="line">UIFont *font = [UIFont systemFontOfSize:20];</span><br><span class="line">// 计算20号字体下，该字符串的宽度和高度</span><br><span class="line">CGSize stringSize = [string sizeWithAttributes:@&#123;NSFontAttributeName:font&#125;];</span><br><span class="line">NSLog(@&quot;(%f,%f)&quot;,stringSize.width,stringSize.height); // (123.651484,23.867188)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>⚠️ </p>
<p>需要注意的是，该方法返回的 <code>CGSize</code> 是行数为1的情况下，计算出来的 Size。当它超过屏幕的宽度（<code>[UIScreen mainScreen].bounds.size.width</code>）时，还会存在文本显示不完全的问题。</p>
<p>因此，该方法仅适用于短文本，还有一种情况是做跑马灯效果时会用到这种方法。</p>
</blockquote>
<h4 id="方法二示例代码1："><a href="#方法二示例代码1：" class="headerlink" title="方法二示例代码1："></a>方法二示例代码1：</h4><p>相对于上者，此方法需要传入一个 <code>CGSize</code> 参数来限制最大宽高尺寸，可以处理多行文本情况。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)resizeUILabelWidth:(UILabel *)label &#123;</span><br><span class="line">    label.lineBreakMode = NSLineBreakByTruncatingTail;</span><br><span class="line"></span><br><span class="line">    CGRect <span class="built_in">rect</span> = label.frame;</span><br><span class="line">    NSString *<span class="built_in">str</span> = label.<span class="built_in">text</span>;</span><br><span class="line">    UIFont *font = label.font;</span><br><span class="line">    CGSize <span class="built_in">size</span> = CGSizeMake(<span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">width</span>, <span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">height</span>);</span><br><span class="line">    NSDictionary *attributes = @&#123;NSFontAttributeName:font&#125;;</span><br><span class="line">    <span class="comment">// 计算大小</span></span><br><span class="line">    CGRect labelSize = [<span class="built_in">str</span> boundingRectWithSize:<span class="built_in">size</span></span><br><span class="line">                                         options:NSStringDrawingUsesLineFragmentOrigin</span><br><span class="line">                                      attributes:attributes</span><br><span class="line">                                         context:nil];</span><br><span class="line">    <span class="comment">// 调整frame</span></span><br><span class="line">    <span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">width</span> = labelSize.<span class="built_in">size</span>.<span class="built_in">width</span>;</span><br><span class="line">    <span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">height</span> = labelSize.<span class="built_in">size</span>.<span class="built_in">height</span>;</span><br><span class="line">    label.frame = <span class="built_in">rect</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二示例代码2："><a href="#方法二示例代码2：" class="headerlink" title="方法二示例代码2："></a>方法二示例代码2：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGSize</span>)sizeForFont:(<span class="built_in">UIFont</span> *)font size:(<span class="built_in">CGSize</span>)size mode:(<span class="built_in">NSLineBreakMode</span>)lineBreakMode &#123;</span><br><span class="line">    <span class="built_in">CGSize</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!font) font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(boundingRectWithSize:options:attributes:context:)]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *attr = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        attr[<span class="built_in">NSFontAttributeName</span>] = font;</span><br><span class="line">        <span class="keyword">if</span> (lineBreakMode != <span class="built_in">NSLineBreakByWordWrapping</span>) &#123;</span><br><span class="line">            <span class="built_in">NSMutableParagraphStyle</span> *paragraphStyle = [<span class="built_in">NSMutableParagraphStyle</span> new];</span><br><span class="line">            paragraphStyle.lineBreakMode = lineBreakMode;</span><br><span class="line">            attr[<span class="built_in">NSParagraphStyleAttributeName</span>] = paragraphStyle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CGRect</span> rect = [<span class="keyword">self</span> boundingRectWithSize:size</span><br><span class="line">                                         options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> | <span class="built_in">NSStringDrawingUsesFontLeading</span></span><br><span class="line">                                      attributes:attr context:<span class="literal">nil</span>];</span><br><span class="line">        result = rect.size;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></span><br><span class="line">        result = [<span class="keyword">self</span> sizeWithFont:font constrainedToSize:size lineBreakMode:lineBreakMode];</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述方法摘自 <a href="https://github.com/ibireme/YYKit" target="_blank" rel="noopener">YYKit</a> :NSString+YYAdd<br>该类中有三个计算字符串大小的方法：</p>
<ul>
<li>-(CGSize)sizeForFont:(UIFont *)font size:(CGSize)size mode:(NSLineBreakMode)lineBreakMode;</li>
<li>-(CGFloat)widthForFont:(UIFont *)font;</li>
<li>-(CGFloat)heightForFont:(UIFont *)font width:(CGFloat)width;</li>
</ul>
</blockquote>
<h3 id="根据文本内容调整UILabel对象的大小"><a href="#根据文本内容调整UILabel对象的大小" class="headerlink" title="根据文本内容调整UILabel对象的大小"></a>根据文本内容调整UILabel对象的大小</h3><p><strong>UIView</strong> 中的两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (CGSize)sizeThatFits:(CGSize)size;     </span><br><span class="line">// return &apos;best&apos; size to fit given size. does not actually resize view. Default is return existing view size</span><br><span class="line">// 返回“最佳”大小以适应给定的大小,默认返回已经存在的视图 size</span><br><span class="line"></span><br><span class="line">- (void)sizeToFit;                       </span><br><span class="line">// calls sizeThatFits: with current view bounds and changes bounds size.</span><br><span class="line">// 调用这个方法会改变当前 view 的 bounds.size</span><br></pre></td></tr></table></figure>
<h4 id="sizeToFit-代码示例一："><a href="#sizeToFit-代码示例一：" class="headerlink" title="sizeToFit 代码示例一："></a><code>sizeToFit</code> 代码示例一：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 代码示例三：label 大小自适应文本</span><br><span class="line">UILabel *label3 = [[UILabel alloc] init];</span><br><span class="line">label3.frame = CGRectMake(15, 150, 125, 24);</span><br><span class="line">label3.text = @&quot;Hello iOS! Hello World！&quot;;</span><br><span class="line">label3.font = [UIFont systemFontOfSize:20];</span><br><span class="line">label3.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">label3.textColor = [UIColor blueColor];</span><br><span class="line">label3.backgroundColor = [UIColor flatWhiteColor];</span><br><span class="line">label3.lineBreakMode = NSLineBreakByTruncatingTail;</span><br><span class="line"></span><br><span class="line">// 设置 sizeToFit</span><br><span class="line">[label3 sizeToFit];</span><br><span class="line">label3.numberOfLines = 0;</span><br><span class="line">[self.view addSubview:label3];</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-25f1387c1b76ed74.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h4 id="sizeToFit-代码示例二："><a href="#sizeToFit-代码示例二：" class="headerlink" title="sizeToFit 代码示例二："></a><code>sizeToFit</code> 代码示例二：</h4><p>当文本非常长的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">UILabel *label3 = [[UILabel alloc] init];</span><br><span class="line">label3.frame = CGRectMake(15, 150, 125, 24);</span><br><span class="line">label3.text = @&quot;透过覆盖着我的夜幕  黑暗层层无底 感谢万能的上苍 赐给我不可征服的灵魂 就算被地狱牢牢抓住 我不会畏縮 也不会哭叫 任凭命运百般作弄 我头破血流但不低头 在这充满愤怒和眼泪的土地之上 恐怖阴影阴森的逼近 不过,即使岁月不停恐吓 亦将发现我毫不畏惧 无论大门何等狭窄 无论承受多么深重的责罚 我是我命运的主宰 我是我灵魂的统帅&quot;;</span><br><span class="line">label3.font = [UIFont systemFontOfSize:20];</span><br><span class="line">label3.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">label3.textColor = [UIColor blueColor];</span><br><span class="line">label3.backgroundColor = [UIColor flatWhiteColor];</span><br><span class="line">label3.lineBreakMode = NSLineBreakByTruncatingTail;</span><br><span class="line"></span><br><span class="line">[label3 sizeToFit];</span><br><span class="line">label3.numberOfLines = 0;</span><br><span class="line">[self.view addSubview:label3];</span><br></pre></td></tr></table></figure>
<p>测试发现，当文本太长显示不完全时，<code>sizeToFit</code> 并不会自动换行。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-fbfd4769dcada102.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<hr>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h4 id="sizeThatFits-代码示例一："><a href="#sizeThatFits-代码示例一：" class="headerlink" title="sizeThatFits: 代码示例一："></a><code>sizeThatFits:</code> 代码示例一：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UILabel *label3 = [[UILabel alloc] init];</span><br><span class="line">label3.frame = CGRectMake(15, 150, 125, 24);</span><br><span class="line">label3.text = @&quot;透过覆盖着我的夜幕  黑暗层层无底 感谢万能的上苍 赐给我不可征服的灵魂 就算被地狱牢牢抓住 我不会畏縮 也不会哭叫 任凭命运百般作弄 我头破血流但不低头 在这充满愤怒和眼泪的土地之上 恐怖阴影阴森的逼近 不过,即使岁月不停恐吓 亦将发现我毫不畏惧 无论大门何等狭窄 无论承受多么深重的责罚 我是我命运的主宰 我是我灵魂的统帅&quot;;</span><br><span class="line">label3.font = [UIFont systemFontOfSize:20];</span><br><span class="line">label3.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">label3.textColor = [UIColor blueColor];</span><br><span class="line">label3.backgroundColor = [UIColor flatWhiteColor];</span><br><span class="line">label3.lineBreakMode = NSLineBreakByTruncatingTail;</span><br><span class="line">label3.numberOfLines = 0;</span><br><span class="line"></span><br><span class="line">// 限定 label 的宽度和高度，让 label 在此范围内自适应</span><br><span class="line">CGSize size = [label3 sizeThatFits:CGSizeMake([UIScreen mainScreen].bounds.size.width - 15*2, MAXFLOAT)];</span><br><span class="line">label3.frame = CGRectMake(15, 150, size.width, size.height);</span><br><span class="line"></span><br><span class="line">[self.view addSubview:label3];</span><br></pre></td></tr></table></figure>
<p>🎉🎉🎉  你看，它做到了，真棒！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-0bc50fa9fd5d6c9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h4 id="sizeThatFits-代码示例二："><a href="#sizeThatFits-代码示例二：" class="headerlink" title="sizeThatFits: 代码示例二："></a><code>sizeThatFits:</code> 代码示例二：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 初始化标签对象</span><br><span class="line">UILabel *label = [[UILabel alloc] init];</span><br><span class="line">// 给标签对象设置一段较长的文本内容</span><br><span class="line">label.text = @&quot;The appearance of labels is configurable, and they can display attributed strings, allowing you to customize the appearance of substrings within a label. You can add labels to your interface programmatically or by using Interface Builder.&quot;;</span><br><span class="line">// 设置标签文字的颜色</span><br><span class="line">label.textColor = [UIColor flatSkyBlueColor];</span><br><span class="line">// 设置标签文字的对齐方式</span><br><span class="line">label.textAlignment = NSTextAlignmentLeft;</span><br><span class="line">// 设置标签文字的换行方式为以空格为界，保留整个单词</span><br><span class="line">label.lineBreakMode = NSLineBreakByWordWrapping;</span><br><span class="line">// 设置标签不限制行数</span><br><span class="line">label.numberOfLines = 0;</span><br><span class="line">// 设置标签的背景颜色</span><br><span class="line">label.backgroundColor = [UIColor lightGrayColor];</span><br><span class="line">// 限定 label 的宽度和高度，让 label 在此范围内自适应</span><br><span class="line">CGSize size = [label sizeThatFits:CGSizeMake([UIScreen mainScreen].bounds.size.width - 15*2, MAXFLOAT)];</span><br><span class="line">label.frame = CGRectMake(15, 150, size.width, size.height);</span><br><span class="line">// 将标签对象，添加到当前视图控制器的根视图</span><br><span class="line">[self.view addSubview:label];</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-15ec805152d3e6a8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<hr>
<h3 id="实例模仿："><a href="#实例模仿：" class="headerlink" title="实例模仿："></a>实例模仿：</h3><p>参考淘票票的 TableViewCell：</p>
<ul>
<li>样式一：影城卡、卡、惠；</li>
<li>样式二：小食、巨幕厅；</li>
<li>样式三：25.8 元起</li>
<li>样式四：3DIMAX tag</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-22f288b22f9e2e9e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h3 id="设置圆角"><a href="#设置圆角" class="headerlink" title="设置圆角"></a>设置圆角</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UILabel *label = [[UILabel alloc] init];</span><br><span class="line">label.frame = CGRectMake(15, 100, 55, 25);</span><br><span class="line">label.text = @&quot;影城卡&quot;;</span><br><span class="line">label.font = [UIFont boldSystemFontOfSize:15];</span><br><span class="line">label.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">label.textColor = [UIColor whiteColor];</span><br><span class="line">label.backgroundColor = HexColor(@&quot;#62C067&quot;);</span><br><span class="line"></span><br><span class="line">// 设置圆角（老方法）</span><br><span class="line">label.layer.cornerRadius = 3;</span><br><span class="line">label.layer.masksToBounds = YES;</span><br><span class="line"></span><br><span class="line">[self.view addSubview:label];</span><br></pre></td></tr></table></figure>
<p>201712更新：优化设置(参考<a href="http://www.cocoachina.com/ios/20171204/21407.html" target="_blank" rel="noopener">iOS 常用组件-高效切圆角方法总结</a>)：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UILabel *<span class="keyword">label</span><span class="bash"> = [[UILabel alloc] init];</span></span><br><span class="line"><span class="keyword">label</span>.<span class="bash">frame = CGRectMake(15, 100, 55, 25);</span></span><br><span class="line"><span class="keyword">label</span>.<span class="bash">text = @<span class="string">"影城卡"</span>;</span></span><br><span class="line"><span class="keyword">label</span>.<span class="bash">font = [UIFont boldSystemFontOfSize:15];</span></span><br><span class="line"><span class="keyword">label</span>.<span class="bash">textAlignment = NSTextAlignmentCenter;</span></span><br><span class="line"><span class="keyword">label</span>.<span class="bash">textColor = [UIColor whiteColor];</span></span><br><span class="line"></span><br><span class="line">// 💡💡💡优化设置圆角（推荐方法）💡💡💡</span><br><span class="line">// 设置 layer 的背景颜色,这样就可以避免离屏渲染问题</span><br><span class="line"><span class="keyword">label</span>.<span class="bash">layer.backgroundColor = UIColorHex(62C067).CGColor; </span></span><br><span class="line"><span class="keyword">label</span>.<span class="bash">layer.cornerRadius = 3;</span></span><br><span class="line"></span><br><span class="line">[self.view addSubview:<span class="keyword">label</span><span class="bash">];</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-b1b3782f400ed7da.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<hr>
<h3 id="设置圆角和边框"><a href="#设置圆角和边框" class="headerlink" title="设置圆角和边框"></a>设置圆角和边框</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建 UILabel 对象</span><br><span class="line">UILabel *label = [[UILabel alloc] init];</span><br><span class="line">label.frame = CGRectMake(15, 100, 54, 25);</span><br><span class="line">label.text = @&quot;小食&quot;;</span><br><span class="line">label.font = [UIFont systemFontOfSize:15];</span><br><span class="line">label.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">label.textColor = [UIColor flatSkyBlueColor];</span><br><span class="line">// 设置圆角</span><br><span class="line">label.layer.cornerRadius = 12;</span><br><span class="line">label.layer.masksToBounds = YES;</span><br><span class="line">// 设置边框</span><br><span class="line">label.layer.borderWidth = 1.0;</span><br><span class="line">label.layer.borderColor = [UIColor flatSkyBlueColor].CGColor;</span><br><span class="line">[self.view addSubview:label];</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-b32be9eaf2bdd7bc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<hr>
<h3 id="设置-attributedText"><a href="#设置-attributedText" class="headerlink" title="设置 attributedText"></a>设置 <code>attributedText</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 创建 UILabel 对象</span><br><span class="line">UILabel *label = [[UILabel alloc] init];</span><br><span class="line"></span><br><span class="line">// 设置 attributedText</span><br><span class="line">NSString *string = @&quot;25.8元起&quot;;</span><br><span class="line">NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:string];</span><br><span class="line">UIFont *font = [UIFont systemFontOfSize:15];</span><br><span class="line">NSDictionary *attributes1 = @&#123;</span><br><span class="line">                             NSForegroundColorAttributeName:HexColor(@&quot;#FF4359&quot;),</span><br><span class="line">                             NSFontAttributeName:font</span><br><span class="line">                             &#125;;</span><br><span class="line">[attributedString setAttributes:attributes1 range:NSMakeRange(0, 4)];</span><br><span class="line"></span><br><span class="line">NSDictionary *attributes2 = @&#123;</span><br><span class="line">                              NSForegroundColorAttributeName:HexColor(@&quot;#7E7B93&quot;),</span><br><span class="line">                              NSFontAttributeName:font</span><br><span class="line">                              &#125;;</span><br><span class="line">[attributedString setAttributes:attributes2 range:NSMakeRange(4, 2)];</span><br><span class="line">label.attributedText = attributedString;</span><br><span class="line"></span><br><span class="line">// 限定 label 的宽度和高度，让 label 在此范围内自适应</span><br><span class="line">CGSize size = [label sizeThatFits:CGSizeMake([UIScreen mainScreen].bounds.size.width - 15*2, MAXFLOAT)];</span><br><span class="line">label.frame = CGRectMake(15, 150, size.width, size.height);</span><br><span class="line"></span><br><span class="line">[self.view addSubview:label];</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-bb87fd515de5a85a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<hr>
<h3 id="设置标题-Tag"><a href="#设置标题-Tag" class="headerlink" title="设置标题 Tag"></a>设置标题 Tag</h3><p><img src="http://upload-images.jianshu.io/upload_images/2648731-32bc1a8021691468.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)<span class="keyword">add3DIMAXTag </span>&#123;</span><br><span class="line"></span><br><span class="line">    UIView *tag = [[UIView alloc] initWithFrame:CGRectMake((MaxX(self.titleLabel)+<span class="number">6</span>), MinY(self.titleLabel)+<span class="number">2</span>, <span class="number">45</span>, <span class="number">13</span>)]<span class="comment">;</span></span><br><span class="line">    tag.<span class="keyword">backgroundColor </span>= COLOR_RGB(<span class="number">185</span>, <span class="number">183</span>, <span class="number">197</span>)<span class="comment">;</span></span><br><span class="line">    tag.layer.<span class="keyword">borderWidth </span>= <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    tag.layer.<span class="keyword">borderColor </span>= COLOR_RGB(<span class="number">185</span>, <span class="number">183</span>, <span class="number">197</span>).CGColor<span class="comment">;</span></span><br><span class="line">    tag.layer.cornerRadius = <span class="number">2</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    UILabel *leftPart = [[UILabel alloc] initWithFrame:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">13</span>)]<span class="comment">;</span></span><br><span class="line">    leftPart.layer.<span class="keyword">borderWidth </span>= <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    leftPart.layer.<span class="keyword">borderColor </span>= COLOR_RGB(<span class="number">185</span>, <span class="number">183</span>, <span class="number">197</span>).CGColor<span class="comment">;</span></span><br><span class="line">    leftPart.layer.cornerRadius = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    leftPart.<span class="keyword">backgroundColor </span>= [UIColor clearColor]<span class="comment">;</span></span><br><span class="line">    leftPart<span class="meta">.text</span> = @<span class="string">"3D"</span><span class="comment">;</span></span><br><span class="line">    leftPart.textAlignment = NSTextAlignmentCenter<span class="comment">;</span></span><br><span class="line">    leftPart.textColor = [UIColor whiteColor]<span class="comment">;</span></span><br><span class="line">    leftPart.font = [UIFont systemFontOfSize:<span class="number">6</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    UILabel *rightPart = [[UILabel alloc] initWithFrame:CGRectMake(<span class="number">17</span>, <span class="number">0</span>, <span class="number">28</span>, <span class="number">13</span>)]<span class="comment">;</span></span><br><span class="line">    rightPart.<span class="keyword">backgroundColor </span>= [UIColor whiteColor]<span class="comment">;</span></span><br><span class="line">    rightPart<span class="meta">.text</span> = @<span class="string">"IMAX"</span><span class="comment">;</span></span><br><span class="line">    rightPart.textAlignment = NSTextAlignmentCenter<span class="comment">;</span></span><br><span class="line">    rightPart.textColor = COLOR_RGB(<span class="number">185</span>, <span class="number">183</span>, <span class="number">197</span>)<span class="comment">;</span></span><br><span class="line">    rightPart.font = [UIFont systemFontOfSize:<span class="number">6</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [tag <span class="keyword">addSubview:leftPart];</span></span><br><span class="line"><span class="keyword"> </span>   [tag <span class="keyword">addSubview:rightPart];</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   [self.contentView <span class="keyword">addSubview:tag];</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="设置阴影："><a href="#设置阴影：" class="headerlink" title="设置阴影："></a>设置阴影：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 设置阴影颜色</span><br><span class="line">label.shadowColor = [UIColor flatBlueColor];</span><br><span class="line"></span><br><span class="line">// 设置阴影偏移量，默认为 CGSizeMake(0, -1) ——向上偏移</span><br><span class="line">// CGSize 宽度控制这阴影横向的位移，高度控制着纵向的位移。</span><br><span class="line">label.shadowOffset = CGSizeMake(1.5, 1.5);</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-a7b47474c2a414a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h3 id="分散对齐标题文字"><a href="#分散对齐标题文字" class="headerlink" title="分散对齐标题文字"></a>分散对齐标题文字</h3><p>为 <strong>UILabel</strong> 添加一个 Category 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UILabel+ChangeRightAndLeftAlignment.h&quot;</span><br><span class="line">#import &lt;CoreText/CoreText.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation UILabel (ChangeRightAndLeftAlignment)</span><br><span class="line"></span><br><span class="line">- (void)hql_changeRightAndLeftAlignment:(CGFloat)labelWidth &#123;</span><br><span class="line">    // 计算文本占据的宽度</span><br><span class="line">    CGSize testSize = [self.text boundingRectWithSize:CGSizeMake(labelWidth, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin | NSStringDrawingTruncatesLastVisibleLine| NSStringDrawingUsesFontLeading attributes:@&#123;NSFontAttributeName :self.font&#125; context:nil].size;</span><br><span class="line">    </span><br><span class="line">    // 文本之间的距离 = （Label的宽度 - 文本宽度）/ （文字个数 - 1）</span><br><span class="line">    CGFloat margin = (labelWidth - testSize.width)/(self.text.length - 1);</span><br><span class="line">    NSNumber *number = [NSNumber numberWithFloat:margin];</span><br><span class="line">    NSMutableAttributedString *attribute = [[NSMutableAttributedString alloc] initWithString:self.text];</span><br><span class="line">    </span><br><span class="line">    // 字间距 :NSKernAttributeName</span><br><span class="line">    [attribute addAttribute: NSKernAttributeName value:number range:NSMakeRange(0, self.text.length - 1 )];</span><br><span class="line">    self.attributedText = attribute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>💡Tips: 如果标题文字末尾带冒号(：)，而你想让【最后一个字】和【冒号】之间不要有空格 那么上面的代码中 <code>self.text.length - 1</code> 这两处应修改为<code>self.text.length - 2</code> ，这样就可以排除最后一个间距了。</p>
</blockquote>
<p>效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-f91a55417a5ba990.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<hr>
<h3 id="给文字添加描边效果"><a href="#给文字添加描边效果" class="headerlink" title="给文字添加描边效果"></a>给文字添加描边效果</h3><p>UILabel 自定义文本样式，在文件夹上点击右键，弹出右键菜单，选择添加新文件选项,创建一个以UILabel为父类的子类。</p>
<p><strong>NewUILabel.h</strong> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 演示给标签文字，添加描边效果</span><br><span class="line"> </span><br><span class="line"> 在文件夹上点击右键，弹出右键菜单，选择添加新文件选项,创建一个以UILabel为父类的子类</span><br><span class="line"> */</span><br><span class="line">@interface NewUILabel : UILabel</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>NewUILabel.m</strong> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NewUILabel.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation NewUILabel</span><br><span class="line"></span><br><span class="line">// 首先重载父类的绘图方法，这样就可以从底层自定义标签</span><br><span class="line">// 如果你需要执行自定义绘图，只需要覆盖 drawRect：方法</span><br><span class="line">// 一个空的实现在动画过程中会影响性能。</span><br><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">    // 获取图形的上下文</span><br><span class="line">    CGContextRef c = UIGraphicsGetCurrentContext();</span><br><span class="line">    // 设置在上下文中，文字的渲染模式为描边模式</span><br><span class="line">    CGContextSetTextDrawingMode(c, kCGTextStroke);</span><br><span class="line">    </span><br><span class="line">    // 设置文字描边的边框宽度</span><br><span class="line">    CGContextSetLineWidth(c, 2.0);</span><br><span class="line">    // 设置文字描边顶点连接方式</span><br><span class="line">    CGContextSetLineJoin(c, kCGLineJoinRound);</span><br><span class="line">    // 设置文字的描边颜色：白色</span><br><span class="line">    self.textColor = [UIColor whiteColor];</span><br><span class="line">    // 将文字的描边，绘制在指定区域内</span><br><span class="line">    [super drawTextInRect:rect];</span><br><span class="line">    </span><br><span class="line">    // 设置上下文文字渲染模式为填充</span><br><span class="line">    CGContextSetTextDrawingMode(c, kCGTextFill);</span><br><span class="line">    // 创建一个颜色为黑色的颜色对象</span><br><span class="line">    UIColor *textColor = [UIColor blackColor];</span><br><span class="line">    // 设置文字颜色为黑色</span><br><span class="line">    self.textColor = textColor;</span><br><span class="line">    // 将文字的填充，绘制在指定区域内</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p> 调用：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化一个自定义标签对象，并指定其位置和尺寸</span><br><span class="line">CGRect labelFrame = CGRectMake(100, 100, 150, 60);</span><br><span class="line">NewUILabel *label = [[NewUILabel alloc] initWithFrame:labelFrame];</span><br><span class="line">// 设置标签对象的文本内容</span><br><span class="line">label.text = @&quot;Apple&quot;;</span><br><span class="line">// 设置文字的字体和大小</span><br><span class="line">label.font = [UIFont fontWithName:@&quot;Arial&quot; size:48];</span><br><span class="line">// 将标签对象，添加到当前视图控制器的根视图</span><br><span class="line">[self.view addSubview:label];</span><br><span class="line"></span><br><span class="line">self.view.backgroundColor = [UIColor purpleColor];;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/2648731-bd561e8c256ec619.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h3 id="添加自定义字体包"><a href="#添加自定义字体包" class="headerlink" title="添加自定义字体包"></a>添加自定义字体包</h3><p>如果系统提供的标准字体无法满足需求，也可以添加自定义字体包，步骤：</p>
<ol>
<li>拖拽所需要的 .ttf 格式文件的字体（字体查询：<a href="https://fonts.google.com）到项目中，如果你的字体包文件是" target="_blank" rel="noopener">https://fonts.google.com）到项目中，如果你的字体包文件是</a> .otf 格式的，也可以去<a href="https://www.fontsquirrel.com/tools/webfont-generator" target="_blank" rel="noopener">这个网站</a>上进行转换，先上传 .otf 格式文件，再转换为 TrueType 类型并下载：<blockquote>
<p>Tips：下载的字体可能三种后缀格式，分别为：ttc/ttf/otf：</p>
<ol>
<li>TTC 是几个 TTF 合成的字型，例如包含粗体、细体两种字型，TTF 就只有一种字型。</li>
<li>TTF 是 apple 和微软共同推出的字体文件格式，只有一种字型。</li>
<li>OTF 是 TTF 的升级版，支持更高级特性的字体。 </li>
</ol>
<p>💡据说 iOS 9 支持了 .otf 格式字体，你可以试试看。</p>
</blockquote>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-fbb25c49bd840647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ol start="2">
<li><p>配置 Info.plist 文件，添加 <strong>Fonts provided by application</strong> 数组字段，将需要的字体包文件名（***.ttf）作为value 添加到该数组中：<br><img src="http://upload-images.jianshu.io/upload_images/2648731-90e3eeb6385b4f9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
</li>
<li><p>将字体文件添加编译，设置 <strong>TARGETS -&gt; Build Phases -&gt; Copy Bundle Resources</strong> 添加 ***.ttf 字体文件：<br><img src="http://upload-images.jianshu.io/upload_images/2648731-87672ee006a62d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
</li>
</ol>
<ol start="4">
<li>使用：</li>
</ol>
<pre><code>UILabel *label = [[UILabel alloc] init];
label.text = @&quot;Stay Hungry,Stay Foolish.&quot;;
label.font = [UIFont fontWithName:@&quot;Sacramento-Regular&quot; size:32.0f];
[label sizeToFit];
label.center = self.view.center;
[self.view addSubview:label];
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2648731-f27afec30ac0ca3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ol start="5">
<li>如果以上步骤均设置无误，字体效果出不来，可能是 <code>[UIFont fontWithName:@&quot;&quot; size:];</code> 方法中的字体名设置不正确（💡因为字体名和字体包的文件名不一定相等！！！），所以你可以用以下方法遍历打印一下字体名看看：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[familyNames enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">    NSLog(@&quot;familyNames: %@&quot;,(NSString *)obj);</span><br><span class="line">    NSArray *fontNames = [UIFont fontNamesForFamilyName:(NSString *)obj];</span><br><span class="line">    [fontNames enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        NSLog(@&quot;\tfontNames: %@&quot;, (NSString *)obj);</span><br><span class="line">    &#125;];</span><br><span class="line">    NSLog(@&quot;--------------------------&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>​    </p>
<h3 id="附-不同苹方字体San-Francisco的Label尺寸"><a href="#附-不同苹方字体San-Francisco的Label尺寸" class="headerlink" title="附:不同苹方字体San Francisco的Label尺寸"></a>附:不同苹方字体San Francisco的Label尺寸</h3><p>测试字体：<code>[UIFont systemFontOfSize:font weight:UIFontWeightRegular]</code></p>
<p>测试方法：<code>sizeThatFits:</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">Font</th>
<th style="text-align:center">width</th>
<th style="text-align:center">height</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">9.5</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">10.5</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">12.5</td>
<td style="text-align:center">14.5</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">14.5</td>
<td style="text-align:center">17</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">15.5</td>
<td style="text-align:center">18</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">16.5</td>
<td style="text-align:center">19.5</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">17.5</td>
<td style="text-align:center">20.5</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">18.5</td>
<td style="text-align:center">21.5</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">19.5</td>
<td style="text-align:center">23</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">20.5</td>
<td style="text-align:center">24</td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td style="text-align:center">30.5</td>
<td style="text-align:center">36</td>
</tr>
</tbody>
</table>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="http://colachan.com/post/3463" target="_blank" rel="noopener">苹果旧金山字体的秘密 @可乐橙</a></li>
<li><a href="http://colachan.com/post/3552" target="_blank" rel="noopener">表单设计:一页只做一件事 @可乐橙</a></li>
<li><a href="http://colachan.com/post/3529" target="_blank" rel="noopener">表单设计优化 @可乐橙</a></li>
<li><a href="http://www.jianshu.com/p/4a3aad22f356" target="_blank" rel="noopener">写一个iOS复杂表单的正确姿势</a><br> <img src="http://upload-images.jianshu.io/upload_images/988593-c5a11178cace2ad4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt></li>
<li><a href="http://www.jianshu.com/p/962ab0cd9bce" target="_blank" rel="noopener">UILabel使用总结</a></li>
<li><a href="https://www.jianshu.com/p/f8a3400836b5" target="_blank" rel="noopener">iOS 常用组件-高效切圆角方法总结</a></li>
<li><a href="https://www.jianshu.com/p/b7f04f2a09d4" target="_blank" rel="noopener">iOS App 导入自定义字体</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/18/《iOS编程（第四版）》Demo6：HQLHypnoNerd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/18/《iOS编程（第四版）》Demo6：HQLHypnoNerd/" class="post-title-link" itemprop="url">《iOS编程（第四版）》Demo6：HQLHypnoNerd</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-18 17:56:00" itemprop="dateCreated datePublished" datetime="2016-08-18T17:56:00+08:00">2016-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-17 17:25:35" itemprop="dateModified" datetime="2019-04-17T17:25:35+08:00">2019-04-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/18/《iOS编程（第四版）》Demo6：HQLHypnoNerd/" class="leancloud_visitors" data-flag-title="《iOS编程（第四版）》Demo6：HQLHypnoNerd">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h1 id="HQLHypnoNerd"><a href="#HQLHypnoNerd" class="headerlink" title="HQLHypnoNerd"></a>HQLHypnoNerd</h1><p>这是参照 <strong>《iOS编程（第四版）》</strong> 第6、7章写的非常杂乱的 Demo 笔记，</p>
<ul>
<li><a href="https://github.com/Andy0570/HQLHypnoNerd" target="_blank" rel="noopener">GitHub源码</a></li>
</ul>
<h1 id="窗口、视图控制器、添加视图、访问视图"><a href="#窗口、视图控制器、添加视图、访问视图" class="headerlink" title="窗口、视图控制器、添加视图、访问视图"></a>窗口、视图控制器、添加视图、访问视图</h1><h2 id="main-与UIApplication"><a href="#main-与UIApplication" class="headerlink" title="main() 与UIApplication"></a>main() 与UIApplication</h2><p>用 Objective-C 语言编写的程序的执行入口与C语言相同，都是 main() 函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="UIApplicationMain-函数"><a href="#UIApplicationMain-函数" class="headerlink" title="UIApplicationMain 函数:"></a><strong>UIApplicationMain</strong> 函数:</h3><ul>
<li><p>1️⃣ 创建一个 <strong>UIApplication</strong> 对象（每个iOS应用都有且只有一个该对象）。</p>
<p>作用:维护运行循环。</p>
</li>
<li><p>2️⃣ <strong>UIApplicationMain</strong> 函数还会创建某个指定类的对象，并将其设置为 <strong>UIApplication</strong> 对象的 delegate，该对象的类是由 <strong>UIApplicationMain</strong> 函数得最后一个实参指定的，该实参的类型是 <strong>NSString</strong> 对象，代表的某个类的类名。</p>
<ul>
<li>所以以上代码块中，<strong>UIApplicationMain</strong> 会创建一个 <strong>AppDelegate</strong> 对象，并将其设置为 <strong>UIApplication</strong> 对象的 delegate。</li>
<li>在应用启动运行循环并开始接收事件前，UIApplication对象会向其委托发送一个特定的消息（<code>didFinishLaunchingWithOptions:</code>）完成相应的初始化工作，该方法只会在应用启动完毕后调用一次。</li>
</ul>
</li>
</ul>
<p>初始化方法实现在 <strong>AppDelegate.m</strong> 文件中： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br></pre></td></tr></table></figure>
<h2 id="UIWindow"><a href="#UIWindow" class="headerlink" title="UIWindow"></a>UIWindow</h2><p>见 <a href="http://www.jianshu.com/p/92d077d82d0f" target="_blank" rel="noopener">UIWindow</a></p>
<h2 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h2><ul>
<li><p>视图控制器是 <strong>UIViewController</strong> 类或其子类的对象。每个视图控制器都负责管理一个视图层次结构，包括视图层次结构中的视图并处理相关用户事件，以及将整个视图层次结构添加到应用窗口。</p>
</li>
<li><p><strong>根视图控制器</strong><br> <strong>UIWindow</strong> 对象提供了一个方法将视图控制器的视图层次结构加入应用窗口：<code>setRootViewController</code>,当程序将某个视图控制器设置为 <strong>UIWindow</strong> 对象的 rootViewControl 时，<strong>UIWindow</strong> 对象会将该视图控制器的view作为子视图加入窗口，此外，还会自动调整view的大小，将其设置为与窗口的大小相同。<code>rootViewControl</code> 的 view 需要在应用启动完毕之后就显示，所以 <strong>UIWindow</strong> 对象会在设置完<code>rootViewControl</code> 后立刻加载其 view 。</p>
</li>
<li><p><strong>根视图控制器创建步骤：</strong></p>
<ol>
<li>创建 <strong>UIViewController</strong> 的子类<br><code>@interface myViewController : UIViewController</code></li>
<li>在 <strong>AppDelegate.h</strong> 中声明属性<br><code>@property (strong,nonatomic) UIViewController *viewController;</code></li>
<li>在 <strong>AppDelegate.m</strong> 中实现初始化</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 方法一：</span><br><span class="line">// 设置根视图控制器</span><br><span class="line">BNRMyViewController *mvc = [[BNRyViewController alloc]init]; </span><br><span class="line">self.window.rootViewController = mvc;</span><br><span class="line"></span><br><span class="line">// 方法二：</span><br><span class="line">// 获取指向 NSbundle 对象的指针，该 NSBundle 对象代表应用程序的主程序包</span><br><span class="line">// mainBundle 主程序包对应于文件系统中项目的根目录</span><br><span class="line">NSBundle *appBundle = [NSBundle mainBundle];</span><br><span class="line">// 告诉初始化方法在 appBundle 中查找 HQLReminderViewController.xib 文件</span><br><span class="line">self.viewController = [[myViewController alloc] initWithNibName:@&quot;HQLReminderViewController&quot; bundle: appBundle];</span><br><span class="line">//将 viewController 作为 window 的根视图控制器</span><br><span class="line">self.window.rootViewController =self.viewController;</span><br></pre></td></tr></table></figure>
<p>上述方法二中对【对象是通过 XIB 文件创建的根视图控制器】设置同样可使用方法一实现，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HQLReminderViewController *rvc = [[HQLReminderViewController alloc] init];</span><br><span class="line">self.window.rootViewController = rvc;</span><br></pre></td></tr></table></figure></p>
<p>为什么向一个需要使用 NIB 文件的视图控制器发送 <code>init</code> 消息也能成功加载对应的视图？</p>
<p><strong>原因</strong>：</p>
<ul>
<li><code>initWithNibName：bundle：</code> 是 <strong>UIViewController</strong> 的指定初始化方法。</li>
<li>向视图控制器发送 <code>init</code> 消息会调用指定初始化方法  <code>initWithNibName：bundle：</code> 并为两个参数都传入nil。</li>
<li>即使向一个需要使用 NIB 文件的视图控制器发送 <code>init</code> 消息，<strong>UIViewControl</strong> 对象仍然会在应用程序中查找和当前 <code>UIViewControl</code> 子类同名的 XIB 文件。</li>
<li>⚠️ 因此建议为 【<strong>UIViewController</strong> 子类】和【该子类需要载入的NIB文件】取相同的名称，这样当视图控制器需要加载视图时，会自动载入正确的XIB文件。    </li>
</ul>
<h3 id="lazy-loading-延迟加载视图"><a href="#lazy-loading-延迟加载视图" class="headerlink" title="lazy loading 延迟加载视图"></a>lazy loading 延迟加载视图</h3><ul>
<li>视图控制器不会在其被创建出来的那一刻马上创建并载入相应的视图，只有当应用需要将某个视图控制器的视图显示到屏幕上时，相应的视图控制器才会创建其视图。</li>
<li>也就是说，视图控制器刚被创建时，其 <code>view</code> 属性会被初始化为 <strong>nil</strong>。之后，当应用需要将视图控制器的视图显示到屏幕上时，如果 <code>view</code> 属性是 <strong>nil</strong>,就会自动调用 <code>loadview</code> 方法。</li>
<li>⚠️ 为了实现视图延迟加载，<code>在initWithNibName：bundle：</code>中不应该访问 <code>view</code> 或 <code>View</code> 的任何子视图。凡是和 <code>view</code>或 <code>view</code>的子视图有关的代码，都应该在 <code>viewDidLoad</code> 方法中实现，避免加载不需要在屏幕上显示的视图。</li>
<li>视图控制器可以通过两种方式创建视图层次结构<ul>
<li>代码方式：覆盖 <strong>UIViewController</strong> 中的 <code>loadView</code> 方法</li>
<li>文件方式：使用 interface builder 创建一个 NIB 文件，然后加入所需的视图层次结构，最后视图控制器会在运行时加载由该 NIB 文件编译而成的 XIB 文件。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> - (void)loadView &#123;  </span><br><span class="line"></span><br><span class="line">//创建一个 HQLHypnosisView 对象</span><br><span class="line">HQLHypnosisView *backgroundView = [[HQLHypnosisView alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</span><br><span class="line">self.view = backgroundView;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上述代码中，将 HQLHypnosisView 对象赋值给视图控制器的 <code>view</code> 属性。</p>
</li>
<li><p><code>view</code> 属性继承自 <strong>UIViewControl</strong> :</p>
<p>   <code>@property(null_resettable, nonatomic,strong) UIView *view;</code><br>   如果视图还没有被设置，那么get方法会首先调用自身的 loadView 方法，如果重写了 setter 或 getter 方法，子类必须调用父类。</p>
</li>
</ul>
<h3 id="运行循环和重绘视图"><a href="#运行循环和重绘视图" class="headerlink" title="运行循环和重绘视图"></a>运行循环和重绘视图</h3><ul>
<li>iOS 应用启动时会开始一个运行循环（run loop）。运行循环的工作是监听事件，当事件发生时运行循环会为相应的事件找到合适的处理方法（类似于单片机中的中断处理机制）,只有当调用的处理方法都执行完毕时，控制权才会再次回到运行循环。</li>
<li>当应用将控制权交回给运行循环时，运行循环首先会检查是否有等待重绘的视图（即在当前循环收到 <code>setNeedsDisplay</code> 消息的视图），然后向所有等待重绘的视图发送  <code>drawRect</code>  消息，最后视图层次结构中所有视图的图层再次组合成一幅完整的图像并绘制到屏幕上。</li>
<li>iOS 做了两方面来保证用户界面的流畅性<ol>
<li>不重绘显示的内容没有改变的视图；</li>
<li>在每次事件处理周期（event handing cycle）中只发送一次 <code>drawRect:</code> 消息。iOS 会在运行循环的最后阶段集中处理所有需要重绘的视图。</li>
</ol>
</li>
</ul>
<h2 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h2><h3 id="添加视图"><a href="#添加视图" class="headerlink" title="添加视图"></a>添加视图</h3><p><strong>frame</strong>:用于确定与视图层次结构中其他视图的相对位置，从而将自己的图层与其他视图的图层正确组合屏幕上的图像。<br><strong>bounds</strong>:用于确定绘制区域，避免将自己绘制到图层边界之外。<br><strong>frame </strong>是从父视图的坐标系统来看的，而 <strong>bounds</strong> 是从本身的坐标系统来看的.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-6b0e6cf74b47e40a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="frame与bounds的区别"></p>
<p>视图的相关结构：<br>Core Graphics( CG )</p>
<ul>
<li><p><strong>CGPoint</strong>：2D空间中的位置坐标,（x,y）<br>  生成函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* **CGSize**：某个对象的尺寸：width、height</span><br><span class="line">   生成函数：```CGSizeMake(width,height)</span><br></pre></td></tr></table></figure></p>
</li>
<li><p><strong>CGRect</strong>：位置和尺寸：origin 和 size<br> 生成函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">```objective-c</span><br><span class="line">//创建一个CGRect结构</span><br><span class="line">//CGRect firstFrame = CGRectMake(160, 240, 100, 150);</span><br><span class="line"></span><br><span class="line">CGRect firstFrame = self.window.bounds;</span><br><span class="line"></span><br><span class="line">//创建HQLHypnosisView对象</span><br><span class="line">HQLHypnosisView *firstView = [[HQLHypnosisView alloc] initWithFrame:firstFrame];</span><br><span class="line"></span><br><span class="line">//设置HQLHypnosisView背景色</span><br><span class="line">firstView.backgroundColor = [UIColor greenColor];</span><br><span class="line"></span><br><span class="line">//将HQLHypnosisView对象加入UIWindow对象</span><br><span class="line">[self.window addSubview:firstView];</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<p>也可以在 <strong>HQLHypnosisView.m</strong> 中复写 <strong>initWithFrame:</strong> 方法设置 HQLHypnosisView 背景色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">self =[super initWithFrame:frame];</span><br><span class="line">if (self) &#123;</span><br><span class="line">    //设置HQLHyponsisView对象的背景颜色为透明</span><br><span class="line">    self.backgroundColor = [UIColor clearColor];</span><br><span class="line">	&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="视图层次的嵌套"><a href="#视图层次的嵌套" class="headerlink" title="视图层次的嵌套"></a>视图层次的嵌套</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HQLHypnosisView *secondView = [[HQLHypnosisView alloc] <span class="string">initWithFrame:</span>secondFrame];</span><br><span class="line">secondView.backgroundColor = [UIColor blueColor];</span><br><span class="line"></span><br><span class="line"><span class="comment">//将 secondView 添加到 window 上</span></span><br><span class="line">[self.window <span class="string">addSubview:</span>secondView];</span><br><span class="line"></span><br><span class="line"><span class="comment">//视图层次嵌套</span></span><br><span class="line"><span class="comment">//视图的frame所代表的位置是相对于其父视角的</span></span><br><span class="line"><span class="comment">//将 secondView 添加到 firstview 上</span></span><br><span class="line">[firstView <span class="string">addSubview:</span>secondView];</span><br></pre></td></tr></table></figure>
<h3 id="访问视图"><a href="#访问视图" class="headerlink" title="访问视图"></a>访问视图</h3><p>通常情况下，在用户看到创建的视图之前需要对它们做一些额外的初始化工作。<br>两种访问NIB文件视图的方法：</p>
<ul>
<li><code>-viewDidLoad:</code> 该方法会在视图控制器加载完视图之后被调用，此时视图控制器中所有视图属性都已经指向了正确的视图对象。</li>
<li><code>-viewWillAppear:</code>该方法会在视图控制器的 view 添加到应用窗口之前被调用。<br><strong>区别：</strong> ⚠️ <strong>如果只需要在应用启动后设置一次视图对象，就选择 <code>viewDidLoad</code>；如果用户每次看到视图控制器的 view 时都需要对其进行设置，则选择 <code>viewWillAppear</code>。</strong></li>
<li><p>相反，<code>viewWillDisappear:</code> 和 <code>viewDidDisappear</code>方法会在每次视图控制器的 view 从屏幕上消失时被调用。</p>
</li>
<li><p><a href="http://www.cnblogs.com/mjios/archive/2013/02/26/2933667.html" target="_blank" rel="noopener">loadView、viewDidLoad及viewDidUnload的关系</a></p>
</li>
</ul>
<h3 id="设置启动页面延时"><a href="#设置启动页面延时" class="headerlink" title="设置启动页面延时"></a>设置启动页面延时</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//延时3秒</span><br><span class="line">[NSThread sleepForTimeInterval:3.0];</span><br></pre></td></tr></table></figure>
<h1 id="运动效果"><a href="#运动效果" class="headerlink" title="运动效果"></a>运动效果</h1><p>iOS 设备内嵌了许多功能强大的传感器，例如加速传感器，磁场传感器和三轴陀螺仪等。应用可以通过这些传感器了解设备的速度、方向和角度，并实现有用的功能。</p>
<p>例如，应用可以根据设备的方向自动将界面调整为横排模式或竖排模式。从iOS 7开始，Apple 引入了一些新API，可以轻松为应用添加一种通过感应器实现的视差（parallax）效果。</p>
<p>在 <strong>HQLHyponViewController.m</strong> 中修改<code>drawHyponticMessage:</code>方法，为 <strong>UILabel</strong> 对象分别添加水平方向和垂直方向的视差效果，使 <strong>UILabel</strong> 对象的中心点坐标在每个方向上最多移动25点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//在屏幕随机位置绘制20个UILabel对象</span><br><span class="line">- (void)drawHypnoticMessage:(NSString *)message &#123;</span><br><span class="line"></span><br><span class="line">for (int i =0; i&lt;20; i++) &#123;</span><br><span class="line">    UILabel *messageLabel = [[UILabel alloc] init];</span><br><span class="line">    //设置UILabel对象的文字和颜色</span><br><span class="line">    messageLabel.backgroundColor = [UIColor clearColor];</span><br><span class="line">    messageLabel.textColor = [UIColor whiteColor];</span><br><span class="line">    messageLabel.text = message;</span><br><span class="line">    //根据需要显示的文字调整UILabel对象的大小</span><br><span class="line">    [messageLabel sizeToFit];</span><br><span class="line">    </span><br><span class="line">    //获取随机x坐标</span><br><span class="line">    //使UILabel对象的宽度不超出HQLHyponsisViewController的view的宽度</span><br><span class="line">    int width = (int)(self.view.bounds.size.width - messageLabel.bounds.size.width);</span><br><span class="line">    int x = arc4random() % width;</span><br><span class="line">    </span><br><span class="line">    //获取随机y坐标</span><br><span class="line">    //使UILabel对象的高度不超出HQLHyponsisViewController的view的高度</span><br><span class="line">    int height = (int)(self.view.bounds.size.width - messageLabel.bounds.size.height);</span><br><span class="line">    int y =184 + arc4random() % height;</span><br><span class="line">    </span><br><span class="line">    //设置UILabel对象的frame</span><br><span class="line">    CGRect frame = messageLabel.frame;</span><br><span class="line">    frame.origin = CGPointMake(x, y);</span><br><span class="line">    messageLabel.frame = frame;</span><br><span class="line">    </span><br><span class="line">    //将UILabel对象添加到HQLHyponsisViewController的view中</span><br><span class="line">    [self.view addSubview:messageLabel];</span><br><span class="line">    </span><br><span class="line">    //运行效果:水平方向和垂直方向的视差效果</span><br><span class="line">  	//设置UILabel 对象的中心点坐标在每个方向上最多移动25点</span><br><span class="line">    UIInterpolatingMotionEffect *motionEffect;</span><br><span class="line">    motionEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@&quot;center.x&quot; type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis];</span><br><span class="line">    motionEffect.minimumRelativeValue = @(-25);</span><br><span class="line">    motionEffect.maximumRelativeValue = @(25);</span><br><span class="line">    [messageLabel addMotionEffect:motionEffect];</span><br><span class="line">    </span><br><span class="line">    motionEffect = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@&quot;center.y&quot; type:UIInterpolatingMotionEffectTypeTiltAlongVerticalAxis];</span><br><span class="line">    motionEffect.minimumRelativeValue = @(-25);</span><br><span class="line">    motionEffect.maximumRelativeValue = @(25);</span><br><span class="line">    [messageLabel addMotionEffect:motionEffect];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LocalNotification（本地通知）"><a href="#LocalNotification（本地通知）" class="headerlink" title="LocalNotification（本地通知）"></a>LocalNotification（本地通知）</h1><p><strong>本地通知</strong>（local notification）用于向用户提示一条消息，即使应用没有运行，用户也可以收到本地通知。<br>应用还可以通过后台服务器实现推送通知（push notification）.有关推送通知的技术细节请参考Apple的Local and Push Notification Programming Guide（本地通知和推送通知编程指南）。<br>Demo:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-5bd235356d1e2922.gif?imageMogr2/auto-orient/strip" alt="locolNotification.gif"></p>
<p>实现本地通知方法代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)addReminder:(id)sender &#123;</span><br><span class="line">    </span><br><span class="line">    NSDate *date = self.datePicker.date;</span><br><span class="line">    NSLog(@&quot;Setting a reminder for %@&quot;,date);</span><br><span class="line">    </span><br><span class="line">    if ([UIApplication instancesRespondToSelector:@selector(registerUserNotificationSettings:)])&#123;</span><br><span class="line">        </span><br><span class="line">        [[UIApplication sharedApplication] registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound categories:nil]];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 创建 UILocalNotification 对象</span><br><span class="line">    UILocalNotification *note = [[UILocalNotification alloc] init];</span><br><span class="line">    // 设置显示内容</span><br><span class="line">    note.alertBody = @&quot;Hypnotize me!&quot;;</span><br><span class="line">    // 设置提醒时间</span><br><span class="line">    note.fireDate = date;</span><br><span class="line">    </span><br><span class="line">    // 使用 scheduleLocalNotification: 方法注册通知</span><br><span class="line">    [[UIApplication sharedApplication] scheduleLocalNotification:note];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;addReminder run over&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="UITabBarController"><a href="#UITabBarController" class="headerlink" title="UITabBarController"></a>UITabBarController</h1><p>参考： <a href="http://www.jianshu.com/p/33d3300afd91" target="_blank" rel="noopener">UITabBarController（标签栏）</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.jianshu.com/p/2e8ef223efef" target="_blank" rel="noopener">天才第一步，从UIWindow谈起 @吴白</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/18/《iOS编程（第四版）》Demo1：Quiz/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/18/《iOS编程（第四版）》Demo1：Quiz/" class="post-title-link" itemprop="url">《iOS编程（第四版）》Demo1：Quiz</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-18 17:08:00" itemprop="dateCreated datePublished" datetime="2016-08-18T17:08:00+08:00">2016-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-17 17:26:08" itemprop="dateModified" datetime="2019-04-17T17:26:08+08:00">2019-04-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/18/《iOS编程（第四版）》Demo1：Quiz/" class="leancloud_visitors" data-flag-title="《iOS编程（第四版）》Demo1：Quiz">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<blockquote>
<p>《iOS编程》Demo应用：Quiz</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/2648731-dac10288198f7605.gif?imageMogr2/auto-orient/strip" alt="Quiz应用"></p>
<p> 功能：在视图中显示一个问题，用户点击视图下方的按钮，可以显示相应的答案，用户点击上方的按钮，则会显示一个新的问题   </p>
<h1 id="第1章-第一个简单的iOS应用"><a href="#第1章-第一个简单的iOS应用" class="headerlink" title="第1章 第一个简单的iOS应用"></a>第1章 第一个简单的iOS应用</h1><h2 id="1-1-创建Xcode项目"><a href="#1-1-创建Xcode项目" class="headerlink" title="1.1 创建Xcode项目"></a>1.1 创建Xcode项目</h2><ul>
<li>位于工作空间窗口左侧的是导航面板区域（navigator area），负责显示各种不同的导航面板。</li>
<li>项目导航面板（project navigator）：显示项目中的文件。</li>
<li>项目导航面板中的组只用来整理文件，与文件系统无关。</li>
<li>一个类（class）表示一种对象（object）。iOS开发是面向对象的，每个iOS应用都可以看成是由一系列协同工作的对象构成的。</li>
</ul>
<h2 id="1-2-模型-视图-控制器"><a href="#1-2-模型-视图-控制器" class="headerlink" title="1.2 模型-视图-控制器"></a>1.2 模型-视图-控制器</h2><p><strong>MVC设计模式</strong>的含义：应用创建的任何一个对象，其类型必定是模型对象、视图对象或者控制器对象三种类型中的一个。</p>
<ul>
<li>【视图对象】是用户可以看见的对象，用来构建用户界面。</li>
<li>【模型对象】负责存储数据，与用户界面无关。通常情况下，【模型对象】表示真实世界中与用户相关的事物。</li>
<li>【控制器对象】扮演“管家”的角色，它用于控制【视图对象】为用户呈现的内容，以及负责确保【视图对象】和【模型对象】的数据保持一致。</li>
</ul>
<blockquote>
<p>⚠️  【模型对象】和【视图对象】之间没有直接产生联系，而是由【控制器对象】负责彼此间的消息发送和数据传递。</p>
</blockquote>
<h2 id="1-3-设计Quiz"><a href="#1-3-设计Quiz" class="headerlink" title="1.3 设计Quiz"></a>1.3 设计Quiz</h2><p>开发中需要使用的对象：</p>
<ul>
<li>四个视图对象：<strong>UILabel</strong> 和 <strong>UIButton</strong>；</li>
<li>两个控制器对象：<strong>AppDelegate</strong>、<strong>QuizViewControl</strong>的对象各一个；</li>
<li>两个模型对象：<strong>NSArray</strong> 的对象两个；</li>
</ul>
<h2 id="1-4-创建视图控制器"><a href="#1-4-创建视图控制器" class="headerlink" title="1.4 创建视图控制器"></a>1.4 创建视图控制器</h2><h2 id="1-5-创建界面"><a href="#1-5-创建界面" class="headerlink" title="1.5 创建界面"></a>1.5 创建界面</h2><ul>
<li><p>Xcode 会使用 Interface Builder （界面创建工具）打开 XIB 文件。Interface Builder 是一种可视化编辑器，可以用拖动对象的方式创建图形用户界面。</p>
</li>
<li><p>XIB 的全称就是 XML Interface Builder。</p>
</li>
</ul>
<h3 id="创建视图对象"><a href="#创建视图对象" class="headerlink" title="创建视图对象"></a>创建视图对象</h3><h3 id="NIB文件"><a href="#NIB文件" class="headerlink" title="NIB文件"></a>NIB文件</h3><p>构建项目时，所有XIB文件都会被编译成NIB文件（NIB文件体积更小，更容易解析），然后Xcode会将NIB文件拷贝至应用的程序包（bundle）中。</p>
<h2 id="1-6-创建关联"><a href="#1-6-创建关联" class="headerlink" title="1.6 创建关联"></a>1.6 创建关联</h2><p>在 Interface Builder中可以创建两种关联</p>
<ul>
<li><strong>插座变量</strong>（outlets）:指向对象的指针；</li>
<li><strong>动作</strong>（actions）：一种方法，在视图对象和用户发生交互时被调用。</li>
</ul>
<h3 id="设置插座变量"><a href="#设置插座变量" class="headerlink" title="设置插座变量"></a>设置插座变量</h3><h2 id="1-7-创建模型对象"><a href="#1-7-创建模型对象" class="headerlink" title="1.7 创建模型对象"></a>1.7 创建模型对象</h2><p><a href="https://github.com/Andy0570/QUIZ.git" target="_blank" rel="noopener">gitHub下载</a></p>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul>
<li><a href="http://www.infoq.com/cn/articles/rethinking-mvc-mvvm" target="_blank" rel="noopener">被误解的MVC和被神化的MVVM</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/08/Objective-C_Foundation框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/08/Objective-C_Foundation框架/" class="post-title-link" itemprop="url">Objective-C_Foundation框架</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-08 10:48:00" itemprop="dateCreated datePublished" datetime="2016-08-08T10:48:00+08:00">2016-08-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-18 00:36:47" itemprop="dateModified" datetime="2019-04-18T00:36:47+08:00">2019-04-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C-编程/" itemprop="url" rel="index"><span itemprop="name">Objective-C 编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/08/Objective-C_Foundation框架/" class="leancloud_visitors" data-flag-title="Objective-C_Foundation框架">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h3 id="Foundation框架"><a href="#Foundation框架" class="headerlink" title="Foundation框架"></a>Foundation框架</h3><ul>
<li><strong>框架</strong>是由许多类、方法、函数组成的一个类库。以便于开发者更方便的开发程序。</li>
<li>许多框架的集合构成了<strong>SDK（开发工具包）</strong>。</li>
<li><strong>Foundation</strong>是OC语言的基础类库。此框架中的类都以 “NS” 为前缀,便于与其他类区分开。</li>
<li><strong>UIKit框架</strong>是UI界面的基础库<br>Foundation中的大部分类都提供了两种方式创建对象:<ul>
<li>alloc创建：<code>NSNumber *number1 = [[NSNumber alloc] initWithInt:100];</code></li>
<li>类方法创建：<code>NSNumber *number2 = [NSNumber numberWithInt:100];</code> </li>
</ul>
</li>
</ul>
<h3 id="NSObject类、延迟调用"><a href="#NSObject类、延迟调用" class="headerlink" title="NSObject类、延迟调用"></a>NSObject类、延迟调用</h3><p><strong>NSObject</strong>类是一切类的根类(基类),它是没有父类,它是所有对象的“生命”方法,也是了对象生终的“终结”。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>比较两个指针是否指向同一个对象(指针是否指向同一个内存区域)<br>  <code>- (BOOL)isEqual:(id)object;</code></li>
<li>调用一个方法<br>  <code>- (id)performSelector:(SEL)aSelector;</code></li>
<li>调用一个方法,并且传递一个参数<br>  <code>- (id)performSelector:(SEL)aSelector withObject:(id)object;</code></li>
<li>调用一个方法,并且传递2个参数<br>  <code>- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</code></li>
<li>某一个对象是否派生或属于某一类<br>  <code>- (BOOL)isKindOfClass:(Class)aClass;</code></li>
<li>某一个对象是否属于某类<br>  <code>- (BOOL)isMemberOfClass:(Class)aClass;</code></li>
<li>某对象是否响应指定的方法<br>  <code>- (BOOL)respondsToSelector:(SEL)aSelector;</code></li>
<li><p>返回指定对象的父类和本类<br>  <code>- (Class)superclass;  - (Class)class;</code></p>
<p>  例：假设 demo1 是一个私有方法（在 .m 文件中实现，但在 .h 文件中没有声明的方法）</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//创建了一个方法选择器，封装demo1方法   </span></span><br><span class="line">	SEL selector1 = <span class="meta">@selector</span>(demo1);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//在performSelector方法中调用selector1方法选择器，也就是demo1</span></span><br><span class="line">   [<span class="keyword">super</span> <span class="string">performSelector:</span>selector1];</span><br><span class="line">	[self <span class="string">performSelector:</span>selector1];  <span class="comment">//同上</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//perform调用带1个参数的方法，@"hello"传给了demo2:的形参</span></span><br><span class="line">    [self <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">demo2:</span>)</span><br><span class="line"><span class="symbol">               withObject:</span>@<span class="string">"hello"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用带2个参数的方法</span></span><br><span class="line">	[self <span class="string">performSelector:</span>(SEL)</span><br><span class="line"><span class="symbol">	              withObject:</span>(id)</span><br><span class="line"><span class="symbol">	               withObject:</span>(id)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//延迟调用</span></span><br><span class="line">    [self demo1];  <span class="comment">//没有延迟，立马调用demo1方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//延迟调用demo1，但是代码执行到此处时，不会停在此处3秒钟</span></span><br><span class="line">    [self <span class="string">performSelector:</span><span class="meta">@selector</span>(demo1) <span class="string">withObject:</span>nil <span class="string">afterDelay:</span><span class="number">3.0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>//让程序保持运行状态
[[NSRunLoop currentRunLoop] run];
</code></pre><hr>
<h4 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h4><ul>
<li><a href="http://www.jianshu.com/p/c4eadf54cd25" target="_blank" rel="noopener">第16章——NSString</a></li>
</ul>
<hr>
<h4 id="NSMutableString"><a href="#NSMutableString" class="headerlink" title="NSMutableString"></a>NSMutableString</h4><ul>
<li><a href="http://www.jianshu.com/p/b628c48be542" target="_blank" rel="noopener">第16章——NSMutableString</a></li>
</ul>
<hr>
<h4 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h4><ul>
<li><a href="http://www.jianshu.com/p/aaa89e070f84" target="_blank" rel="noopener">第17章——NSArray</a></li>
</ul>
<hr>
<h4 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h4><ul>
<li><a href="http://www.jianshu.com/p/64443aecc4dd" target="_blank" rel="noopener">第17章——NSMutableArray</a></li>
</ul>
<hr>
<h4 id="Collection-类"><a href="#Collection-类" class="headerlink" title="Collection 类"></a>Collection 类</h4><ul>
<li><a href="http://www.jianshu.com/p/d84d570fe6a9" target="_blank" rel="noopener">第24章——Collection 类</a></li>
</ul>
<hr>
<h4 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h4><ul>
<li><a href="http://www.jianshu.com/p/6fa0926dd478" target="_blank" rel="noopener">NSNumber</a></li>
</ul>
<hr>
<h4 id="NSValue"><a href="#NSValue" class="headerlink" title="NSValue"></a>NSValue</h4><ul>
<li><a href="http://www.jianshu.com/p/928502aba37a" target="_blank" rel="noopener">NSValue</a></li>
</ul>
<hr>
<h4 id="NSNull"><a href="#NSNull" class="headerlink" title="NSNull"></a>NSNull</h4><p>我们之前提到,不能在集合(collection) 中存储nil值,因为字典和数组中nil都有特殊的含义,但有时候你确实需要存储一个表示“什么都没有”的值。那就用 <strong>NSNull</strong> 代替,表示什么都不是,什么都没有。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [zhangsan,lisi,  ,zhaoliu];</span></span><br><span class="line">NSNull *<span class="keyword">null</span> = [NSNull <span class="keyword">null</span>];</span><br><span class="line">NSArray *<span class="keyword">array</span> = @[@<span class="string">"zhagnsan"</span>,@<span class="string">"lisi"</span>,<span class="keyword">null</span>,@<span class="string">"zhaoliu"</span>];</span><br></pre></td></tr></table></figure>
<h5 id="线上的一个实际例子："><a href="#线上的一个实际例子：" class="headerlink" title="线上的一个实际例子："></a>线上的一个实际例子：</h5><p>本意：如果用户已经成功登录，就获取存储在磁盘上的用户名：<br> <code>NSDictionary *dictionary = @{@&quot;username&quot;:_username};</code><br>实际生产环境中，发生了这样的情况：判断用户已经登录成功，但是无法获取用户名导致应用crash。<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">attachDatas:</span></span><br><span class="line"><span class="symbol">Exception:</span>&#123;</span><br><span class="line">    Name = NSInvalidArgumentException<span class="comment">;</span></span><br><span class="line">    Reason = <span class="string">"*** -[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[0]"</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最初的修复方法是，判断为nil,就传入一个空字符串： @””：<br><code>NSDictionary *dictionary = @{@&quot;username&quot;:_username?:@&quot;&quot;};</code><br>规范的方法是传入一个空对象：<br> <code>NSDictionary *dictionary = @{@&quot;username&quot;:_username?:[NSNull null]};</code><br>参考：<a href="http://nshipster.cn/nil/" target="_blank" rel="noopener">nshipster: nil / Nil / NULL / NSNull</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://andy0570.com/2016/08/08/Objective-C_KVO、KVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="独木舟的木">
      <meta itemprop="description" content="有时候阳光很好 有时候阳光很暗">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="独木舟的木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/08/08/Objective-C_KVO、KVC/" class="post-title-link" itemprop="url">Objective-C_KVO、KVC</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-08-08 10:48:00" itemprop="dateCreated datePublished" datetime="2016-08-08T10:48:00+08:00">2016-08-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-18 00:38:21" itemprop="dateModified" datetime="2019-04-18T00:38:21+08:00">2019-04-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Objective-C-编程/" itemprop="url" rel="index"><span itemprop="name">Objective-C 编程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2016/08/08/Objective-C_KVO、KVC/" class="leancloud_visitors" data-flag-title="Objective-C_KVO、KVC">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><h3 id="键值编码的基本概念"><a href="#键值编码的基本概念" class="headerlink" title="键值编码的基本概念"></a>键值编码的基本概念</h3><ol>
<li><strong>KVC</strong> 是 <strong>KeyValue Coding</strong> 的简称，它是一种可以直接通过字符串的名字(key)来访问属性的机制。使用该机制不需要调用存取方法和变量实例就可访问对象属性。本质上讲，键-值编码定义了你的程序存取方法需要实现的样式及方法签名。</li>
<li>在应用程序中实现键-值编码兼容性是一项重要的设计原则。存取方法可以加<br>强合适的数据封装，而键-值编码方法在多数情况下可简化程序代码。</li>
<li>键-值编码方法在 Objective-C 非标准协议（类目）<strong>NSKeyValueCoding</strong>中被声明，默认的实现方法由 <strong>NSObject</strong> 提供，所以凡是继承自 <strong>NSObject</strong> 的类都具备 KVC 功能。</li>
<li>键-值编码支持带有对象值的属性，同时也支持纯数值类型和结构。非对象参<br>数和返回类型会被识别并自动封装/解封。</li>
</ol>
<h3 id="设置和访问"><a href="#设置和访问" class="headerlink" title="设置和访问"></a>设置和访问</h3><ul>
<li>键/值编码中的基本调用包括 <code>-valueForKey：</code> 和 <code>-setValue：forkey：</code> 这两个<br>方法，它们以字符串的形式向对象发送消息，字符串是我们关注属性的关键。</li>
</ul>
<p>示例1：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BNRAppliance *a = [[BNRAppliance alloc] init];</span><br><span class="line"></span><br><span class="line">[a <span class="string">setProductName:</span>@<span class="string">"Washing Machine"</span>];</span><br><span class="line"><span class="comment">// 使用 KVC 重写以上代码</span></span><br><span class="line"> [a <span class="string">setValue:</span>@<span class="string">"Washing Machine"</span> <span class="string">forKey:</span>@<span class="string">"productName"</span>];</span><br><span class="line">        </span><br><span class="line">[a <span class="string">setVoltage:</span><span class="number">240</span>];</span><br><span class="line"><span class="comment">// 使用 KVC 重写以上代码</span></span><br><span class="line">[a <span class="string">setValue:</span>[NSNumber <span class="string">numberWithInt:</span><span class="number">240</span>] <span class="string">forKey:</span>@<span class="string">"voltage"</span>];</span><br><span class="line">        </span><br><span class="line"> NSLog(@<span class="string">"a is %@"</span>,a);</span><br><span class="line"> <span class="comment">// 使用 KVC 重写以上代码</span></span><br><span class="line"> NSLog(@<span class="string">"the product name is %@"</span>,[a <span class="string">valueForKey:</span>@<span class="string">"productName"</span>]);</span><br></pre></td></tr></table></figure></p>
<p>示例2：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person *<span class="keyword">jack </span>= [[Person alloc] init]<span class="comment">;</span></span><br><span class="line">NSMutableString *name = [[NSMutableString alloc] initWithFormat:@<span class="string">"jack"</span>]<span class="comment">;</span></span><br><span class="line">[<span class="keyword">jack </span>setValue:name forKey:@<span class="string">"name"</span>]<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">"jack name : %@"</span>, [<span class="keyword">jack </span>valueForKey:@<span class="string">"name"</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>使用KVC，编译器会查找是否存在 <strong>setter</strong>、<strong>getter</strong> 方法，如果不存在，它将在内部查找名为 <strong>_key</strong> 或 <strong>key</strong> 的实例变量。通过 KVC，可以获取不存在<strong>getter</strong>方法的对象值，无需通过对象指针直接访问。</li>
<li>KVC 能够在没有存取方法的情况下直接存取实例变量。</li>
<li>⚠️非对象类型：当我们通过 <code>setValue：forKey：</code> 设置对象的值，或通过<br><code>valueForKey</code> 来获取对象的值时，如果对象的实例变量为基本数据类型（<strong>char、int、float、BOOL</strong>）时，我们需要使用 <strong>NSNumber</strong> 对象对数据进行 <strong>封装</strong>。</li>
</ul>
<h3 id="key路径"><a href="#key路径" class="headerlink" title="key路径"></a>key路径</h3><ul>
<li>除了通过键设置值外，键/值编码还支持指定路径，像文件系统一样。用“点”<br>号隔开。</li>
<li>使用 key path 可以一次性遍历复杂的对象表。</li>
<li>注意顺序，第一个想要遍历的对象放在第一个。</li>
</ul>
<p>示例：<br><code>BNRDepartment. manager</code> 指向 <code>BNREmployee. emergencyContact</code> 指向 <code>BNRPerson. phoneNumber</code></p>
<pre><code>BNRDepartment *sales = ...;
BNREmployee *sickEmployee = [sales valueForKey:@&quot;manager&quot;];
BNRPerson *personToCall = [sickEmployee valueForKey:@&quot;emergencyContact&quot;];
[personToCall setValue:@&quot;555-606-0842&quot; forKey:@&quot;phoneNumber&quot;];

// 使用 Key路径 重写以上代码
BNRDepartment *sales = ...;
[personToCall setValue:@&quot;555-606-0842&quot;
            forKeyPath:@&quot;manager.emergencyContact.phoneNumber&quot;];
</code></pre><h3 id="一对多的关系"><a href="#一对多的关系" class="headerlink" title="一对多的关系"></a>一对多的关系</h3><ul>
<li>如果向 <strong>NSArray</strong> 请求一个键值，它实际上会查询数组中的每个对象来查找这个<br>键值，然后将查询结果打包到另一个数组中并返回给你。</li>
</ul>
<pre><code>NSArray *booksArray = [NSArray arrayWithObjects:book1, book2, nil];
[book1 release];
[book2 release];
[book setValue:booksArray forKey:@&quot;relativeBooks&quot;];
NSLog(@&quot;books 2: %@&quot;, [book valueForKeyPath:@&quot;relativeBooks.price&quot;]);
</code></pre><h3 id="实现简单的运算"><a href="#实现简单的运算" class="headerlink" title="实现简单的运算"></a>实现简单的运算</h3><pre><code>NSString *count = [book valueForKeyPath:@&quot;relativeBooks.@count&quot;];
NSLog(@&quot;count : %@&quot;, count);
NSString *sum = [book valueForKeyPath:@&quot;relativeBooks.@sum._price&quot;];
NSLog(@&quot;sum : %@&quot;, sum);
NSString *avg = [book valueForKeyPath:@&quot;relativeBooks.@avg._price&quot;];
NSLog(@&quot;avg : %@&quot;, avg);
NSString *min = [book valueForKeyPath:@&quot;relativeBooks.@min._price&quot;];
NSLog(@&quot;min : %@&quot;, min);
NSString *max = [book valueForKeyPath:@&quot;relativeBooks.@max._price&quot;];
NSLog(@&quot;max : %@&quot;, max);
</code></pre><h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><strong>Key Value Observing</strong>，直译为：基于键值的观察者。它提供一种机制，当指定的对象的属性被修改后，则对象就会接受到通知。简单的说就是每次指定的被观察对象的属性被修改后，KVO就会自动通知相应的观察者了。</li>
<li>与 <strong>NSNotification</strong>不同，键-值观察中并没有所谓的中心对象来为所有观察者提供变化通知。取而代之地，当有变化发生时，通知被直接发送至处于观察状态的对象。<strong>NSObject</strong> 提供这种基础的键-值观察实现方法。   </li>
<li>你可以观察任意对象属性，包括简单属性，对一或是对多关系。对多关系的观察者将会被告知发生变化的类型-也就是任意发生变化的对象。</li>
<li>键-值观察为所有对象提供自动观察兼容性。你可以通过禁用自动观察通知并<br>实现手动通知来筛选通知。</li>
</ol>
<h3 id="注册观察者"><a href="#注册观察者" class="headerlink" title="注册观察者"></a>注册观察者</h3><p>为了正确接收属性的变更通知，观察对象必须首先发送一个<br><code>addObserver:forKeyPath:options:context:</code>消息至被观察对象，用以传送观察<br>对象和需要观察的属性的关键路径，以便与其注册。选项参数指定了发送变更通知时提供给观察者的信息。 使用<code>NSKeyValueObservingOptionOld</code>选项可以将<br>初始对象值 以变更字典中的一个项的形式提供给观察者。指定<br><code>NSKeyValueObservingOptionNew</code>选项可以将新的值以一个项的形式 添加至<br>变更字典。你可以使用逐位“|”这两个常量来指定接收上述两种类型的值。<br>示例：</p>
<pre><code>BNRLogger *logger = [[BNRLogger alloc] init];
__unused NSTimer *timer =
            [NSTimer scheduledTimerWithTimeInterval:2.0
                                             target:logger
                                           selector:@selector(updateLastTime:)
                                           userInfo:nil
                                            repeats:YES];

BNRObserver *observer = [[BNRObserver alloc] init];
// 无论 lastTime 何时发生变化，都要通知我它改变的新值以及改变之前的旧值
[logger addObserver:observer
         forKeyPath:@&quot;lastTime&quot;
            options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld
            context:nil];

[[NSRunLoop mainRunLoop] run];
</code></pre><h3 id="接受变更后通知"><a href="#接受变更后通知" class="headerlink" title="接受变更后通知"></a>接受变更后通知</h3><ul>
<li>当对象的一个被观察属性发生变动时，观察者收到一个<br><code>observeValueForKeyPath:ofObject:change:context:</code>消息。所有观察者都必须<br>实现这一方法。触发观察通知的对象和键路径、包含变更细节的字典，以及观察者<br>注册时提交的上下文指针均被提交给观察者，<code>context</code>可以为任意类型参数。<br>示例：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *oldValue = [change objectForKey:<span class="built_in">NSKeyValueChangeOldKey</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *newValue = [change objectForKey:<span class="built_in">NSKeyValueChangeNewKey</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Observed:%@ of %@ was changed from %@ to %@"</span>,</span><br><span class="line">          keyPath,object,oldValue,newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移除观察者身份"><a href="#移除观察者身份" class="headerlink" title="移除观察者身份"></a>移除观察者身份</h3><ul>
<li>你可以发送一条指定观察方对象和键路径的<code>removeObserver:forKeyPath:</code><br>消息至被观察的对象，来移除一个键-值观察者。（当我们达到目的时）<br>示例：</li>
</ul>
<pre><code>[child removeObserver:self forKeyPath:@&quot;key&quot;];
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/30/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/32/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://ws1.sinaimg.cn/large/006tNc79gy1g22m14458rj30u014xu0x.jpg" alt="独木舟的木">
            
              <p class="site-author-name" itemprop="name">独木舟的木</p>
              <div class="site-description motion-element" itemprop="description">有时候阳光很好 有时候阳光很暗</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">317</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">36</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Andy0570" title="GitHub &rarr; https://github.com/Andy0570" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:andywhm@163.com" title="E-Mail &rarr; mailto:andywhm@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          
             <div class="cc-license motion-element" itemprop="license">
              
              
                
              
              
              
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
             </div>
          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">独木舟的木</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





  



  






  



  
    
    
      
    
  
  <script color="17,119,176" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>













  
  <script src="//cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/npm/fastclick@1/lib/fastclick.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/npm/jquery-lazyload@1/jquery.lazyload.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  
  
  
    
  

  
    
      
    
  

  
  
  
    <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
    <script>
      
        window.addEventListener('load', () => {
      
        quicklink({
          timeout: 3000,
          priority: true,
          ignores: [uri => uri.includes('#'),uri => uri == 'https://andy0570.com/page/31/',]
        });
      
        });
      
    </script>
  


  



  



  
  
  
    
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">

  
  
    
  
  <script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.js"></script>
  

  <script src="/js/algolia-search.js?v=7.1.0"></script>



  
  
  <script>
    
    function showTime(Counter) {
      var entries = [];
      var $visitors = $('.leancloud_visitors');

      $visitors.each(function() {
        entries.push( $(this).attr('id').trim() );
      });

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url: { '$in': entries } }) })
        .done(function({ results }) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if (countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'S7i1Y8YorMKFPaYbJbekD5el-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'S7i1Y8YorMKFPaYbJbekD5el-gzGzoHsz',
                'X-LC-Key': 'brOnU8mOQvSjpipJvdKUAIbU',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            if ($('.post-title-link').length >= 1) {
              showTime(Counter);
            }
          
        });
    });
  </script>



  

  

  

  

  

  

  

  

  
  
  
    
  
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script>pangu.spacingPage();</script>


  
  
  
    
  
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1/bookmark.min.js"></script>
  <script>
  
    bookmark.loadBookmark();
  
  </script>


  

  

  


  <!-- red heart -->
  <script type="text/javascript" src="/js/src/love.js"></script>
  
</body>
</html>
